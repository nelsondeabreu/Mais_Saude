
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model EntidadesSistema
 * 
 */
export type EntidadesSistema = $Result.DefaultSelection<Prisma.$EntidadesSistemaPayload>
/**
 * Model Endereco
 * 
 */
export type Endereco = $Result.DefaultSelection<Prisma.$EnderecoPayload>
/**
 * Model Contactos
 * 
 */
export type Contactos = $Result.DefaultSelection<Prisma.$ContactosPayload>
/**
 * Model Especialistas
 * 
 */
export type Especialistas = $Result.DefaultSelection<Prisma.$EspecialistasPayload>
/**
 * Model Usuarios
 * 
 */
export type Usuarios = $Result.DefaultSelection<Prisma.$UsuariosPayload>
/**
 * Model Publicacoes
 * 
 */
export type Publicacoes = $Result.DefaultSelection<Prisma.$PublicacoesPayload>
/**
 * Model Comentarios
 * 
 */
export type Comentarios = $Result.DefaultSelection<Prisma.$ComentariosPayload>
/**
 * Model Reacoes
 * 
 */
export type Reacoes = $Result.DefaultSelection<Prisma.$ReacoesPayload>
/**
 * Model Notificacoes
 * 
 */
export type Notificacoes = $Result.DefaultSelection<Prisma.$NotificacoesPayload>
/**
 * Model Seguidores
 * 
 */
export type Seguidores = $Result.DefaultSelection<Prisma.$SeguidoresPayload>
/**
 * Model Mensagens
 * 
 */
export type Mensagens = $Result.DefaultSelection<Prisma.$MensagensPayload>
/**
 * Model DiasDisponiveis
 * 
 */
export type DiasDisponiveis = $Result.DefaultSelection<Prisma.$DiasDisponiveisPayload>
/**
 * Model HorasDisponiveis
 * 
 */
export type HorasDisponiveis = $Result.DefaultSelection<Prisma.$HorasDisponiveisPayload>
/**
 * Model Consultas
 * 
 */
export type Consultas = $Result.DefaultSelection<Prisma.$ConsultasPayload>
/**
 * Model VideoCall
 * 
 */
export type VideoCall = $Result.DefaultSelection<Prisma.$VideoCallPayload>
/**
 * Model MinhasConexoes
 * 
 */
export type MinhasConexoes = $Result.DefaultSelection<Prisma.$MinhasConexoesPayload>
/**
 * Model PedidoDeConexao
 * 
 */
export type PedidoDeConexao = $Result.DefaultSelection<Prisma.$PedidoDeConexaoPayload>
/**
 * Model Partilha
 * 
 */
export type Partilha = $Result.DefaultSelection<Prisma.$PartilhaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Sexo: {
  Masculino: 'Masculino',
  Feminino: 'Feminino'
};

export type Sexo = (typeof Sexo)[keyof typeof Sexo]


export const Consulta: {
  Marcada: 'Marcada',
  Realizada: 'Realizada',
  NRealizada: 'NRealizada',
  Cancelada: 'Cancelada'
};

export type Consulta = (typeof Consulta)[keyof typeof Consulta]

}

export type Sexo = $Enums.Sexo

export const Sexo: typeof $Enums.Sexo

export type Consulta = $Enums.Consulta

export const Consulta: typeof $Enums.Consulta

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more EntidadesSistemas
 * const entidadesSistemas = await prisma.entidadesSistema.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more EntidadesSistemas
   * const entidadesSistemas = await prisma.entidadesSistema.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.entidadesSistema`: Exposes CRUD operations for the **EntidadesSistema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntidadesSistemas
    * const entidadesSistemas = await prisma.entidadesSistema.findMany()
    * ```
    */
  get entidadesSistema(): Prisma.EntidadesSistemaDelegate<ExtArgs>;

  /**
   * `prisma.endereco`: Exposes CRUD operations for the **Endereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enderecos
    * const enderecos = await prisma.endereco.findMany()
    * ```
    */
  get endereco(): Prisma.EnderecoDelegate<ExtArgs>;

  /**
   * `prisma.contactos`: Exposes CRUD operations for the **Contactos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactos
    * const contactos = await prisma.contactos.findMany()
    * ```
    */
  get contactos(): Prisma.ContactosDelegate<ExtArgs>;

  /**
   * `prisma.especialistas`: Exposes CRUD operations for the **Especialistas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especialistas
    * const especialistas = await prisma.especialistas.findMany()
    * ```
    */
  get especialistas(): Prisma.EspecialistasDelegate<ExtArgs>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **Usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.UsuariosDelegate<ExtArgs>;

  /**
   * `prisma.publicacoes`: Exposes CRUD operations for the **Publicacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publicacoes
    * const publicacoes = await prisma.publicacoes.findMany()
    * ```
    */
  get publicacoes(): Prisma.PublicacoesDelegate<ExtArgs>;

  /**
   * `prisma.comentarios`: Exposes CRUD operations for the **Comentarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentarios.findMany()
    * ```
    */
  get comentarios(): Prisma.ComentariosDelegate<ExtArgs>;

  /**
   * `prisma.reacoes`: Exposes CRUD operations for the **Reacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reacoes
    * const reacoes = await prisma.reacoes.findMany()
    * ```
    */
  get reacoes(): Prisma.ReacoesDelegate<ExtArgs>;

  /**
   * `prisma.notificacoes`: Exposes CRUD operations for the **Notificacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacoes
    * const notificacoes = await prisma.notificacoes.findMany()
    * ```
    */
  get notificacoes(): Prisma.NotificacoesDelegate<ExtArgs>;

  /**
   * `prisma.seguidores`: Exposes CRUD operations for the **Seguidores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seguidores
    * const seguidores = await prisma.seguidores.findMany()
    * ```
    */
  get seguidores(): Prisma.SeguidoresDelegate<ExtArgs>;

  /**
   * `prisma.mensagens`: Exposes CRUD operations for the **Mensagens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mensagens
    * const mensagens = await prisma.mensagens.findMany()
    * ```
    */
  get mensagens(): Prisma.MensagensDelegate<ExtArgs>;

  /**
   * `prisma.diasDisponiveis`: Exposes CRUD operations for the **DiasDisponiveis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiasDisponiveis
    * const diasDisponiveis = await prisma.diasDisponiveis.findMany()
    * ```
    */
  get diasDisponiveis(): Prisma.DiasDisponiveisDelegate<ExtArgs>;

  /**
   * `prisma.horasDisponiveis`: Exposes CRUD operations for the **HorasDisponiveis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HorasDisponiveis
    * const horasDisponiveis = await prisma.horasDisponiveis.findMany()
    * ```
    */
  get horasDisponiveis(): Prisma.HorasDisponiveisDelegate<ExtArgs>;

  /**
   * `prisma.consultas`: Exposes CRUD operations for the **Consultas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultas
    * const consultas = await prisma.consultas.findMany()
    * ```
    */
  get consultas(): Prisma.ConsultasDelegate<ExtArgs>;

  /**
   * `prisma.videoCall`: Exposes CRUD operations for the **VideoCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoCalls
    * const videoCalls = await prisma.videoCall.findMany()
    * ```
    */
  get videoCall(): Prisma.VideoCallDelegate<ExtArgs>;

  /**
   * `prisma.minhasConexoes`: Exposes CRUD operations for the **MinhasConexoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MinhasConexoes
    * const minhasConexoes = await prisma.minhasConexoes.findMany()
    * ```
    */
  get minhasConexoes(): Prisma.MinhasConexoesDelegate<ExtArgs>;

  /**
   * `prisma.pedidoDeConexao`: Exposes CRUD operations for the **PedidoDeConexao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoDeConexaos
    * const pedidoDeConexaos = await prisma.pedidoDeConexao.findMany()
    * ```
    */
  get pedidoDeConexao(): Prisma.PedidoDeConexaoDelegate<ExtArgs>;

  /**
   * `prisma.partilha`: Exposes CRUD operations for the **Partilha** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partilhas
    * const partilhas = await prisma.partilha.findMany()
    * ```
    */
  get partilha(): Prisma.PartilhaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.1
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    EntidadesSistema: 'EntidadesSistema',
    Endereco: 'Endereco',
    Contactos: 'Contactos',
    Especialistas: 'Especialistas',
    Usuarios: 'Usuarios',
    Publicacoes: 'Publicacoes',
    Comentarios: 'Comentarios',
    Reacoes: 'Reacoes',
    Notificacoes: 'Notificacoes',
    Seguidores: 'Seguidores',
    Mensagens: 'Mensagens',
    DiasDisponiveis: 'DiasDisponiveis',
    HorasDisponiveis: 'HorasDisponiveis',
    Consultas: 'Consultas',
    VideoCall: 'VideoCall',
    MinhasConexoes: 'MinhasConexoes',
    PedidoDeConexao: 'PedidoDeConexao',
    Partilha: 'Partilha'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'entidadesSistema' | 'endereco' | 'contactos' | 'especialistas' | 'usuarios' | 'publicacoes' | 'comentarios' | 'reacoes' | 'notificacoes' | 'seguidores' | 'mensagens' | 'diasDisponiveis' | 'horasDisponiveis' | 'consultas' | 'videoCall' | 'minhasConexoes' | 'pedidoDeConexao' | 'partilha'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      EntidadesSistema: {
        payload: Prisma.$EntidadesSistemaPayload<ExtArgs>
        fields: Prisma.EntidadesSistemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntidadesSistemaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntidadesSistemaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload>
          }
          findFirst: {
            args: Prisma.EntidadesSistemaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntidadesSistemaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload>
          }
          findMany: {
            args: Prisma.EntidadesSistemaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload>[]
          }
          create: {
            args: Prisma.EntidadesSistemaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload>
          }
          createMany: {
            args: Prisma.EntidadesSistemaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntidadesSistemaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload>
          }
          update: {
            args: Prisma.EntidadesSistemaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload>
          }
          deleteMany: {
            args: Prisma.EntidadesSistemaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntidadesSistemaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntidadesSistemaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntidadesSistemaPayload>
          }
          aggregate: {
            args: Prisma.EntidadesSistemaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntidadesSistema>
          }
          groupBy: {
            args: Prisma.EntidadesSistemaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntidadesSistemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntidadesSistemaCountArgs<ExtArgs>,
            result: $Utils.Optional<EntidadesSistemaCountAggregateOutputType> | number
          }
        }
      }
      Endereco: {
        payload: Prisma.$EnderecoPayload<ExtArgs>
        fields: Prisma.EnderecoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnderecoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnderecoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findFirst: {
            args: Prisma.EnderecoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnderecoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findMany: {
            args: Prisma.EnderecoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          create: {
            args: Prisma.EnderecoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          createMany: {
            args: Prisma.EnderecoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnderecoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          update: {
            args: Prisma.EnderecoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          deleteMany: {
            args: Prisma.EnderecoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnderecoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnderecoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          aggregate: {
            args: Prisma.EnderecoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEndereco>
          }
          groupBy: {
            args: Prisma.EnderecoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnderecoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnderecoCountArgs<ExtArgs>,
            result: $Utils.Optional<EnderecoCountAggregateOutputType> | number
          }
        }
      }
      Contactos: {
        payload: Prisma.$ContactosPayload<ExtArgs>
        fields: Prisma.ContactosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload>
          }
          findFirst: {
            args: Prisma.ContactosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload>
          }
          findMany: {
            args: Prisma.ContactosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload>[]
          }
          create: {
            args: Prisma.ContactosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload>
          }
          createMany: {
            args: Prisma.ContactosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload>
          }
          update: {
            args: Prisma.ContactosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload>
          }
          deleteMany: {
            args: Prisma.ContactosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactosPayload>
          }
          aggregate: {
            args: Prisma.ContactosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContactos>
          }
          groupBy: {
            args: Prisma.ContactosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactosGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactosCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactosCountAggregateOutputType> | number
          }
        }
      }
      Especialistas: {
        payload: Prisma.$EspecialistasPayload<ExtArgs>
        fields: Prisma.EspecialistasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EspecialistasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EspecialistasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload>
          }
          findFirst: {
            args: Prisma.EspecialistasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EspecialistasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload>
          }
          findMany: {
            args: Prisma.EspecialistasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload>[]
          }
          create: {
            args: Prisma.EspecialistasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload>
          }
          createMany: {
            args: Prisma.EspecialistasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EspecialistasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload>
          }
          update: {
            args: Prisma.EspecialistasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload>
          }
          deleteMany: {
            args: Prisma.EspecialistasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EspecialistasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EspecialistasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EspecialistasPayload>
          }
          aggregate: {
            args: Prisma.EspecialistasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEspecialistas>
          }
          groupBy: {
            args: Prisma.EspecialistasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EspecialistasGroupByOutputType>[]
          }
          count: {
            args: Prisma.EspecialistasCountArgs<ExtArgs>,
            result: $Utils.Optional<EspecialistasCountAggregateOutputType> | number
          }
        }
      }
      Usuarios: {
        payload: Prisma.$UsuariosPayload<ExtArgs>
        fields: Prisma.UsuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findFirst: {
            args: Prisma.UsuariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findMany: {
            args: Prisma.UsuariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          create: {
            args: Prisma.UsuariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          createMany: {
            args: Prisma.UsuariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          update: {
            args: Prisma.UsuariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          deleteMany: {
            args: Prisma.UsuariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.UsuariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuariosCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
      Publicacoes: {
        payload: Prisma.$PublicacoesPayload<ExtArgs>
        fields: Prisma.PublicacoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicacoesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicacoesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload>
          }
          findFirst: {
            args: Prisma.PublicacoesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicacoesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload>
          }
          findMany: {
            args: Prisma.PublicacoesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload>[]
          }
          create: {
            args: Prisma.PublicacoesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload>
          }
          createMany: {
            args: Prisma.PublicacoesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PublicacoesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload>
          }
          update: {
            args: Prisma.PublicacoesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload>
          }
          deleteMany: {
            args: Prisma.PublicacoesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PublicacoesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PublicacoesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicacoesPayload>
          }
          aggregate: {
            args: Prisma.PublicacoesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePublicacoes>
          }
          groupBy: {
            args: Prisma.PublicacoesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PublicacoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicacoesCountArgs<ExtArgs>,
            result: $Utils.Optional<PublicacoesCountAggregateOutputType> | number
          }
        }
      }
      Comentarios: {
        payload: Prisma.$ComentariosPayload<ExtArgs>
        fields: Prisma.ComentariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComentariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload>
          }
          findFirst: {
            args: Prisma.ComentariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload>
          }
          findMany: {
            args: Prisma.ComentariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload>[]
          }
          create: {
            args: Prisma.ComentariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload>
          }
          createMany: {
            args: Prisma.ComentariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ComentariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload>
          }
          update: {
            args: Prisma.ComentariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload>
          }
          deleteMany: {
            args: Prisma.ComentariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ComentariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ComentariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComentariosPayload>
          }
          aggregate: {
            args: Prisma.ComentariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComentarios>
          }
          groupBy: {
            args: Prisma.ComentariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComentariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComentariosCountArgs<ExtArgs>,
            result: $Utils.Optional<ComentariosCountAggregateOutputType> | number
          }
        }
      }
      Reacoes: {
        payload: Prisma.$ReacoesPayload<ExtArgs>
        fields: Prisma.ReacoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReacoesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReacoesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload>
          }
          findFirst: {
            args: Prisma.ReacoesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReacoesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload>
          }
          findMany: {
            args: Prisma.ReacoesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload>[]
          }
          create: {
            args: Prisma.ReacoesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload>
          }
          createMany: {
            args: Prisma.ReacoesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReacoesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload>
          }
          update: {
            args: Prisma.ReacoesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload>
          }
          deleteMany: {
            args: Prisma.ReacoesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReacoesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReacoesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReacoesPayload>
          }
          aggregate: {
            args: Prisma.ReacoesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReacoes>
          }
          groupBy: {
            args: Prisma.ReacoesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReacoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReacoesCountArgs<ExtArgs>,
            result: $Utils.Optional<ReacoesCountAggregateOutputType> | number
          }
        }
      }
      Notificacoes: {
        payload: Prisma.$NotificacoesPayload<ExtArgs>
        fields: Prisma.NotificacoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacoesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacoesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload>
          }
          findFirst: {
            args: Prisma.NotificacoesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacoesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload>
          }
          findMany: {
            args: Prisma.NotificacoesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload>[]
          }
          create: {
            args: Prisma.NotificacoesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload>
          }
          createMany: {
            args: Prisma.NotificacoesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificacoesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload>
          }
          update: {
            args: Prisma.NotificacoesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload>
          }
          deleteMany: {
            args: Prisma.NotificacoesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacoesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificacoesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificacoesPayload>
          }
          aggregate: {
            args: Prisma.NotificacoesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotificacoes>
          }
          groupBy: {
            args: Prisma.NotificacoesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificacoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacoesCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificacoesCountAggregateOutputType> | number
          }
        }
      }
      Seguidores: {
        payload: Prisma.$SeguidoresPayload<ExtArgs>
        fields: Prisma.SeguidoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeguidoresFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeguidoresFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload>
          }
          findFirst: {
            args: Prisma.SeguidoresFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeguidoresFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload>
          }
          findMany: {
            args: Prisma.SeguidoresFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload>[]
          }
          create: {
            args: Prisma.SeguidoresCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload>
          }
          createMany: {
            args: Prisma.SeguidoresCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SeguidoresDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload>
          }
          update: {
            args: Prisma.SeguidoresUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload>
          }
          deleteMany: {
            args: Prisma.SeguidoresDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SeguidoresUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SeguidoresUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SeguidoresPayload>
          }
          aggregate: {
            args: Prisma.SeguidoresAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSeguidores>
          }
          groupBy: {
            args: Prisma.SeguidoresGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SeguidoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeguidoresCountArgs<ExtArgs>,
            result: $Utils.Optional<SeguidoresCountAggregateOutputType> | number
          }
        }
      }
      Mensagens: {
        payload: Prisma.$MensagensPayload<ExtArgs>
        fields: Prisma.MensagensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MensagensFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MensagensFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload>
          }
          findFirst: {
            args: Prisma.MensagensFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MensagensFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload>
          }
          findMany: {
            args: Prisma.MensagensFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload>[]
          }
          create: {
            args: Prisma.MensagensCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload>
          }
          createMany: {
            args: Prisma.MensagensCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MensagensDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload>
          }
          update: {
            args: Prisma.MensagensUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload>
          }
          deleteMany: {
            args: Prisma.MensagensDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MensagensUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MensagensUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MensagensPayload>
          }
          aggregate: {
            args: Prisma.MensagensAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMensagens>
          }
          groupBy: {
            args: Prisma.MensagensGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MensagensGroupByOutputType>[]
          }
          count: {
            args: Prisma.MensagensCountArgs<ExtArgs>,
            result: $Utils.Optional<MensagensCountAggregateOutputType> | number
          }
        }
      }
      DiasDisponiveis: {
        payload: Prisma.$DiasDisponiveisPayload<ExtArgs>
        fields: Prisma.DiasDisponiveisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiasDisponiveisFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiasDisponiveisFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload>
          }
          findFirst: {
            args: Prisma.DiasDisponiveisFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiasDisponiveisFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload>
          }
          findMany: {
            args: Prisma.DiasDisponiveisFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload>[]
          }
          create: {
            args: Prisma.DiasDisponiveisCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload>
          }
          createMany: {
            args: Prisma.DiasDisponiveisCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DiasDisponiveisDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload>
          }
          update: {
            args: Prisma.DiasDisponiveisUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload>
          }
          deleteMany: {
            args: Prisma.DiasDisponiveisDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiasDisponiveisUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiasDisponiveisUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiasDisponiveisPayload>
          }
          aggregate: {
            args: Prisma.DiasDisponiveisAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDiasDisponiveis>
          }
          groupBy: {
            args: Prisma.DiasDisponiveisGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiasDisponiveisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiasDisponiveisCountArgs<ExtArgs>,
            result: $Utils.Optional<DiasDisponiveisCountAggregateOutputType> | number
          }
        }
      }
      HorasDisponiveis: {
        payload: Prisma.$HorasDisponiveisPayload<ExtArgs>
        fields: Prisma.HorasDisponiveisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HorasDisponiveisFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HorasDisponiveisFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload>
          }
          findFirst: {
            args: Prisma.HorasDisponiveisFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HorasDisponiveisFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload>
          }
          findMany: {
            args: Prisma.HorasDisponiveisFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload>[]
          }
          create: {
            args: Prisma.HorasDisponiveisCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload>
          }
          createMany: {
            args: Prisma.HorasDisponiveisCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HorasDisponiveisDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload>
          }
          update: {
            args: Prisma.HorasDisponiveisUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload>
          }
          deleteMany: {
            args: Prisma.HorasDisponiveisDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HorasDisponiveisUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HorasDisponiveisUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasDisponiveisPayload>
          }
          aggregate: {
            args: Prisma.HorasDisponiveisAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHorasDisponiveis>
          }
          groupBy: {
            args: Prisma.HorasDisponiveisGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HorasDisponiveisGroupByOutputType>[]
          }
          count: {
            args: Prisma.HorasDisponiveisCountArgs<ExtArgs>,
            result: $Utils.Optional<HorasDisponiveisCountAggregateOutputType> | number
          }
        }
      }
      Consultas: {
        payload: Prisma.$ConsultasPayload<ExtArgs>
        fields: Prisma.ConsultasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload>
          }
          findFirst: {
            args: Prisma.ConsultasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload>
          }
          findMany: {
            args: Prisma.ConsultasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload>[]
          }
          create: {
            args: Prisma.ConsultasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload>
          }
          createMany: {
            args: Prisma.ConsultasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConsultasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload>
          }
          update: {
            args: Prisma.ConsultasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload>
          }
          deleteMany: {
            args: Prisma.ConsultasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConsultasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConsultasPayload>
          }
          aggregate: {
            args: Prisma.ConsultasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConsultas>
          }
          groupBy: {
            args: Prisma.ConsultasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConsultasGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultasCountArgs<ExtArgs>,
            result: $Utils.Optional<ConsultasCountAggregateOutputType> | number
          }
        }
      }
      VideoCall: {
        payload: Prisma.$VideoCallPayload<ExtArgs>
        fields: Prisma.VideoCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoCallFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoCallFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          findFirst: {
            args: Prisma.VideoCallFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoCallFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          findMany: {
            args: Prisma.VideoCallFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>[]
          }
          create: {
            args: Prisma.VideoCallCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          createMany: {
            args: Prisma.VideoCallCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VideoCallDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          update: {
            args: Prisma.VideoCallUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          deleteMany: {
            args: Prisma.VideoCallDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VideoCallUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VideoCallUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VideoCallPayload>
          }
          aggregate: {
            args: Prisma.VideoCallAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVideoCall>
          }
          groupBy: {
            args: Prisma.VideoCallGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VideoCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCallCountArgs<ExtArgs>,
            result: $Utils.Optional<VideoCallCountAggregateOutputType> | number
          }
        }
      }
      MinhasConexoes: {
        payload: Prisma.$MinhasConexoesPayload<ExtArgs>
        fields: Prisma.MinhasConexoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MinhasConexoesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MinhasConexoesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload>
          }
          findFirst: {
            args: Prisma.MinhasConexoesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MinhasConexoesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload>
          }
          findMany: {
            args: Prisma.MinhasConexoesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload>[]
          }
          create: {
            args: Prisma.MinhasConexoesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload>
          }
          createMany: {
            args: Prisma.MinhasConexoesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MinhasConexoesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload>
          }
          update: {
            args: Prisma.MinhasConexoesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload>
          }
          deleteMany: {
            args: Prisma.MinhasConexoesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MinhasConexoesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MinhasConexoesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MinhasConexoesPayload>
          }
          aggregate: {
            args: Prisma.MinhasConexoesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMinhasConexoes>
          }
          groupBy: {
            args: Prisma.MinhasConexoesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MinhasConexoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MinhasConexoesCountArgs<ExtArgs>,
            result: $Utils.Optional<MinhasConexoesCountAggregateOutputType> | number
          }
        }
      }
      PedidoDeConexao: {
        payload: Prisma.$PedidoDeConexaoPayload<ExtArgs>
        fields: Prisma.PedidoDeConexaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoDeConexaoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoDeConexaoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload>
          }
          findFirst: {
            args: Prisma.PedidoDeConexaoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoDeConexaoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload>
          }
          findMany: {
            args: Prisma.PedidoDeConexaoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload>[]
          }
          create: {
            args: Prisma.PedidoDeConexaoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload>
          }
          createMany: {
            args: Prisma.PedidoDeConexaoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PedidoDeConexaoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload>
          }
          update: {
            args: Prisma.PedidoDeConexaoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeConexaoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoDeConexaoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PedidoDeConexaoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PedidoDeConexaoPayload>
          }
          aggregate: {
            args: Prisma.PedidoDeConexaoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePedidoDeConexao>
          }
          groupBy: {
            args: Prisma.PedidoDeConexaoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PedidoDeConexaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoDeConexaoCountArgs<ExtArgs>,
            result: $Utils.Optional<PedidoDeConexaoCountAggregateOutputType> | number
          }
        }
      }
      Partilha: {
        payload: Prisma.$PartilhaPayload<ExtArgs>
        fields: Prisma.PartilhaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartilhaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartilhaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload>
          }
          findFirst: {
            args: Prisma.PartilhaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartilhaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload>
          }
          findMany: {
            args: Prisma.PartilhaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload>[]
          }
          create: {
            args: Prisma.PartilhaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload>
          }
          createMany: {
            args: Prisma.PartilhaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartilhaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload>
          }
          update: {
            args: Prisma.PartilhaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload>
          }
          deleteMany: {
            args: Prisma.PartilhaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartilhaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartilhaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartilhaPayload>
          }
          aggregate: {
            args: Prisma.PartilhaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePartilha>
          }
          groupBy: {
            args: Prisma.PartilhaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartilhaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartilhaCountArgs<ExtArgs>,
            result: $Utils.Optional<PartilhaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EntidadesSistemaCountOutputType
   */

  export type EntidadesSistemaCountOutputType = {
    contactos: number
    especialista: number
    seguidores: number
  }

  export type EntidadesSistemaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactos?: boolean | EntidadesSistemaCountOutputTypeCountContactosArgs
    especialista?: boolean | EntidadesSistemaCountOutputTypeCountEspecialistaArgs
    seguidores?: boolean | EntidadesSistemaCountOutputTypeCountSeguidoresArgs
  }

  // Custom InputTypes

  /**
   * EntidadesSistemaCountOutputType without action
   */
  export type EntidadesSistemaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistemaCountOutputType
     */
    select?: EntidadesSistemaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EntidadesSistemaCountOutputType without action
   */
  export type EntidadesSistemaCountOutputTypeCountContactosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactosWhereInput
  }


  /**
   * EntidadesSistemaCountOutputType without action
   */
  export type EntidadesSistemaCountOutputTypeCountEspecialistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecialistasWhereInput
  }


  /**
   * EntidadesSistemaCountOutputType without action
   */
  export type EntidadesSistemaCountOutputTypeCountSeguidoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeguidoresWhereInput
  }



  /**
   * Count Type EnderecoCountOutputType
   */

  export type EnderecoCountOutputType = {
    entitie: number
  }

  export type EnderecoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entitie?: boolean | EnderecoCountOutputTypeCountEntitieArgs
  }

  // Custom InputTypes

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoCountOutputType
     */
    select?: EnderecoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountEntitieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntidadesSistemaWhereInput
  }



  /**
   * Count Type EspecialistasCountOutputType
   */

  export type EspecialistasCountOutputType = {
    diasDisponiveis: number
    horasDisponiveis: number
    consultas: number
  }

  export type EspecialistasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diasDisponiveis?: boolean | EspecialistasCountOutputTypeCountDiasDisponiveisArgs
    horasDisponiveis?: boolean | EspecialistasCountOutputTypeCountHorasDisponiveisArgs
    consultas?: boolean | EspecialistasCountOutputTypeCountConsultasArgs
  }

  // Custom InputTypes

  /**
   * EspecialistasCountOutputType without action
   */
  export type EspecialistasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecialistasCountOutputType
     */
    select?: EspecialistasCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EspecialistasCountOutputType without action
   */
  export type EspecialistasCountOutputTypeCountDiasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiasDisponiveisWhereInput
  }


  /**
   * EspecialistasCountOutputType without action
   */
  export type EspecialistasCountOutputTypeCountHorasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HorasDisponiveisWhereInput
  }


  /**
   * EspecialistasCountOutputType without action
   */
  export type EspecialistasCountOutputTypeCountConsultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultasWhereInput
  }



  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    contactos: number
    pubblicacoes: number
    origem: number
    destinatarioNotificacao: number
    consultas: number
    mensagensEnviadas: number
    mensagensRecebidas: number
    remetente: number
    destinatario: number
    emissorDoPedido: number
    receptorDoPedido: number
    reacoes: number
    comentarios: number
    seguidor: number
    partilha: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactos?: boolean | UsuariosCountOutputTypeCountContactosArgs
    pubblicacoes?: boolean | UsuariosCountOutputTypeCountPubblicacoesArgs
    origem?: boolean | UsuariosCountOutputTypeCountOrigemArgs
    destinatarioNotificacao?: boolean | UsuariosCountOutputTypeCountDestinatarioNotificacaoArgs
    consultas?: boolean | UsuariosCountOutputTypeCountConsultasArgs
    mensagensEnviadas?: boolean | UsuariosCountOutputTypeCountMensagensEnviadasArgs
    mensagensRecebidas?: boolean | UsuariosCountOutputTypeCountMensagensRecebidasArgs
    remetente?: boolean | UsuariosCountOutputTypeCountRemetenteArgs
    destinatario?: boolean | UsuariosCountOutputTypeCountDestinatarioArgs
    emissorDoPedido?: boolean | UsuariosCountOutputTypeCountEmissorDoPedidoArgs
    receptorDoPedido?: boolean | UsuariosCountOutputTypeCountReceptorDoPedidoArgs
    reacoes?: boolean | UsuariosCountOutputTypeCountReacoesArgs
    comentarios?: boolean | UsuariosCountOutputTypeCountComentariosArgs
    seguidor?: boolean | UsuariosCountOutputTypeCountSeguidorArgs
    partilha?: boolean | UsuariosCountOutputTypeCountPartilhaArgs
  }

  // Custom InputTypes

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountContactosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactosWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountPubblicacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicacoesWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacoesWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountDestinatarioNotificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacoesWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountConsultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultasWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountMensagensEnviadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensagensWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountMensagensRecebidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensagensWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountRemetenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinhasConexoesWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountDestinatarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinhasConexoesWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountEmissorDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoDeConexaoWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountReceptorDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoDeConexaoWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountReacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReacoesWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentariosWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountSeguidorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeguidoresWhereInput
  }


  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountPartilhaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartilhaWhereInput
  }



  /**
   * Count Type PublicacoesCountOutputType
   */

  export type PublicacoesCountOutputType = {
    reacoes: number
    comentarios: number
    notificacao: number
    postPartilhado: number
    postCriado: number
  }

  export type PublicacoesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reacoes?: boolean | PublicacoesCountOutputTypeCountReacoesArgs
    comentarios?: boolean | PublicacoesCountOutputTypeCountComentariosArgs
    notificacao?: boolean | PublicacoesCountOutputTypeCountNotificacaoArgs
    postPartilhado?: boolean | PublicacoesCountOutputTypeCountPostPartilhadoArgs
    postCriado?: boolean | PublicacoesCountOutputTypeCountPostCriadoArgs
  }

  // Custom InputTypes

  /**
   * PublicacoesCountOutputType without action
   */
  export type PublicacoesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicacoesCountOutputType
     */
    select?: PublicacoesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PublicacoesCountOutputType without action
   */
  export type PublicacoesCountOutputTypeCountReacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReacoesWhereInput
  }


  /**
   * PublicacoesCountOutputType without action
   */
  export type PublicacoesCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentariosWhereInput
  }


  /**
   * PublicacoesCountOutputType without action
   */
  export type PublicacoesCountOutputTypeCountNotificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacoesWhereInput
  }


  /**
   * PublicacoesCountOutputType without action
   */
  export type PublicacoesCountOutputTypeCountPostPartilhadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartilhaWhereInput
  }


  /**
   * PublicacoesCountOutputType without action
   */
  export type PublicacoesCountOutputTypeCountPostCriadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartilhaWhereInput
  }



  /**
   * Count Type DiasDisponiveisCountOutputType
   */

  export type DiasDisponiveisCountOutputType = {
    horasDisponiveis: number
  }

  export type DiasDisponiveisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    horasDisponiveis?: boolean | DiasDisponiveisCountOutputTypeCountHorasDisponiveisArgs
  }

  // Custom InputTypes

  /**
   * DiasDisponiveisCountOutputType without action
   */
  export type DiasDisponiveisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveisCountOutputType
     */
    select?: DiasDisponiveisCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DiasDisponiveisCountOutputType without action
   */
  export type DiasDisponiveisCountOutputTypeCountHorasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HorasDisponiveisWhereInput
  }



  /**
   * Count Type ConsultasCountOutputType
   */

  export type ConsultasCountOutputType = {
    notificacoes: number
  }

  export type ConsultasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificacoes?: boolean | ConsultasCountOutputTypeCountNotificacoesArgs
  }

  // Custom InputTypes

  /**
   * ConsultasCountOutputType without action
   */
  export type ConsultasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultasCountOutputType
     */
    select?: ConsultasCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConsultasCountOutputType without action
   */
  export type ConsultasCountOutputTypeCountNotificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacoesWhereInput
  }



  /**
   * Models
   */

  /**
   * Model EntidadesSistema
   */

  export type AggregateEntidadesSistema = {
    _count: EntidadesSistemaCountAggregateOutputType | null
    _min: EntidadesSistemaMinAggregateOutputType | null
    _max: EntidadesSistemaMaxAggregateOutputType | null
  }

  export type EntidadesSistemaMinAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    tipo_entidade: string | null
    sobre: string | null
    email: string | null
    foto: string | null
    enderecoID: string | null
  }

  export type EntidadesSistemaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    tipo_entidade: string | null
    sobre: string | null
    email: string | null
    foto: string | null
    enderecoID: string | null
  }

  export type EntidadesSistemaCountAggregateOutputType = {
    id: number
    name: number
    cnpj: number
    tipo_entidade: number
    sobre: number
    email: number
    foto: number
    enderecoID: number
    _all: number
  }


  export type EntidadesSistemaMinAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    tipo_entidade?: true
    sobre?: true
    email?: true
    foto?: true
    enderecoID?: true
  }

  export type EntidadesSistemaMaxAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    tipo_entidade?: true
    sobre?: true
    email?: true
    foto?: true
    enderecoID?: true
  }

  export type EntidadesSistemaCountAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    tipo_entidade?: true
    sobre?: true
    email?: true
    foto?: true
    enderecoID?: true
    _all?: true
  }

  export type EntidadesSistemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntidadesSistema to aggregate.
     */
    where?: EntidadesSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntidadesSistemas to fetch.
     */
    orderBy?: EntidadesSistemaOrderByWithRelationInput | EntidadesSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntidadesSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntidadesSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntidadesSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntidadesSistemas
    **/
    _count?: true | EntidadesSistemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntidadesSistemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntidadesSistemaMaxAggregateInputType
  }

  export type GetEntidadesSistemaAggregateType<T extends EntidadesSistemaAggregateArgs> = {
        [P in keyof T & keyof AggregateEntidadesSistema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntidadesSistema[P]>
      : GetScalarType<T[P], AggregateEntidadesSistema[P]>
  }




  export type EntidadesSistemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntidadesSistemaWhereInput
    orderBy?: EntidadesSistemaOrderByWithAggregationInput | EntidadesSistemaOrderByWithAggregationInput[]
    by: EntidadesSistemaScalarFieldEnum[] | EntidadesSistemaScalarFieldEnum
    having?: EntidadesSistemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntidadesSistemaCountAggregateInputType | true
    _min?: EntidadesSistemaMinAggregateInputType
    _max?: EntidadesSistemaMaxAggregateInputType
  }

  export type EntidadesSistemaGroupByOutputType = {
    id: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre: string | null
    email: string
    foto: string | null
    enderecoID: string
    _count: EntidadesSistemaCountAggregateOutputType | null
    _min: EntidadesSistemaMinAggregateOutputType | null
    _max: EntidadesSistemaMaxAggregateOutputType | null
  }

  type GetEntidadesSistemaGroupByPayload<T extends EntidadesSistemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntidadesSistemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntidadesSistemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntidadesSistemaGroupByOutputType[P]>
            : GetScalarType<T[P], EntidadesSistemaGroupByOutputType[P]>
        }
      >
    >


  export type EntidadesSistemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cnpj?: boolean
    tipo_entidade?: boolean
    sobre?: boolean
    email?: boolean
    foto?: boolean
    enderecoID?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    contactos?: boolean | EntidadesSistema$contactosArgs<ExtArgs>
    especialista?: boolean | EntidadesSistema$especialistaArgs<ExtArgs>
    seguidores?: boolean | EntidadesSistema$seguidoresArgs<ExtArgs>
    _count?: boolean | EntidadesSistemaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entidadesSistema"]>

  export type EntidadesSistemaSelectScalar = {
    id?: boolean
    name?: boolean
    cnpj?: boolean
    tipo_entidade?: boolean
    sobre?: boolean
    email?: boolean
    foto?: boolean
    enderecoID?: boolean
  }

  export type EntidadesSistemaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    contactos?: boolean | EntidadesSistema$contactosArgs<ExtArgs>
    especialista?: boolean | EntidadesSistema$especialistaArgs<ExtArgs>
    seguidores?: boolean | EntidadesSistema$seguidoresArgs<ExtArgs>
    _count?: boolean | EntidadesSistemaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EntidadesSistemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntidadesSistema"
    objects: {
      endereco: Prisma.$EnderecoPayload<ExtArgs>
      contactos: Prisma.$ContactosPayload<ExtArgs>[]
      especialista: Prisma.$EspecialistasPayload<ExtArgs>[]
      seguidores: Prisma.$SeguidoresPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cnpj: string
      tipo_entidade: string
      sobre: string | null
      email: string
      foto: string | null
      enderecoID: string
    }, ExtArgs["result"]["entidadesSistema"]>
    composites: {}
  }


  type EntidadesSistemaGetPayload<S extends boolean | null | undefined | EntidadesSistemaDefaultArgs> = $Result.GetResult<Prisma.$EntidadesSistemaPayload, S>

  type EntidadesSistemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntidadesSistemaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntidadesSistemaCountAggregateInputType | true
    }

  export interface EntidadesSistemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntidadesSistema'], meta: { name: 'EntidadesSistema' } }
    /**
     * Find zero or one EntidadesSistema that matches the filter.
     * @param {EntidadesSistemaFindUniqueArgs} args - Arguments to find a EntidadesSistema
     * @example
     * // Get one EntidadesSistema
     * const entidadesSistema = await prisma.entidadesSistema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntidadesSistemaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntidadesSistemaFindUniqueArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EntidadesSistema that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EntidadesSistemaFindUniqueOrThrowArgs} args - Arguments to find a EntidadesSistema
     * @example
     * // Get one EntidadesSistema
     * const entidadesSistema = await prisma.entidadesSistema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntidadesSistemaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntidadesSistemaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EntidadesSistema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntidadesSistemaFindFirstArgs} args - Arguments to find a EntidadesSistema
     * @example
     * // Get one EntidadesSistema
     * const entidadesSistema = await prisma.entidadesSistema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntidadesSistemaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntidadesSistemaFindFirstArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EntidadesSistema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntidadesSistemaFindFirstOrThrowArgs} args - Arguments to find a EntidadesSistema
     * @example
     * // Get one EntidadesSistema
     * const entidadesSistema = await prisma.entidadesSistema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntidadesSistemaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntidadesSistemaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EntidadesSistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntidadesSistemaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntidadesSistemas
     * const entidadesSistemas = await prisma.entidadesSistema.findMany()
     * 
     * // Get first 10 EntidadesSistemas
     * const entidadesSistemas = await prisma.entidadesSistema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entidadesSistemaWithIdOnly = await prisma.entidadesSistema.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntidadesSistemaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntidadesSistemaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EntidadesSistema.
     * @param {EntidadesSistemaCreateArgs} args - Arguments to create a EntidadesSistema.
     * @example
     * // Create one EntidadesSistema
     * const EntidadesSistema = await prisma.entidadesSistema.create({
     *   data: {
     *     // ... data to create a EntidadesSistema
     *   }
     * })
     * 
    **/
    create<T extends EntidadesSistemaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntidadesSistemaCreateArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EntidadesSistemas.
     *     @param {EntidadesSistemaCreateManyArgs} args - Arguments to create many EntidadesSistemas.
     *     @example
     *     // Create many EntidadesSistemas
     *     const entidadesSistema = await prisma.entidadesSistema.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EntidadesSistemaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntidadesSistemaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntidadesSistema.
     * @param {EntidadesSistemaDeleteArgs} args - Arguments to delete one EntidadesSistema.
     * @example
     * // Delete one EntidadesSistema
     * const EntidadesSistema = await prisma.entidadesSistema.delete({
     *   where: {
     *     // ... filter to delete one EntidadesSistema
     *   }
     * })
     * 
    **/
    delete<T extends EntidadesSistemaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntidadesSistemaDeleteArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EntidadesSistema.
     * @param {EntidadesSistemaUpdateArgs} args - Arguments to update one EntidadesSistema.
     * @example
     * // Update one EntidadesSistema
     * const entidadesSistema = await prisma.entidadesSistema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntidadesSistemaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntidadesSistemaUpdateArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EntidadesSistemas.
     * @param {EntidadesSistemaDeleteManyArgs} args - Arguments to filter EntidadesSistemas to delete.
     * @example
     * // Delete a few EntidadesSistemas
     * const { count } = await prisma.entidadesSistema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntidadesSistemaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntidadesSistemaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntidadesSistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntidadesSistemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntidadesSistemas
     * const entidadesSistema = await prisma.entidadesSistema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntidadesSistemaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntidadesSistemaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntidadesSistema.
     * @param {EntidadesSistemaUpsertArgs} args - Arguments to update or create a EntidadesSistema.
     * @example
     * // Update or create a EntidadesSistema
     * const entidadesSistema = await prisma.entidadesSistema.upsert({
     *   create: {
     *     // ... data to create a EntidadesSistema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntidadesSistema we want to update
     *   }
     * })
    **/
    upsert<T extends EntidadesSistemaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntidadesSistemaUpsertArgs<ExtArgs>>
    ): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EntidadesSistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntidadesSistemaCountArgs} args - Arguments to filter EntidadesSistemas to count.
     * @example
     * // Count the number of EntidadesSistemas
     * const count = await prisma.entidadesSistema.count({
     *   where: {
     *     // ... the filter for the EntidadesSistemas we want to count
     *   }
     * })
    **/
    count<T extends EntidadesSistemaCountArgs>(
      args?: Subset<T, EntidadesSistemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntidadesSistemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntidadesSistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntidadesSistemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntidadesSistemaAggregateArgs>(args: Subset<T, EntidadesSistemaAggregateArgs>): Prisma.PrismaPromise<GetEntidadesSistemaAggregateType<T>>

    /**
     * Group by EntidadesSistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntidadesSistemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntidadesSistemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntidadesSistemaGroupByArgs['orderBy'] }
        : { orderBy?: EntidadesSistemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntidadesSistemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntidadesSistemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntidadesSistema model
   */
  readonly fields: EntidadesSistemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntidadesSistema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntidadesSistemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    endereco<T extends EnderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnderecoDefaultArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    contactos<T extends EntidadesSistema$contactosArgs<ExtArgs> = {}>(args?: Subset<T, EntidadesSistema$contactosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'findMany'> | Null>;

    especialista<T extends EntidadesSistema$especialistaArgs<ExtArgs> = {}>(args?: Subset<T, EntidadesSistema$especialistaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findMany'> | Null>;

    seguidores<T extends EntidadesSistema$seguidoresArgs<ExtArgs> = {}>(args?: Subset<T, EntidadesSistema$seguidoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EntidadesSistema model
   */ 
  interface EntidadesSistemaFieldRefs {
    readonly id: FieldRef<"EntidadesSistema", 'String'>
    readonly name: FieldRef<"EntidadesSistema", 'String'>
    readonly cnpj: FieldRef<"EntidadesSistema", 'String'>
    readonly tipo_entidade: FieldRef<"EntidadesSistema", 'String'>
    readonly sobre: FieldRef<"EntidadesSistema", 'String'>
    readonly email: FieldRef<"EntidadesSistema", 'String'>
    readonly foto: FieldRef<"EntidadesSistema", 'String'>
    readonly enderecoID: FieldRef<"EntidadesSistema", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EntidadesSistema findUnique
   */
  export type EntidadesSistemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * Filter, which EntidadesSistema to fetch.
     */
    where: EntidadesSistemaWhereUniqueInput
  }


  /**
   * EntidadesSistema findUniqueOrThrow
   */
  export type EntidadesSistemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * Filter, which EntidadesSistema to fetch.
     */
    where: EntidadesSistemaWhereUniqueInput
  }


  /**
   * EntidadesSistema findFirst
   */
  export type EntidadesSistemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * Filter, which EntidadesSistema to fetch.
     */
    where?: EntidadesSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntidadesSistemas to fetch.
     */
    orderBy?: EntidadesSistemaOrderByWithRelationInput | EntidadesSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntidadesSistemas.
     */
    cursor?: EntidadesSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntidadesSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntidadesSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntidadesSistemas.
     */
    distinct?: EntidadesSistemaScalarFieldEnum | EntidadesSistemaScalarFieldEnum[]
  }


  /**
   * EntidadesSistema findFirstOrThrow
   */
  export type EntidadesSistemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * Filter, which EntidadesSistema to fetch.
     */
    where?: EntidadesSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntidadesSistemas to fetch.
     */
    orderBy?: EntidadesSistemaOrderByWithRelationInput | EntidadesSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntidadesSistemas.
     */
    cursor?: EntidadesSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntidadesSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntidadesSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntidadesSistemas.
     */
    distinct?: EntidadesSistemaScalarFieldEnum | EntidadesSistemaScalarFieldEnum[]
  }


  /**
   * EntidadesSistema findMany
   */
  export type EntidadesSistemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * Filter, which EntidadesSistemas to fetch.
     */
    where?: EntidadesSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntidadesSistemas to fetch.
     */
    orderBy?: EntidadesSistemaOrderByWithRelationInput | EntidadesSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntidadesSistemas.
     */
    cursor?: EntidadesSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntidadesSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntidadesSistemas.
     */
    skip?: number
    distinct?: EntidadesSistemaScalarFieldEnum | EntidadesSistemaScalarFieldEnum[]
  }


  /**
   * EntidadesSistema create
   */
  export type EntidadesSistemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * The data needed to create a EntidadesSistema.
     */
    data: XOR<EntidadesSistemaCreateInput, EntidadesSistemaUncheckedCreateInput>
  }


  /**
   * EntidadesSistema createMany
   */
  export type EntidadesSistemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntidadesSistemas.
     */
    data: EntidadesSistemaCreateManyInput | EntidadesSistemaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EntidadesSistema update
   */
  export type EntidadesSistemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * The data needed to update a EntidadesSistema.
     */
    data: XOR<EntidadesSistemaUpdateInput, EntidadesSistemaUncheckedUpdateInput>
    /**
     * Choose, which EntidadesSistema to update.
     */
    where: EntidadesSistemaWhereUniqueInput
  }


  /**
   * EntidadesSistema updateMany
   */
  export type EntidadesSistemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntidadesSistemas.
     */
    data: XOR<EntidadesSistemaUpdateManyMutationInput, EntidadesSistemaUncheckedUpdateManyInput>
    /**
     * Filter which EntidadesSistemas to update
     */
    where?: EntidadesSistemaWhereInput
  }


  /**
   * EntidadesSistema upsert
   */
  export type EntidadesSistemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * The filter to search for the EntidadesSistema to update in case it exists.
     */
    where: EntidadesSistemaWhereUniqueInput
    /**
     * In case the EntidadesSistema found by the `where` argument doesn't exist, create a new EntidadesSistema with this data.
     */
    create: XOR<EntidadesSistemaCreateInput, EntidadesSistemaUncheckedCreateInput>
    /**
     * In case the EntidadesSistema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntidadesSistemaUpdateInput, EntidadesSistemaUncheckedUpdateInput>
  }


  /**
   * EntidadesSistema delete
   */
  export type EntidadesSistemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    /**
     * Filter which EntidadesSistema to delete.
     */
    where: EntidadesSistemaWhereUniqueInput
  }


  /**
   * EntidadesSistema deleteMany
   */
  export type EntidadesSistemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntidadesSistemas to delete
     */
    where?: EntidadesSistemaWhereInput
  }


  /**
   * EntidadesSistema.contactos
   */
  export type EntidadesSistema$contactosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    where?: ContactosWhereInput
    orderBy?: ContactosOrderByWithRelationInput | ContactosOrderByWithRelationInput[]
    cursor?: ContactosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactosScalarFieldEnum | ContactosScalarFieldEnum[]
  }


  /**
   * EntidadesSistema.especialista
   */
  export type EntidadesSistema$especialistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    where?: EspecialistasWhereInput
    orderBy?: EspecialistasOrderByWithRelationInput | EspecialistasOrderByWithRelationInput[]
    cursor?: EspecialistasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EspecialistasScalarFieldEnum | EspecialistasScalarFieldEnum[]
  }


  /**
   * EntidadesSistema.seguidores
   */
  export type EntidadesSistema$seguidoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    where?: SeguidoresWhereInput
    orderBy?: SeguidoresOrderByWithRelationInput | SeguidoresOrderByWithRelationInput[]
    cursor?: SeguidoresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeguidoresScalarFieldEnum | SeguidoresScalarFieldEnum[]
  }


  /**
   * EntidadesSistema without action
   */
  export type EntidadesSistemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
  }



  /**
   * Model Endereco
   */

  export type AggregateEndereco = {
    _count: EnderecoCountAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  export type EnderecoMinAggregateOutputType = {
    id: string | null
    adress: string | null
  }

  export type EnderecoMaxAggregateOutputType = {
    id: string | null
    adress: string | null
  }

  export type EnderecoCountAggregateOutputType = {
    id: number
    adress: number
    _all: number
  }


  export type EnderecoMinAggregateInputType = {
    id?: true
    adress?: true
  }

  export type EnderecoMaxAggregateInputType = {
    id?: true
    adress?: true
  }

  export type EnderecoCountAggregateInputType = {
    id?: true
    adress?: true
    _all?: true
  }

  export type EnderecoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endereco to aggregate.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enderecos
    **/
    _count?: true | EnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoMaxAggregateInputType
  }

  export type GetEnderecoAggregateType<T extends EnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregateEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndereco[P]>
      : GetScalarType<T[P], AggregateEndereco[P]>
  }




  export type EnderecoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoWhereInput
    orderBy?: EnderecoOrderByWithAggregationInput | EnderecoOrderByWithAggregationInput[]
    by: EnderecoScalarFieldEnum[] | EnderecoScalarFieldEnum
    having?: EnderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoCountAggregateInputType | true
    _min?: EnderecoMinAggregateInputType
    _max?: EnderecoMaxAggregateInputType
  }

  export type EnderecoGroupByOutputType = {
    id: string
    adress: string
    _count: EnderecoCountAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  type GetEnderecoGroupByPayload<T extends EnderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adress?: boolean
    entitie?: boolean | Endereco$entitieArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectScalar = {
    id?: boolean
    adress?: boolean
  }

  export type EnderecoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entitie?: boolean | Endereco$entitieArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EnderecoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Endereco"
    objects: {
      entitie: Prisma.$EntidadesSistemaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adress: string
    }, ExtArgs["result"]["endereco"]>
    composites: {}
  }


  type EnderecoGetPayload<S extends boolean | null | undefined | EnderecoDefaultArgs> = $Result.GetResult<Prisma.$EnderecoPayload, S>

  type EnderecoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnderecoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnderecoCountAggregateInputType | true
    }

  export interface EnderecoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Endereco'], meta: { name: 'Endereco' } }
    /**
     * Find zero or one Endereco that matches the filter.
     * @param {EnderecoFindUniqueArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnderecoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnderecoFindUniqueArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Endereco that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnderecoFindUniqueOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnderecoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnderecoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Endereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnderecoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnderecoFindFirstArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Endereco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnderecoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnderecoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Enderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enderecos
     * const enderecos = await prisma.endereco.findMany()
     * 
     * // Get first 10 Enderecos
     * const enderecos = await prisma.endereco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoWithIdOnly = await prisma.endereco.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnderecoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnderecoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Endereco.
     * @param {EnderecoCreateArgs} args - Arguments to create a Endereco.
     * @example
     * // Create one Endereco
     * const Endereco = await prisma.endereco.create({
     *   data: {
     *     // ... data to create a Endereco
     *   }
     * })
     * 
    **/
    create<T extends EnderecoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnderecoCreateArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Enderecos.
     *     @param {EnderecoCreateManyArgs} args - Arguments to create many Enderecos.
     *     @example
     *     // Create many Enderecos
     *     const endereco = await prisma.endereco.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnderecoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnderecoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Endereco.
     * @param {EnderecoDeleteArgs} args - Arguments to delete one Endereco.
     * @example
     * // Delete one Endereco
     * const Endereco = await prisma.endereco.delete({
     *   where: {
     *     // ... filter to delete one Endereco
     *   }
     * })
     * 
    **/
    delete<T extends EnderecoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnderecoDeleteArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Endereco.
     * @param {EnderecoUpdateArgs} args - Arguments to update one Endereco.
     * @example
     * // Update one Endereco
     * const endereco = await prisma.endereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnderecoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnderecoUpdateArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Enderecos.
     * @param {EnderecoDeleteManyArgs} args - Arguments to filter Enderecos to delete.
     * @example
     * // Delete a few Enderecos
     * const { count } = await prisma.endereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnderecoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnderecoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnderecoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnderecoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Endereco.
     * @param {EnderecoUpsertArgs} args - Arguments to update or create a Endereco.
     * @example
     * // Update or create a Endereco
     * const endereco = await prisma.endereco.upsert({
     *   create: {
     *     // ... data to create a Endereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endereco we want to update
     *   }
     * })
    **/
    upsert<T extends EnderecoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnderecoUpsertArgs<ExtArgs>>
    ): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoCountArgs} args - Arguments to filter Enderecos to count.
     * @example
     * // Count the number of Enderecos
     * const count = await prisma.endereco.count({
     *   where: {
     *     // ... the filter for the Enderecos we want to count
     *   }
     * })
    **/
    count<T extends EnderecoCountArgs>(
      args?: Subset<T, EnderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoAggregateArgs>(args: Subset<T, EnderecoAggregateArgs>): Prisma.PrismaPromise<GetEnderecoAggregateType<T>>

    /**
     * Group by Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Endereco model
   */
  readonly fields: EnderecoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnderecoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entitie<T extends Endereco$entitieArgs<ExtArgs> = {}>(args?: Subset<T, Endereco$entitieArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Endereco model
   */ 
  interface EnderecoFieldRefs {
    readonly id: FieldRef<"Endereco", 'String'>
    readonly adress: FieldRef<"Endereco", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Endereco findUnique
   */
  export type EnderecoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }


  /**
   * Endereco findUniqueOrThrow
   */
  export type EnderecoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }


  /**
   * Endereco findFirst
   */
  export type EnderecoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }


  /**
   * Endereco findFirstOrThrow
   */
  export type EnderecoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }


  /**
   * Endereco findMany
   */
  export type EnderecoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Enderecos to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }


  /**
   * Endereco create
   */
  export type EnderecoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to create a Endereco.
     */
    data: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
  }


  /**
   * Endereco createMany
   */
  export type EnderecoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enderecos.
     */
    data: EnderecoCreateManyInput | EnderecoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Endereco update
   */
  export type EnderecoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to update a Endereco.
     */
    data: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
    /**
     * Choose, which Endereco to update.
     */
    where: EnderecoWhereUniqueInput
  }


  /**
   * Endereco updateMany
   */
  export type EnderecoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
  }


  /**
   * Endereco upsert
   */
  export type EnderecoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The filter to search for the Endereco to update in case it exists.
     */
    where: EnderecoWhereUniqueInput
    /**
     * In case the Endereco found by the `where` argument doesn't exist, create a new Endereco with this data.
     */
    create: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
    /**
     * In case the Endereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
  }


  /**
   * Endereco delete
   */
  export type EnderecoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter which Endereco to delete.
     */
    where: EnderecoWhereUniqueInput
  }


  /**
   * Endereco deleteMany
   */
  export type EnderecoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enderecos to delete
     */
    where?: EnderecoWhereInput
  }


  /**
   * Endereco.entitie
   */
  export type Endereco$entitieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    where?: EntidadesSistemaWhereInput
    orderBy?: EntidadesSistemaOrderByWithRelationInput | EntidadesSistemaOrderByWithRelationInput[]
    cursor?: EntidadesSistemaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntidadesSistemaScalarFieldEnum | EntidadesSistemaScalarFieldEnum[]
  }


  /**
   * Endereco without action
   */
  export type EnderecoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnderecoInclude<ExtArgs> | null
  }



  /**
   * Model Contactos
   */

  export type AggregateContactos = {
    _count: ContactosCountAggregateOutputType | null
    _min: ContactosMinAggregateOutputType | null
    _max: ContactosMaxAggregateOutputType | null
  }

  export type ContactosMinAggregateOutputType = {
    id: string | null
    contacto: string | null
    entidadeID: string | null
    usuarioID: string | null
  }

  export type ContactosMaxAggregateOutputType = {
    id: string | null
    contacto: string | null
    entidadeID: string | null
    usuarioID: string | null
  }

  export type ContactosCountAggregateOutputType = {
    id: number
    contacto: number
    entidadeID: number
    usuarioID: number
    _all: number
  }


  export type ContactosMinAggregateInputType = {
    id?: true
    contacto?: true
    entidadeID?: true
    usuarioID?: true
  }

  export type ContactosMaxAggregateInputType = {
    id?: true
    contacto?: true
    entidadeID?: true
    usuarioID?: true
  }

  export type ContactosCountAggregateInputType = {
    id?: true
    contacto?: true
    entidadeID?: true
    usuarioID?: true
    _all?: true
  }

  export type ContactosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactos to aggregate.
     */
    where?: ContactosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactos to fetch.
     */
    orderBy?: ContactosOrderByWithRelationInput | ContactosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactos
    **/
    _count?: true | ContactosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactosMaxAggregateInputType
  }

  export type GetContactosAggregateType<T extends ContactosAggregateArgs> = {
        [P in keyof T & keyof AggregateContactos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactos[P]>
      : GetScalarType<T[P], AggregateContactos[P]>
  }




  export type ContactosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactosWhereInput
    orderBy?: ContactosOrderByWithAggregationInput | ContactosOrderByWithAggregationInput[]
    by: ContactosScalarFieldEnum[] | ContactosScalarFieldEnum
    having?: ContactosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactosCountAggregateInputType | true
    _min?: ContactosMinAggregateInputType
    _max?: ContactosMaxAggregateInputType
  }

  export type ContactosGroupByOutputType = {
    id: string
    contacto: string
    entidadeID: string
    usuarioID: string
    _count: ContactosCountAggregateOutputType | null
    _min: ContactosMinAggregateOutputType | null
    _max: ContactosMaxAggregateOutputType | null
  }

  type GetContactosGroupByPayload<T extends ContactosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactosGroupByOutputType[P]>
            : GetScalarType<T[P], ContactosGroupByOutputType[P]>
        }
      >
    >


  export type ContactosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contacto?: boolean
    entidadeID?: boolean
    usuarioID?: boolean
    entidade?: boolean | EntidadesSistemaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactos"]>

  export type ContactosSelectScalar = {
    id?: boolean
    contacto?: boolean
    entidadeID?: boolean
    usuarioID?: boolean
  }

  export type ContactosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entidade?: boolean | EntidadesSistemaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuariosDefaultArgs<ExtArgs>
  }


  export type $ContactosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contactos"
    objects: {
      entidade: Prisma.$EntidadesSistemaPayload<ExtArgs>
      usuario: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contacto: string
      entidadeID: string
      usuarioID: string
    }, ExtArgs["result"]["contactos"]>
    composites: {}
  }


  type ContactosGetPayload<S extends boolean | null | undefined | ContactosDefaultArgs> = $Result.GetResult<Prisma.$ContactosPayload, S>

  type ContactosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactosCountAggregateInputType | true
    }

  export interface ContactosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contactos'], meta: { name: 'Contactos' } }
    /**
     * Find zero or one Contactos that matches the filter.
     * @param {ContactosFindUniqueArgs} args - Arguments to find a Contactos
     * @example
     * // Get one Contactos
     * const contactos = await prisma.contactos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactosFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contactos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactosFindUniqueOrThrowArgs} args - Arguments to find a Contactos
     * @example
     * // Get one Contactos
     * const contactos = await prisma.contactos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contactos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactosFindFirstArgs} args - Arguments to find a Contactos
     * @example
     * // Get one Contactos
     * const contactos = await prisma.contactos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactosFindFirstArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contactos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactosFindFirstOrThrowArgs} args - Arguments to find a Contactos
     * @example
     * // Get one Contactos
     * const contactos = await prisma.contactos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contactos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactos
     * const contactos = await prisma.contactos.findMany()
     * 
     * // Get first 10 Contactos
     * const contactos = await prisma.contactos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactosWithIdOnly = await prisma.contactos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contactos.
     * @param {ContactosCreateArgs} args - Arguments to create a Contactos.
     * @example
     * // Create one Contactos
     * const Contactos = await prisma.contactos.create({
     *   data: {
     *     // ... data to create a Contactos
     *   }
     * })
     * 
    **/
    create<T extends ContactosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactosCreateArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contactos.
     *     @param {ContactosCreateManyArgs} args - Arguments to create many Contactos.
     *     @example
     *     // Create many Contactos
     *     const contactos = await prisma.contactos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contactos.
     * @param {ContactosDeleteArgs} args - Arguments to delete one Contactos.
     * @example
     * // Delete one Contactos
     * const Contactos = await prisma.contactos.delete({
     *   where: {
     *     // ... filter to delete one Contactos
     *   }
     * })
     * 
    **/
    delete<T extends ContactosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactosDeleteArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contactos.
     * @param {ContactosUpdateArgs} args - Arguments to update one Contactos.
     * @example
     * // Update one Contactos
     * const contactos = await prisma.contactos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactosUpdateArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contactos.
     * @param {ContactosDeleteManyArgs} args - Arguments to filter Contactos to delete.
     * @example
     * // Delete a few Contactos
     * const { count } = await prisma.contactos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactos
     * const contactos = await prisma.contactos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contactos.
     * @param {ContactosUpsertArgs} args - Arguments to update or create a Contactos.
     * @example
     * // Update or create a Contactos
     * const contactos = await prisma.contactos.upsert({
     *   create: {
     *     // ... data to create a Contactos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contactos we want to update
     *   }
     * })
    **/
    upsert<T extends ContactosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactosUpsertArgs<ExtArgs>>
    ): Prisma__ContactosClient<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contactos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactosCountArgs} args - Arguments to filter Contactos to count.
     * @example
     * // Count the number of Contactos
     * const count = await prisma.contactos.count({
     *   where: {
     *     // ... the filter for the Contactos we want to count
     *   }
     * })
    **/
    count<T extends ContactosCountArgs>(
      args?: Subset<T, ContactosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contactos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactosAggregateArgs>(args: Subset<T, ContactosAggregateArgs>): Prisma.PrismaPromise<GetContactosAggregateType<T>>

    /**
     * Group by Contactos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactosGroupByArgs['orderBy'] }
        : { orderBy?: ContactosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contactos model
   */
  readonly fields: ContactosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contactos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entidade<T extends EntidadesSistemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntidadesSistemaDefaultArgs<ExtArgs>>): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuario<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Contactos model
   */ 
  interface ContactosFieldRefs {
    readonly id: FieldRef<"Contactos", 'String'>
    readonly contacto: FieldRef<"Contactos", 'String'>
    readonly entidadeID: FieldRef<"Contactos", 'String'>
    readonly usuarioID: FieldRef<"Contactos", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Contactos findUnique
   */
  export type ContactosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * Filter, which Contactos to fetch.
     */
    where: ContactosWhereUniqueInput
  }


  /**
   * Contactos findUniqueOrThrow
   */
  export type ContactosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * Filter, which Contactos to fetch.
     */
    where: ContactosWhereUniqueInput
  }


  /**
   * Contactos findFirst
   */
  export type ContactosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * Filter, which Contactos to fetch.
     */
    where?: ContactosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactos to fetch.
     */
    orderBy?: ContactosOrderByWithRelationInput | ContactosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactos.
     */
    cursor?: ContactosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactos.
     */
    distinct?: ContactosScalarFieldEnum | ContactosScalarFieldEnum[]
  }


  /**
   * Contactos findFirstOrThrow
   */
  export type ContactosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * Filter, which Contactos to fetch.
     */
    where?: ContactosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactos to fetch.
     */
    orderBy?: ContactosOrderByWithRelationInput | ContactosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactos.
     */
    cursor?: ContactosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactos.
     */
    distinct?: ContactosScalarFieldEnum | ContactosScalarFieldEnum[]
  }


  /**
   * Contactos findMany
   */
  export type ContactosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * Filter, which Contactos to fetch.
     */
    where?: ContactosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactos to fetch.
     */
    orderBy?: ContactosOrderByWithRelationInput | ContactosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactos.
     */
    cursor?: ContactosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactos.
     */
    skip?: number
    distinct?: ContactosScalarFieldEnum | ContactosScalarFieldEnum[]
  }


  /**
   * Contactos create
   */
  export type ContactosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * The data needed to create a Contactos.
     */
    data: XOR<ContactosCreateInput, ContactosUncheckedCreateInput>
  }


  /**
   * Contactos createMany
   */
  export type ContactosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contactos.
     */
    data: ContactosCreateManyInput | ContactosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Contactos update
   */
  export type ContactosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * The data needed to update a Contactos.
     */
    data: XOR<ContactosUpdateInput, ContactosUncheckedUpdateInput>
    /**
     * Choose, which Contactos to update.
     */
    where: ContactosWhereUniqueInput
  }


  /**
   * Contactos updateMany
   */
  export type ContactosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contactos.
     */
    data: XOR<ContactosUpdateManyMutationInput, ContactosUncheckedUpdateManyInput>
    /**
     * Filter which Contactos to update
     */
    where?: ContactosWhereInput
  }


  /**
   * Contactos upsert
   */
  export type ContactosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * The filter to search for the Contactos to update in case it exists.
     */
    where: ContactosWhereUniqueInput
    /**
     * In case the Contactos found by the `where` argument doesn't exist, create a new Contactos with this data.
     */
    create: XOR<ContactosCreateInput, ContactosUncheckedCreateInput>
    /**
     * In case the Contactos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactosUpdateInput, ContactosUncheckedUpdateInput>
  }


  /**
   * Contactos delete
   */
  export type ContactosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    /**
     * Filter which Contactos to delete.
     */
    where: ContactosWhereUniqueInput
  }


  /**
   * Contactos deleteMany
   */
  export type ContactosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactos to delete
     */
    where?: ContactosWhereInput
  }


  /**
   * Contactos without action
   */
  export type ContactosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
  }



  /**
   * Model Especialistas
   */

  export type AggregateEspecialistas = {
    _count: EspecialistasCountAggregateOutputType | null
    _min: EspecialistasMinAggregateOutputType | null
    _max: EspecialistasMaxAggregateOutputType | null
  }

  export type EspecialistasMinAggregateOutputType = {
    id: string | null
    nome: string | null
    crm: string | null
    especialidade: string | null
    tipo_De_Consulta: string | null
    valor: string | null
    bloqueado: string | null
    sexo: $Enums.Sexo | null
    entidadeID: string | null
  }

  export type EspecialistasMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    crm: string | null
    especialidade: string | null
    tipo_De_Consulta: string | null
    valor: string | null
    bloqueado: string | null
    sexo: $Enums.Sexo | null
    entidadeID: string | null
  }

  export type EspecialistasCountAggregateOutputType = {
    id: number
    nome: number
    crm: number
    especialidade: number
    tipo_De_Consulta: number
    valor: number
    bloqueado: number
    sexo: number
    entidadeID: number
    _all: number
  }


  export type EspecialistasMinAggregateInputType = {
    id?: true
    nome?: true
    crm?: true
    especialidade?: true
    tipo_De_Consulta?: true
    valor?: true
    bloqueado?: true
    sexo?: true
    entidadeID?: true
  }

  export type EspecialistasMaxAggregateInputType = {
    id?: true
    nome?: true
    crm?: true
    especialidade?: true
    tipo_De_Consulta?: true
    valor?: true
    bloqueado?: true
    sexo?: true
    entidadeID?: true
  }

  export type EspecialistasCountAggregateInputType = {
    id?: true
    nome?: true
    crm?: true
    especialidade?: true
    tipo_De_Consulta?: true
    valor?: true
    bloqueado?: true
    sexo?: true
    entidadeID?: true
    _all?: true
  }

  export type EspecialistasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Especialistas to aggregate.
     */
    where?: EspecialistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especialistas to fetch.
     */
    orderBy?: EspecialistasOrderByWithRelationInput | EspecialistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EspecialistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especialistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especialistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Especialistas
    **/
    _count?: true | EspecialistasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecialistasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecialistasMaxAggregateInputType
  }

  export type GetEspecialistasAggregateType<T extends EspecialistasAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecialistas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecialistas[P]>
      : GetScalarType<T[P], AggregateEspecialistas[P]>
  }




  export type EspecialistasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecialistasWhereInput
    orderBy?: EspecialistasOrderByWithAggregationInput | EspecialistasOrderByWithAggregationInput[]
    by: EspecialistasScalarFieldEnum[] | EspecialistasScalarFieldEnum
    having?: EspecialistasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecialistasCountAggregateInputType | true
    _min?: EspecialistasMinAggregateInputType
    _max?: EspecialistasMaxAggregateInputType
  }

  export type EspecialistasGroupByOutputType = {
    id: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor: string | null
    bloqueado: string | null
    sexo: $Enums.Sexo
    entidadeID: string | null
    _count: EspecialistasCountAggregateOutputType | null
    _min: EspecialistasMinAggregateOutputType | null
    _max: EspecialistasMaxAggregateOutputType | null
  }

  type GetEspecialistasGroupByPayload<T extends EspecialistasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecialistasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecialistasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecialistasGroupByOutputType[P]>
            : GetScalarType<T[P], EspecialistasGroupByOutputType[P]>
        }
      >
    >


  export type EspecialistasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    crm?: boolean
    especialidade?: boolean
    tipo_De_Consulta?: boolean
    valor?: boolean
    bloqueado?: boolean
    sexo?: boolean
    entidadeID?: boolean
    entidade?: boolean | Especialistas$entidadeArgs<ExtArgs>
    diasDisponiveis?: boolean | Especialistas$diasDisponiveisArgs<ExtArgs>
    horasDisponiveis?: boolean | Especialistas$horasDisponiveisArgs<ExtArgs>
    consultas?: boolean | Especialistas$consultasArgs<ExtArgs>
    _count?: boolean | EspecialistasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especialistas"]>

  export type EspecialistasSelectScalar = {
    id?: boolean
    nome?: boolean
    crm?: boolean
    especialidade?: boolean
    tipo_De_Consulta?: boolean
    valor?: boolean
    bloqueado?: boolean
    sexo?: boolean
    entidadeID?: boolean
  }

  export type EspecialistasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entidade?: boolean | Especialistas$entidadeArgs<ExtArgs>
    diasDisponiveis?: boolean | Especialistas$diasDisponiveisArgs<ExtArgs>
    horasDisponiveis?: boolean | Especialistas$horasDisponiveisArgs<ExtArgs>
    consultas?: boolean | Especialistas$consultasArgs<ExtArgs>
    _count?: boolean | EspecialistasCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EspecialistasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Especialistas"
    objects: {
      entidade: Prisma.$EntidadesSistemaPayload<ExtArgs> | null
      diasDisponiveis: Prisma.$DiasDisponiveisPayload<ExtArgs>[]
      horasDisponiveis: Prisma.$HorasDisponiveisPayload<ExtArgs>[]
      consultas: Prisma.$ConsultasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      crm: string
      especialidade: string
      tipo_De_Consulta: string
      valor: string | null
      bloqueado: string | null
      sexo: $Enums.Sexo
      entidadeID: string | null
    }, ExtArgs["result"]["especialistas"]>
    composites: {}
  }


  type EspecialistasGetPayload<S extends boolean | null | undefined | EspecialistasDefaultArgs> = $Result.GetResult<Prisma.$EspecialistasPayload, S>

  type EspecialistasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EspecialistasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspecialistasCountAggregateInputType | true
    }

  export interface EspecialistasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Especialistas'], meta: { name: 'Especialistas' } }
    /**
     * Find zero or one Especialistas that matches the filter.
     * @param {EspecialistasFindUniqueArgs} args - Arguments to find a Especialistas
     * @example
     * // Get one Especialistas
     * const especialistas = await prisma.especialistas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EspecialistasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EspecialistasFindUniqueArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Especialistas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EspecialistasFindUniqueOrThrowArgs} args - Arguments to find a Especialistas
     * @example
     * // Get one Especialistas
     * const especialistas = await prisma.especialistas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EspecialistasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EspecialistasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Especialistas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialistasFindFirstArgs} args - Arguments to find a Especialistas
     * @example
     * // Get one Especialistas
     * const especialistas = await prisma.especialistas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EspecialistasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EspecialistasFindFirstArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Especialistas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialistasFindFirstOrThrowArgs} args - Arguments to find a Especialistas
     * @example
     * // Get one Especialistas
     * const especialistas = await prisma.especialistas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EspecialistasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EspecialistasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Especialistas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialistasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especialistas
     * const especialistas = await prisma.especialistas.findMany()
     * 
     * // Get first 10 Especialistas
     * const especialistas = await prisma.especialistas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const especialistasWithIdOnly = await prisma.especialistas.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EspecialistasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspecialistasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Especialistas.
     * @param {EspecialistasCreateArgs} args - Arguments to create a Especialistas.
     * @example
     * // Create one Especialistas
     * const Especialistas = await prisma.especialistas.create({
     *   data: {
     *     // ... data to create a Especialistas
     *   }
     * })
     * 
    **/
    create<T extends EspecialistasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EspecialistasCreateArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Especialistas.
     *     @param {EspecialistasCreateManyArgs} args - Arguments to create many Especialistas.
     *     @example
     *     // Create many Especialistas
     *     const especialistas = await prisma.especialistas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EspecialistasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspecialistasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Especialistas.
     * @param {EspecialistasDeleteArgs} args - Arguments to delete one Especialistas.
     * @example
     * // Delete one Especialistas
     * const Especialistas = await prisma.especialistas.delete({
     *   where: {
     *     // ... filter to delete one Especialistas
     *   }
     * })
     * 
    **/
    delete<T extends EspecialistasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EspecialistasDeleteArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Especialistas.
     * @param {EspecialistasUpdateArgs} args - Arguments to update one Especialistas.
     * @example
     * // Update one Especialistas
     * const especialistas = await prisma.especialistas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EspecialistasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EspecialistasUpdateArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Especialistas.
     * @param {EspecialistasDeleteManyArgs} args - Arguments to filter Especialistas to delete.
     * @example
     * // Delete a few Especialistas
     * const { count } = await prisma.especialistas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EspecialistasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EspecialistasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialistasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especialistas
     * const especialistas = await prisma.especialistas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EspecialistasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EspecialistasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Especialistas.
     * @param {EspecialistasUpsertArgs} args - Arguments to update or create a Especialistas.
     * @example
     * // Update or create a Especialistas
     * const especialistas = await prisma.especialistas.upsert({
     *   create: {
     *     // ... data to create a Especialistas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especialistas we want to update
     *   }
     * })
    **/
    upsert<T extends EspecialistasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EspecialistasUpsertArgs<ExtArgs>>
    ): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Especialistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialistasCountArgs} args - Arguments to filter Especialistas to count.
     * @example
     * // Count the number of Especialistas
     * const count = await prisma.especialistas.count({
     *   where: {
     *     // ... the filter for the Especialistas we want to count
     *   }
     * })
    **/
    count<T extends EspecialistasCountArgs>(
      args?: Subset<T, EspecialistasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecialistasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especialistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialistasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecialistasAggregateArgs>(args: Subset<T, EspecialistasAggregateArgs>): Prisma.PrismaPromise<GetEspecialistasAggregateType<T>>

    /**
     * Group by Especialistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialistasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EspecialistasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EspecialistasGroupByArgs['orderBy'] }
        : { orderBy?: EspecialistasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EspecialistasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecialistasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Especialistas model
   */
  readonly fields: EspecialistasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Especialistas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EspecialistasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    entidade<T extends Especialistas$entidadeArgs<ExtArgs> = {}>(args?: Subset<T, Especialistas$entidadeArgs<ExtArgs>>): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    diasDisponiveis<T extends Especialistas$diasDisponiveisArgs<ExtArgs> = {}>(args?: Subset<T, Especialistas$diasDisponiveisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'findMany'> | Null>;

    horasDisponiveis<T extends Especialistas$horasDisponiveisArgs<ExtArgs> = {}>(args?: Subset<T, Especialistas$horasDisponiveisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'findMany'> | Null>;

    consultas<T extends Especialistas$consultasArgs<ExtArgs> = {}>(args?: Subset<T, Especialistas$consultasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Especialistas model
   */ 
  interface EspecialistasFieldRefs {
    readonly id: FieldRef<"Especialistas", 'String'>
    readonly nome: FieldRef<"Especialistas", 'String'>
    readonly crm: FieldRef<"Especialistas", 'String'>
    readonly especialidade: FieldRef<"Especialistas", 'String'>
    readonly tipo_De_Consulta: FieldRef<"Especialistas", 'String'>
    readonly valor: FieldRef<"Especialistas", 'String'>
    readonly bloqueado: FieldRef<"Especialistas", 'String'>
    readonly sexo: FieldRef<"Especialistas", 'Sexo'>
    readonly entidadeID: FieldRef<"Especialistas", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Especialistas findUnique
   */
  export type EspecialistasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * Filter, which Especialistas to fetch.
     */
    where: EspecialistasWhereUniqueInput
  }


  /**
   * Especialistas findUniqueOrThrow
   */
  export type EspecialistasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * Filter, which Especialistas to fetch.
     */
    where: EspecialistasWhereUniqueInput
  }


  /**
   * Especialistas findFirst
   */
  export type EspecialistasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * Filter, which Especialistas to fetch.
     */
    where?: EspecialistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especialistas to fetch.
     */
    orderBy?: EspecialistasOrderByWithRelationInput | EspecialistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Especialistas.
     */
    cursor?: EspecialistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especialistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especialistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Especialistas.
     */
    distinct?: EspecialistasScalarFieldEnum | EspecialistasScalarFieldEnum[]
  }


  /**
   * Especialistas findFirstOrThrow
   */
  export type EspecialistasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * Filter, which Especialistas to fetch.
     */
    where?: EspecialistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especialistas to fetch.
     */
    orderBy?: EspecialistasOrderByWithRelationInput | EspecialistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Especialistas.
     */
    cursor?: EspecialistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especialistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especialistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Especialistas.
     */
    distinct?: EspecialistasScalarFieldEnum | EspecialistasScalarFieldEnum[]
  }


  /**
   * Especialistas findMany
   */
  export type EspecialistasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * Filter, which Especialistas to fetch.
     */
    where?: EspecialistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especialistas to fetch.
     */
    orderBy?: EspecialistasOrderByWithRelationInput | EspecialistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Especialistas.
     */
    cursor?: EspecialistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especialistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especialistas.
     */
    skip?: number
    distinct?: EspecialistasScalarFieldEnum | EspecialistasScalarFieldEnum[]
  }


  /**
   * Especialistas create
   */
  export type EspecialistasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * The data needed to create a Especialistas.
     */
    data: XOR<EspecialistasCreateInput, EspecialistasUncheckedCreateInput>
  }


  /**
   * Especialistas createMany
   */
  export type EspecialistasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Especialistas.
     */
    data: EspecialistasCreateManyInput | EspecialistasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Especialistas update
   */
  export type EspecialistasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * The data needed to update a Especialistas.
     */
    data: XOR<EspecialistasUpdateInput, EspecialistasUncheckedUpdateInput>
    /**
     * Choose, which Especialistas to update.
     */
    where: EspecialistasWhereUniqueInput
  }


  /**
   * Especialistas updateMany
   */
  export type EspecialistasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Especialistas.
     */
    data: XOR<EspecialistasUpdateManyMutationInput, EspecialistasUncheckedUpdateManyInput>
    /**
     * Filter which Especialistas to update
     */
    where?: EspecialistasWhereInput
  }


  /**
   * Especialistas upsert
   */
  export type EspecialistasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * The filter to search for the Especialistas to update in case it exists.
     */
    where: EspecialistasWhereUniqueInput
    /**
     * In case the Especialistas found by the `where` argument doesn't exist, create a new Especialistas with this data.
     */
    create: XOR<EspecialistasCreateInput, EspecialistasUncheckedCreateInput>
    /**
     * In case the Especialistas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EspecialistasUpdateInput, EspecialistasUncheckedUpdateInput>
  }


  /**
   * Especialistas delete
   */
  export type EspecialistasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
    /**
     * Filter which Especialistas to delete.
     */
    where: EspecialistasWhereUniqueInput
  }


  /**
   * Especialistas deleteMany
   */
  export type EspecialistasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Especialistas to delete
     */
    where?: EspecialistasWhereInput
  }


  /**
   * Especialistas.entidade
   */
  export type Especialistas$entidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntidadesSistema
     */
    select?: EntidadesSistemaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntidadesSistemaInclude<ExtArgs> | null
    where?: EntidadesSistemaWhereInput
  }


  /**
   * Especialistas.diasDisponiveis
   */
  export type Especialistas$diasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    where?: DiasDisponiveisWhereInput
    orderBy?: DiasDisponiveisOrderByWithRelationInput | DiasDisponiveisOrderByWithRelationInput[]
    cursor?: DiasDisponiveisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiasDisponiveisScalarFieldEnum | DiasDisponiveisScalarFieldEnum[]
  }


  /**
   * Especialistas.horasDisponiveis
   */
  export type Especialistas$horasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    where?: HorasDisponiveisWhereInput
    orderBy?: HorasDisponiveisOrderByWithRelationInput | HorasDisponiveisOrderByWithRelationInput[]
    cursor?: HorasDisponiveisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HorasDisponiveisScalarFieldEnum | HorasDisponiveisScalarFieldEnum[]
  }


  /**
   * Especialistas.consultas
   */
  export type Especialistas$consultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    where?: ConsultasWhereInput
    orderBy?: ConsultasOrderByWithRelationInput | ConsultasOrderByWithRelationInput[]
    cursor?: ConsultasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }


  /**
   * Especialistas without action
   */
  export type EspecialistasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especialistas
     */
    select?: EspecialistasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EspecialistasInclude<ExtArgs> | null
  }



  /**
   * Model Usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    crm: string | null
    cnpj: string | null
    foto: string | null
    senha: string | null
    sobre: string | null
    sexo: $Enums.Sexo | null
    socketID: string | null
    nascimento: Date | null
  }

  export type UsuariosMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    crm: string | null
    cnpj: string | null
    foto: string | null
    senha: string | null
    sobre: string | null
    sexo: $Enums.Sexo | null
    socketID: string | null
    nascimento: Date | null
  }

  export type UsuariosCountAggregateOutputType = {
    id: number
    name: number
    email: number
    crm: number
    cnpj: number
    foto: number
    senha: number
    sobre: number
    sexo: number
    socketID: number
    nascimento: number
    _all: number
  }


  export type UsuariosMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    crm?: true
    cnpj?: true
    foto?: true
    senha?: true
    sobre?: true
    sexo?: true
    socketID?: true
    nascimento?: true
  }

  export type UsuariosMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    crm?: true
    cnpj?: true
    foto?: true
    senha?: true
    sobre?: true
    sexo?: true
    socketID?: true
    nascimento?: true
  }

  export type UsuariosCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    crm?: true
    cnpj?: true
    foto?: true
    senha?: true
    sobre?: true
    sexo?: true
    socketID?: true
    nascimento?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to aggregate.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type UsuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithAggregationInput | UsuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: UsuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    id: string
    name: string
    email: string
    crm: string | null
    cnpj: string | null
    foto: string | null
    senha: string
    sobre: string | null
    sexo: $Enums.Sexo
    socketID: string | null
    nascimento: Date
    _count: UsuariosCountAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends UsuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type UsuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    crm?: boolean
    cnpj?: boolean
    foto?: boolean
    senha?: boolean
    sobre?: boolean
    sexo?: boolean
    socketID?: boolean
    nascimento?: boolean
    contactos?: boolean | Usuarios$contactosArgs<ExtArgs>
    pubblicacoes?: boolean | Usuarios$pubblicacoesArgs<ExtArgs>
    origem?: boolean | Usuarios$origemArgs<ExtArgs>
    destinatarioNotificacao?: boolean | Usuarios$destinatarioNotificacaoArgs<ExtArgs>
    consultas?: boolean | Usuarios$consultasArgs<ExtArgs>
    mensagensEnviadas?: boolean | Usuarios$mensagensEnviadasArgs<ExtArgs>
    mensagensRecebidas?: boolean | Usuarios$mensagensRecebidasArgs<ExtArgs>
    remetente?: boolean | Usuarios$remetenteArgs<ExtArgs>
    destinatario?: boolean | Usuarios$destinatarioArgs<ExtArgs>
    emissorDoPedido?: boolean | Usuarios$emissorDoPedidoArgs<ExtArgs>
    receptorDoPedido?: boolean | Usuarios$receptorDoPedidoArgs<ExtArgs>
    reacoes?: boolean | Usuarios$reacoesArgs<ExtArgs>
    comentarios?: boolean | Usuarios$comentariosArgs<ExtArgs>
    seguidor?: boolean | Usuarios$seguidorArgs<ExtArgs>
    partilha?: boolean | Usuarios$partilhaArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    crm?: boolean
    cnpj?: boolean
    foto?: boolean
    senha?: boolean
    sobre?: boolean
    sexo?: boolean
    socketID?: boolean
    nascimento?: boolean
  }

  export type UsuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactos?: boolean | Usuarios$contactosArgs<ExtArgs>
    pubblicacoes?: boolean | Usuarios$pubblicacoesArgs<ExtArgs>
    origem?: boolean | Usuarios$origemArgs<ExtArgs>
    destinatarioNotificacao?: boolean | Usuarios$destinatarioNotificacaoArgs<ExtArgs>
    consultas?: boolean | Usuarios$consultasArgs<ExtArgs>
    mensagensEnviadas?: boolean | Usuarios$mensagensEnviadasArgs<ExtArgs>
    mensagensRecebidas?: boolean | Usuarios$mensagensRecebidasArgs<ExtArgs>
    remetente?: boolean | Usuarios$remetenteArgs<ExtArgs>
    destinatario?: boolean | Usuarios$destinatarioArgs<ExtArgs>
    emissorDoPedido?: boolean | Usuarios$emissorDoPedidoArgs<ExtArgs>
    receptorDoPedido?: boolean | Usuarios$receptorDoPedidoArgs<ExtArgs>
    reacoes?: boolean | Usuarios$reacoesArgs<ExtArgs>
    comentarios?: boolean | Usuarios$comentariosArgs<ExtArgs>
    seguidor?: boolean | Usuarios$seguidorArgs<ExtArgs>
    partilha?: boolean | Usuarios$partilhaArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UsuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuarios"
    objects: {
      contactos: Prisma.$ContactosPayload<ExtArgs>[]
      pubblicacoes: Prisma.$PublicacoesPayload<ExtArgs>[]
      origem: Prisma.$NotificacoesPayload<ExtArgs>[]
      destinatarioNotificacao: Prisma.$NotificacoesPayload<ExtArgs>[]
      consultas: Prisma.$ConsultasPayload<ExtArgs>[]
      mensagensEnviadas: Prisma.$MensagensPayload<ExtArgs>[]
      mensagensRecebidas: Prisma.$MensagensPayload<ExtArgs>[]
      remetente: Prisma.$MinhasConexoesPayload<ExtArgs>[]
      destinatario: Prisma.$MinhasConexoesPayload<ExtArgs>[]
      emissorDoPedido: Prisma.$PedidoDeConexaoPayload<ExtArgs>[]
      receptorDoPedido: Prisma.$PedidoDeConexaoPayload<ExtArgs>[]
      reacoes: Prisma.$ReacoesPayload<ExtArgs>[]
      comentarios: Prisma.$ComentariosPayload<ExtArgs>[]
      seguidor: Prisma.$SeguidoresPayload<ExtArgs>[]
      partilha: Prisma.$PartilhaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      crm: string | null
      cnpj: string | null
      foto: string | null
      senha: string
      sobre: string | null
      sexo: $Enums.Sexo
      socketID: string | null
      nascimento: Date
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }


  type UsuariosGetPayload<S extends boolean | null | undefined | UsuariosDefaultArgs> = $Result.GetResult<Prisma.$UsuariosPayload, S>

  type UsuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface UsuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuarios'], meta: { name: 'Usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {UsuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuariosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuariosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindFirstArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuarios.
     * @param {UsuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
    **/
    create<T extends UsuariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosCreateArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuariosCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuarios = await prisma.usuarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios.
     * @param {UsuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
    **/
    delete<T extends UsuariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosDeleteArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuarios.
     * @param {UsuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpdateArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {UsuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
    **/
    upsert<T extends UsuariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpsertArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuariosCountArgs>(
      args?: Subset<T, UsuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuarios model
   */
  readonly fields: UsuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contactos<T extends Usuarios$contactosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$contactosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactosPayload<ExtArgs>, T, 'findMany'> | Null>;

    pubblicacoes<T extends Usuarios$pubblicacoesArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$pubblicacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    origem<T extends Usuarios$origemArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$origemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    destinatarioNotificacao<T extends Usuarios$destinatarioNotificacaoArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$destinatarioNotificacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    consultas<T extends Usuarios$consultasArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$consultasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findMany'> | Null>;

    mensagensEnviadas<T extends Usuarios$mensagensEnviadasArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$mensagensEnviadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'findMany'> | Null>;

    mensagensRecebidas<T extends Usuarios$mensagensRecebidasArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$mensagensRecebidasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'findMany'> | Null>;

    remetente<T extends Usuarios$remetenteArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$remetenteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    destinatario<T extends Usuarios$destinatarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$destinatarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    emissorDoPedido<T extends Usuarios$emissorDoPedidoArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$emissorDoPedidoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'findMany'> | Null>;

    receptorDoPedido<T extends Usuarios$receptorDoPedidoArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$receptorDoPedidoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'findMany'> | Null>;

    reacoes<T extends Usuarios$reacoesArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$reacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    comentarios<T extends Usuarios$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'findMany'> | Null>;

    seguidor<T extends Usuarios$seguidorArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$seguidorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'findMany'> | Null>;

    partilha<T extends Usuarios$partilhaArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$partilhaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuarios model
   */ 
  interface UsuariosFieldRefs {
    readonly id: FieldRef<"Usuarios", 'String'>
    readonly name: FieldRef<"Usuarios", 'String'>
    readonly email: FieldRef<"Usuarios", 'String'>
    readonly crm: FieldRef<"Usuarios", 'String'>
    readonly cnpj: FieldRef<"Usuarios", 'String'>
    readonly foto: FieldRef<"Usuarios", 'String'>
    readonly senha: FieldRef<"Usuarios", 'String'>
    readonly sobre: FieldRef<"Usuarios", 'String'>
    readonly sexo: FieldRef<"Usuarios", 'Sexo'>
    readonly socketID: FieldRef<"Usuarios", 'String'>
    readonly nascimento: FieldRef<"Usuarios", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Usuarios findUnique
   */
  export type UsuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios findUniqueOrThrow
   */
  export type UsuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios findFirst
   */
  export type UsuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios findFirstOrThrow
   */
  export type UsuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios findMany
   */
  export type UsuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios create
   */
  export type UsuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuarios.
     */
    data: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
  }


  /**
   * Usuarios createMany
   */
  export type UsuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Usuarios update
   */
  export type UsuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuarios.
     */
    data: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
    /**
     * Choose, which Usuarios to update.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios updateMany
   */
  export type UsuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
  }


  /**
   * Usuarios upsert
   */
  export type UsuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuarios to update in case it exists.
     */
    where: UsuariosWhereUniqueInput
    /**
     * In case the Usuarios found by the `where` argument doesn't exist, create a new Usuarios with this data.
     */
    create: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
    /**
     * In case the Usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
  }


  /**
   * Usuarios delete
   */
  export type UsuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter which Usuarios to delete.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios deleteMany
   */
  export type UsuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuariosWhereInput
  }


  /**
   * Usuarios.contactos
   */
  export type Usuarios$contactosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contactos
     */
    select?: ContactosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactosInclude<ExtArgs> | null
    where?: ContactosWhereInput
    orderBy?: ContactosOrderByWithRelationInput | ContactosOrderByWithRelationInput[]
    cursor?: ContactosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactosScalarFieldEnum | ContactosScalarFieldEnum[]
  }


  /**
   * Usuarios.pubblicacoes
   */
  export type Usuarios$pubblicacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    where?: PublicacoesWhereInput
    orderBy?: PublicacoesOrderByWithRelationInput | PublicacoesOrderByWithRelationInput[]
    cursor?: PublicacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicacoesScalarFieldEnum | PublicacoesScalarFieldEnum[]
  }


  /**
   * Usuarios.origem
   */
  export type Usuarios$origemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    where?: NotificacoesWhereInput
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    cursor?: NotificacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacoesScalarFieldEnum | NotificacoesScalarFieldEnum[]
  }


  /**
   * Usuarios.destinatarioNotificacao
   */
  export type Usuarios$destinatarioNotificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    where?: NotificacoesWhereInput
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    cursor?: NotificacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacoesScalarFieldEnum | NotificacoesScalarFieldEnum[]
  }


  /**
   * Usuarios.consultas
   */
  export type Usuarios$consultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    where?: ConsultasWhereInput
    orderBy?: ConsultasOrderByWithRelationInput | ConsultasOrderByWithRelationInput[]
    cursor?: ConsultasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }


  /**
   * Usuarios.mensagensEnviadas
   */
  export type Usuarios$mensagensEnviadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    where?: MensagensWhereInput
    orderBy?: MensagensOrderByWithRelationInput | MensagensOrderByWithRelationInput[]
    cursor?: MensagensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MensagensScalarFieldEnum | MensagensScalarFieldEnum[]
  }


  /**
   * Usuarios.mensagensRecebidas
   */
  export type Usuarios$mensagensRecebidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    where?: MensagensWhereInput
    orderBy?: MensagensOrderByWithRelationInput | MensagensOrderByWithRelationInput[]
    cursor?: MensagensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MensagensScalarFieldEnum | MensagensScalarFieldEnum[]
  }


  /**
   * Usuarios.remetente
   */
  export type Usuarios$remetenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    where?: MinhasConexoesWhereInput
    orderBy?: MinhasConexoesOrderByWithRelationInput | MinhasConexoesOrderByWithRelationInput[]
    cursor?: MinhasConexoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinhasConexoesScalarFieldEnum | MinhasConexoesScalarFieldEnum[]
  }


  /**
   * Usuarios.destinatario
   */
  export type Usuarios$destinatarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    where?: MinhasConexoesWhereInput
    orderBy?: MinhasConexoesOrderByWithRelationInput | MinhasConexoesOrderByWithRelationInput[]
    cursor?: MinhasConexoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinhasConexoesScalarFieldEnum | MinhasConexoesScalarFieldEnum[]
  }


  /**
   * Usuarios.emissorDoPedido
   */
  export type Usuarios$emissorDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    where?: PedidoDeConexaoWhereInput
    orderBy?: PedidoDeConexaoOrderByWithRelationInput | PedidoDeConexaoOrderByWithRelationInput[]
    cursor?: PedidoDeConexaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoDeConexaoScalarFieldEnum | PedidoDeConexaoScalarFieldEnum[]
  }


  /**
   * Usuarios.receptorDoPedido
   */
  export type Usuarios$receptorDoPedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    where?: PedidoDeConexaoWhereInput
    orderBy?: PedidoDeConexaoOrderByWithRelationInput | PedidoDeConexaoOrderByWithRelationInput[]
    cursor?: PedidoDeConexaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoDeConexaoScalarFieldEnum | PedidoDeConexaoScalarFieldEnum[]
  }


  /**
   * Usuarios.reacoes
   */
  export type Usuarios$reacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    where?: ReacoesWhereInput
    orderBy?: ReacoesOrderByWithRelationInput | ReacoesOrderByWithRelationInput[]
    cursor?: ReacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReacoesScalarFieldEnum | ReacoesScalarFieldEnum[]
  }


  /**
   * Usuarios.comentarios
   */
  export type Usuarios$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    where?: ComentariosWhereInput
    orderBy?: ComentariosOrderByWithRelationInput | ComentariosOrderByWithRelationInput[]
    cursor?: ComentariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }


  /**
   * Usuarios.seguidor
   */
  export type Usuarios$seguidorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    where?: SeguidoresWhereInput
    orderBy?: SeguidoresOrderByWithRelationInput | SeguidoresOrderByWithRelationInput[]
    cursor?: SeguidoresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeguidoresScalarFieldEnum | SeguidoresScalarFieldEnum[]
  }


  /**
   * Usuarios.partilha
   */
  export type Usuarios$partilhaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    where?: PartilhaWhereInput
    orderBy?: PartilhaOrderByWithRelationInput | PartilhaOrderByWithRelationInput[]
    cursor?: PartilhaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartilhaScalarFieldEnum | PartilhaScalarFieldEnum[]
  }


  /**
   * Usuarios without action
   */
  export type UsuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuariosInclude<ExtArgs> | null
  }



  /**
   * Model Publicacoes
   */

  export type AggregatePublicacoes = {
    _count: PublicacoesCountAggregateOutputType | null
    _min: PublicacoesMinAggregateOutputType | null
    _max: PublicacoesMaxAggregateOutputType | null
  }

  export type PublicacoesMinAggregateOutputType = {
    id: string | null
    conteudo: string | null
    foto: string | null
    video: string | null
    data: Date | null
    updatedAt: Date | null
    usuarioID: string | null
  }

  export type PublicacoesMaxAggregateOutputType = {
    id: string | null
    conteudo: string | null
    foto: string | null
    video: string | null
    data: Date | null
    updatedAt: Date | null
    usuarioID: string | null
  }

  export type PublicacoesCountAggregateOutputType = {
    id: number
    conteudo: number
    foto: number
    video: number
    data: number
    updatedAt: number
    usuarioID: number
    _all: number
  }


  export type PublicacoesMinAggregateInputType = {
    id?: true
    conteudo?: true
    foto?: true
    video?: true
    data?: true
    updatedAt?: true
    usuarioID?: true
  }

  export type PublicacoesMaxAggregateInputType = {
    id?: true
    conteudo?: true
    foto?: true
    video?: true
    data?: true
    updatedAt?: true
    usuarioID?: true
  }

  export type PublicacoesCountAggregateInputType = {
    id?: true
    conteudo?: true
    foto?: true
    video?: true
    data?: true
    updatedAt?: true
    usuarioID?: true
    _all?: true
  }

  export type PublicacoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publicacoes to aggregate.
     */
    where?: PublicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publicacoes to fetch.
     */
    orderBy?: PublicacoesOrderByWithRelationInput | PublicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publicacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publicacoes
    **/
    _count?: true | PublicacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicacoesMaxAggregateInputType
  }

  export type GetPublicacoesAggregateType<T extends PublicacoesAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicacoes[P]>
      : GetScalarType<T[P], AggregatePublicacoes[P]>
  }




  export type PublicacoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicacoesWhereInput
    orderBy?: PublicacoesOrderByWithAggregationInput | PublicacoesOrderByWithAggregationInput[]
    by: PublicacoesScalarFieldEnum[] | PublicacoesScalarFieldEnum
    having?: PublicacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicacoesCountAggregateInputType | true
    _min?: PublicacoesMinAggregateInputType
    _max?: PublicacoesMaxAggregateInputType
  }

  export type PublicacoesGroupByOutputType = {
    id: string
    conteudo: string
    foto: string | null
    video: string | null
    data: Date
    updatedAt: Date
    usuarioID: string
    _count: PublicacoesCountAggregateOutputType | null
    _min: PublicacoesMinAggregateOutputType | null
    _max: PublicacoesMaxAggregateOutputType | null
  }

  type GetPublicacoesGroupByPayload<T extends PublicacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicacoesGroupByOutputType[P]>
            : GetScalarType<T[P], PublicacoesGroupByOutputType[P]>
        }
      >
    >


  export type PublicacoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conteudo?: boolean
    foto?: boolean
    video?: boolean
    data?: boolean
    updatedAt?: boolean
    usuarioID?: boolean
    usuarioPub?: boolean | UsuariosDefaultArgs<ExtArgs>
    reacoes?: boolean | Publicacoes$reacoesArgs<ExtArgs>
    comentarios?: boolean | Publicacoes$comentariosArgs<ExtArgs>
    notificacao?: boolean | Publicacoes$notificacaoArgs<ExtArgs>
    postPartilhado?: boolean | Publicacoes$postPartilhadoArgs<ExtArgs>
    postCriado?: boolean | Publicacoes$postCriadoArgs<ExtArgs>
    _count?: boolean | PublicacoesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicacoes"]>

  export type PublicacoesSelectScalar = {
    id?: boolean
    conteudo?: boolean
    foto?: boolean
    video?: boolean
    data?: boolean
    updatedAt?: boolean
    usuarioID?: boolean
  }

  export type PublicacoesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarioPub?: boolean | UsuariosDefaultArgs<ExtArgs>
    reacoes?: boolean | Publicacoes$reacoesArgs<ExtArgs>
    comentarios?: boolean | Publicacoes$comentariosArgs<ExtArgs>
    notificacao?: boolean | Publicacoes$notificacaoArgs<ExtArgs>
    postPartilhado?: boolean | Publicacoes$postPartilhadoArgs<ExtArgs>
    postCriado?: boolean | Publicacoes$postCriadoArgs<ExtArgs>
    _count?: boolean | PublicacoesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PublicacoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Publicacoes"
    objects: {
      usuarioPub: Prisma.$UsuariosPayload<ExtArgs>
      reacoes: Prisma.$ReacoesPayload<ExtArgs>[]
      comentarios: Prisma.$ComentariosPayload<ExtArgs>[]
      notificacao: Prisma.$NotificacoesPayload<ExtArgs>[]
      postPartilhado: Prisma.$PartilhaPayload<ExtArgs>[]
      postCriado: Prisma.$PartilhaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conteudo: string
      foto: string | null
      video: string | null
      data: Date
      updatedAt: Date
      usuarioID: string
    }, ExtArgs["result"]["publicacoes"]>
    composites: {}
  }


  type PublicacoesGetPayload<S extends boolean | null | undefined | PublicacoesDefaultArgs> = $Result.GetResult<Prisma.$PublicacoesPayload, S>

  type PublicacoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PublicacoesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PublicacoesCountAggregateInputType | true
    }

  export interface PublicacoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Publicacoes'], meta: { name: 'Publicacoes' } }
    /**
     * Find zero or one Publicacoes that matches the filter.
     * @param {PublicacoesFindUniqueArgs} args - Arguments to find a Publicacoes
     * @example
     * // Get one Publicacoes
     * const publicacoes = await prisma.publicacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PublicacoesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PublicacoesFindUniqueArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Publicacoes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PublicacoesFindUniqueOrThrowArgs} args - Arguments to find a Publicacoes
     * @example
     * // Get one Publicacoes
     * const publicacoes = await prisma.publicacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PublicacoesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicacoesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Publicacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacoesFindFirstArgs} args - Arguments to find a Publicacoes
     * @example
     * // Get one Publicacoes
     * const publicacoes = await prisma.publicacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PublicacoesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicacoesFindFirstArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Publicacoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacoesFindFirstOrThrowArgs} args - Arguments to find a Publicacoes
     * @example
     * // Get one Publicacoes
     * const publicacoes = await prisma.publicacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PublicacoesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicacoesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Publicacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacoesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publicacoes
     * const publicacoes = await prisma.publicacoes.findMany()
     * 
     * // Get first 10 Publicacoes
     * const publicacoes = await prisma.publicacoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicacoesWithIdOnly = await prisma.publicacoes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PublicacoesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicacoesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Publicacoes.
     * @param {PublicacoesCreateArgs} args - Arguments to create a Publicacoes.
     * @example
     * // Create one Publicacoes
     * const Publicacoes = await prisma.publicacoes.create({
     *   data: {
     *     // ... data to create a Publicacoes
     *   }
     * })
     * 
    **/
    create<T extends PublicacoesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PublicacoesCreateArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Publicacoes.
     *     @param {PublicacoesCreateManyArgs} args - Arguments to create many Publicacoes.
     *     @example
     *     // Create many Publicacoes
     *     const publicacoes = await prisma.publicacoes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PublicacoesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicacoesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Publicacoes.
     * @param {PublicacoesDeleteArgs} args - Arguments to delete one Publicacoes.
     * @example
     * // Delete one Publicacoes
     * const Publicacoes = await prisma.publicacoes.delete({
     *   where: {
     *     // ... filter to delete one Publicacoes
     *   }
     * })
     * 
    **/
    delete<T extends PublicacoesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PublicacoesDeleteArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Publicacoes.
     * @param {PublicacoesUpdateArgs} args - Arguments to update one Publicacoes.
     * @example
     * // Update one Publicacoes
     * const publicacoes = await prisma.publicacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PublicacoesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PublicacoesUpdateArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Publicacoes.
     * @param {PublicacoesDeleteManyArgs} args - Arguments to filter Publicacoes to delete.
     * @example
     * // Delete a few Publicacoes
     * const { count } = await prisma.publicacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PublicacoesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicacoesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publicacoes
     * const publicacoes = await prisma.publicacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PublicacoesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PublicacoesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publicacoes.
     * @param {PublicacoesUpsertArgs} args - Arguments to update or create a Publicacoes.
     * @example
     * // Update or create a Publicacoes
     * const publicacoes = await prisma.publicacoes.upsert({
     *   create: {
     *     // ... data to create a Publicacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publicacoes we want to update
     *   }
     * })
    **/
    upsert<T extends PublicacoesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PublicacoesUpsertArgs<ExtArgs>>
    ): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Publicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacoesCountArgs} args - Arguments to filter Publicacoes to count.
     * @example
     * // Count the number of Publicacoes
     * const count = await prisma.publicacoes.count({
     *   where: {
     *     // ... the filter for the Publicacoes we want to count
     *   }
     * })
    **/
    count<T extends PublicacoesCountArgs>(
      args?: Subset<T, PublicacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicacoesAggregateArgs>(args: Subset<T, PublicacoesAggregateArgs>): Prisma.PrismaPromise<GetPublicacoesAggregateType<T>>

    /**
     * Group by Publicacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicacoesGroupByArgs['orderBy'] }
        : { orderBy?: PublicacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Publicacoes model
   */
  readonly fields: PublicacoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publicacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicacoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuarioPub<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    reacoes<T extends Publicacoes$reacoesArgs<ExtArgs> = {}>(args?: Subset<T, Publicacoes$reacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    comentarios<T extends Publicacoes$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Publicacoes$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'findMany'> | Null>;

    notificacao<T extends Publicacoes$notificacaoArgs<ExtArgs> = {}>(args?: Subset<T, Publicacoes$notificacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    postPartilhado<T extends Publicacoes$postPartilhadoArgs<ExtArgs> = {}>(args?: Subset<T, Publicacoes$postPartilhadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findMany'> | Null>;

    postCriado<T extends Publicacoes$postCriadoArgs<ExtArgs> = {}>(args?: Subset<T, Publicacoes$postCriadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Publicacoes model
   */ 
  interface PublicacoesFieldRefs {
    readonly id: FieldRef<"Publicacoes", 'String'>
    readonly conteudo: FieldRef<"Publicacoes", 'String'>
    readonly foto: FieldRef<"Publicacoes", 'String'>
    readonly video: FieldRef<"Publicacoes", 'String'>
    readonly data: FieldRef<"Publicacoes", 'DateTime'>
    readonly updatedAt: FieldRef<"Publicacoes", 'DateTime'>
    readonly usuarioID: FieldRef<"Publicacoes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Publicacoes findUnique
   */
  export type PublicacoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * Filter, which Publicacoes to fetch.
     */
    where: PublicacoesWhereUniqueInput
  }


  /**
   * Publicacoes findUniqueOrThrow
   */
  export type PublicacoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * Filter, which Publicacoes to fetch.
     */
    where: PublicacoesWhereUniqueInput
  }


  /**
   * Publicacoes findFirst
   */
  export type PublicacoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * Filter, which Publicacoes to fetch.
     */
    where?: PublicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publicacoes to fetch.
     */
    orderBy?: PublicacoesOrderByWithRelationInput | PublicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publicacoes.
     */
    cursor?: PublicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publicacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publicacoes.
     */
    distinct?: PublicacoesScalarFieldEnum | PublicacoesScalarFieldEnum[]
  }


  /**
   * Publicacoes findFirstOrThrow
   */
  export type PublicacoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * Filter, which Publicacoes to fetch.
     */
    where?: PublicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publicacoes to fetch.
     */
    orderBy?: PublicacoesOrderByWithRelationInput | PublicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publicacoes.
     */
    cursor?: PublicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publicacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publicacoes.
     */
    distinct?: PublicacoesScalarFieldEnum | PublicacoesScalarFieldEnum[]
  }


  /**
   * Publicacoes findMany
   */
  export type PublicacoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * Filter, which Publicacoes to fetch.
     */
    where?: PublicacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publicacoes to fetch.
     */
    orderBy?: PublicacoesOrderByWithRelationInput | PublicacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publicacoes.
     */
    cursor?: PublicacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publicacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publicacoes.
     */
    skip?: number
    distinct?: PublicacoesScalarFieldEnum | PublicacoesScalarFieldEnum[]
  }


  /**
   * Publicacoes create
   */
  export type PublicacoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * The data needed to create a Publicacoes.
     */
    data: XOR<PublicacoesCreateInput, PublicacoesUncheckedCreateInput>
  }


  /**
   * Publicacoes createMany
   */
  export type PublicacoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Publicacoes.
     */
    data: PublicacoesCreateManyInput | PublicacoesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Publicacoes update
   */
  export type PublicacoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * The data needed to update a Publicacoes.
     */
    data: XOR<PublicacoesUpdateInput, PublicacoesUncheckedUpdateInput>
    /**
     * Choose, which Publicacoes to update.
     */
    where: PublicacoesWhereUniqueInput
  }


  /**
   * Publicacoes updateMany
   */
  export type PublicacoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Publicacoes.
     */
    data: XOR<PublicacoesUpdateManyMutationInput, PublicacoesUncheckedUpdateManyInput>
    /**
     * Filter which Publicacoes to update
     */
    where?: PublicacoesWhereInput
  }


  /**
   * Publicacoes upsert
   */
  export type PublicacoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * The filter to search for the Publicacoes to update in case it exists.
     */
    where: PublicacoesWhereUniqueInput
    /**
     * In case the Publicacoes found by the `where` argument doesn't exist, create a new Publicacoes with this data.
     */
    create: XOR<PublicacoesCreateInput, PublicacoesUncheckedCreateInput>
    /**
     * In case the Publicacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicacoesUpdateInput, PublicacoesUncheckedUpdateInput>
  }


  /**
   * Publicacoes delete
   */
  export type PublicacoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
    /**
     * Filter which Publicacoes to delete.
     */
    where: PublicacoesWhereUniqueInput
  }


  /**
   * Publicacoes deleteMany
   */
  export type PublicacoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publicacoes to delete
     */
    where?: PublicacoesWhereInput
  }


  /**
   * Publicacoes.reacoes
   */
  export type Publicacoes$reacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    where?: ReacoesWhereInput
    orderBy?: ReacoesOrderByWithRelationInput | ReacoesOrderByWithRelationInput[]
    cursor?: ReacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReacoesScalarFieldEnum | ReacoesScalarFieldEnum[]
  }


  /**
   * Publicacoes.comentarios
   */
  export type Publicacoes$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    where?: ComentariosWhereInput
    orderBy?: ComentariosOrderByWithRelationInput | ComentariosOrderByWithRelationInput[]
    cursor?: ComentariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }


  /**
   * Publicacoes.notificacao
   */
  export type Publicacoes$notificacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    where?: NotificacoesWhereInput
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    cursor?: NotificacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacoesScalarFieldEnum | NotificacoesScalarFieldEnum[]
  }


  /**
   * Publicacoes.postPartilhado
   */
  export type Publicacoes$postPartilhadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    where?: PartilhaWhereInput
    orderBy?: PartilhaOrderByWithRelationInput | PartilhaOrderByWithRelationInput[]
    cursor?: PartilhaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartilhaScalarFieldEnum | PartilhaScalarFieldEnum[]
  }


  /**
   * Publicacoes.postCriado
   */
  export type Publicacoes$postCriadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    where?: PartilhaWhereInput
    orderBy?: PartilhaOrderByWithRelationInput | PartilhaOrderByWithRelationInput[]
    cursor?: PartilhaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartilhaScalarFieldEnum | PartilhaScalarFieldEnum[]
  }


  /**
   * Publicacoes without action
   */
  export type PublicacoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publicacoes
     */
    select?: PublicacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicacoesInclude<ExtArgs> | null
  }



  /**
   * Model Comentarios
   */

  export type AggregateComentarios = {
    _count: ComentariosCountAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  export type ComentariosMinAggregateOutputType = {
    id: string | null
    postId: string | null
    autorId: string | null
    conteudo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentariosMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    autorId: string | null
    conteudo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentariosCountAggregateOutputType = {
    id: number
    postId: number
    autorId: number
    conteudo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComentariosMinAggregateInputType = {
    id?: true
    postId?: true
    autorId?: true
    conteudo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentariosMaxAggregateInputType = {
    id?: true
    postId?: true
    autorId?: true
    conteudo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentariosCountAggregateInputType = {
    id?: true
    postId?: true
    autorId?: true
    conteudo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComentariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentarios to aggregate.
     */
    where?: ComentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentariosOrderByWithRelationInput | ComentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comentarios
    **/
    _count?: true | ComentariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentariosMaxAggregateInputType
  }

  export type GetComentariosAggregateType<T extends ComentariosAggregateArgs> = {
        [P in keyof T & keyof AggregateComentarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentarios[P]>
      : GetScalarType<T[P], AggregateComentarios[P]>
  }




  export type ComentariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentariosWhereInput
    orderBy?: ComentariosOrderByWithAggregationInput | ComentariosOrderByWithAggregationInput[]
    by: ComentariosScalarFieldEnum[] | ComentariosScalarFieldEnum
    having?: ComentariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentariosCountAggregateInputType | true
    _min?: ComentariosMinAggregateInputType
    _max?: ComentariosMaxAggregateInputType
  }

  export type ComentariosGroupByOutputType = {
    id: string
    postId: string
    autorId: string
    conteudo: string
    createdAt: Date
    updatedAt: Date
    _count: ComentariosCountAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  type GetComentariosGroupByPayload<T extends ComentariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
            : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
        }
      >
    >


  export type ComentariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    autorId?: boolean
    conteudo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    autor?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarios"]>

  export type ComentariosSelectScalar = {
    id?: boolean
    postId?: boolean
    autorId?: boolean
    conteudo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComentariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    autor?: boolean | UsuariosDefaultArgs<ExtArgs>
  }


  export type $ComentariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comentarios"
    objects: {
      post: Prisma.$PublicacoesPayload<ExtArgs>
      autor: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      autorId: string
      conteudo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comentarios"]>
    composites: {}
  }


  type ComentariosGetPayload<S extends boolean | null | undefined | ComentariosDefaultArgs> = $Result.GetResult<Prisma.$ComentariosPayload, S>

  type ComentariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComentariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentariosCountAggregateInputType | true
    }

  export interface ComentariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comentarios'], meta: { name: 'Comentarios' } }
    /**
     * Find zero or one Comentarios that matches the filter.
     * @param {ComentariosFindUniqueArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComentariosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ComentariosFindUniqueArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comentarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ComentariosFindUniqueOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ComentariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosFindFirstArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComentariosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentariosFindFirstArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comentarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosFindFirstOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ComentariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentarios.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentariosWithIdOnly = await prisma.comentarios.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ComentariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comentarios.
     * @param {ComentariosCreateArgs} args - Arguments to create a Comentarios.
     * @example
     * // Create one Comentarios
     * const Comentarios = await prisma.comentarios.create({
     *   data: {
     *     // ... data to create a Comentarios
     *   }
     * })
     * 
    **/
    create<T extends ComentariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ComentariosCreateArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comentarios.
     *     @param {ComentariosCreateManyArgs} args - Arguments to create many Comentarios.
     *     @example
     *     // Create many Comentarios
     *     const comentarios = await prisma.comentarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComentariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comentarios.
     * @param {ComentariosDeleteArgs} args - Arguments to delete one Comentarios.
     * @example
     * // Delete one Comentarios
     * const Comentarios = await prisma.comentarios.delete({
     *   where: {
     *     // ... filter to delete one Comentarios
     *   }
     * })
     * 
    **/
    delete<T extends ComentariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ComentariosDeleteArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comentarios.
     * @param {ComentariosUpdateArgs} args - Arguments to update one Comentarios.
     * @example
     * // Update one Comentarios
     * const comentarios = await prisma.comentarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComentariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ComentariosUpdateArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comentarios.
     * @param {ComentariosDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComentariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComentariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentarios = await prisma.comentarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComentariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ComentariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentarios.
     * @param {ComentariosUpsertArgs} args - Arguments to update or create a Comentarios.
     * @example
     * // Update or create a Comentarios
     * const comentarios = await prisma.comentarios.upsert({
     *   create: {
     *     // ... data to create a Comentarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentarios we want to update
     *   }
     * })
    **/
    upsert<T extends ComentariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ComentariosUpsertArgs<ExtArgs>>
    ): Prisma__ComentariosClient<$Result.GetResult<Prisma.$ComentariosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentarios.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends ComentariosCountArgs>(
      args?: Subset<T, ComentariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentariosAggregateArgs>(args: Subset<T, ComentariosAggregateArgs>): Prisma.PrismaPromise<GetComentariosAggregateType<T>>

    /**
     * Group by Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentariosGroupByArgs['orderBy'] }
        : { orderBy?: ComentariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comentarios model
   */
  readonly fields: ComentariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comentarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComentariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    post<T extends PublicacoesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicacoesDefaultArgs<ExtArgs>>): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    autor<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comentarios model
   */ 
  interface ComentariosFieldRefs {
    readonly id: FieldRef<"Comentarios", 'String'>
    readonly postId: FieldRef<"Comentarios", 'String'>
    readonly autorId: FieldRef<"Comentarios", 'String'>
    readonly conteudo: FieldRef<"Comentarios", 'String'>
    readonly createdAt: FieldRef<"Comentarios", 'DateTime'>
    readonly updatedAt: FieldRef<"Comentarios", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Comentarios findUnique
   */
  export type ComentariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where: ComentariosWhereUniqueInput
  }


  /**
   * Comentarios findUniqueOrThrow
   */
  export type ComentariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where: ComentariosWhereUniqueInput
  }


  /**
   * Comentarios findFirst
   */
  export type ComentariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentariosOrderByWithRelationInput | ComentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }


  /**
   * Comentarios findFirstOrThrow
   */
  export type ComentariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentariosOrderByWithRelationInput | ComentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }


  /**
   * Comentarios findMany
   */
  export type ComentariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentariosOrderByWithRelationInput | ComentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comentarios.
     */
    cursor?: ComentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }


  /**
   * Comentarios create
   */
  export type ComentariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Comentarios.
     */
    data: XOR<ComentariosCreateInput, ComentariosUncheckedCreateInput>
  }


  /**
   * Comentarios createMany
   */
  export type ComentariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comentarios.
     */
    data: ComentariosCreateManyInput | ComentariosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comentarios update
   */
  export type ComentariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Comentarios.
     */
    data: XOR<ComentariosUpdateInput, ComentariosUncheckedUpdateInput>
    /**
     * Choose, which Comentarios to update.
     */
    where: ComentariosWhereUniqueInput
  }


  /**
   * Comentarios updateMany
   */
  export type ComentariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comentarios.
     */
    data: XOR<ComentariosUpdateManyMutationInput, ComentariosUncheckedUpdateManyInput>
    /**
     * Filter which Comentarios to update
     */
    where?: ComentariosWhereInput
  }


  /**
   * Comentarios upsert
   */
  export type ComentariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Comentarios to update in case it exists.
     */
    where: ComentariosWhereUniqueInput
    /**
     * In case the Comentarios found by the `where` argument doesn't exist, create a new Comentarios with this data.
     */
    create: XOR<ComentariosCreateInput, ComentariosUncheckedCreateInput>
    /**
     * In case the Comentarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentariosUpdateInput, ComentariosUncheckedUpdateInput>
  }


  /**
   * Comentarios delete
   */
  export type ComentariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
    /**
     * Filter which Comentarios to delete.
     */
    where: ComentariosWhereUniqueInput
  }


  /**
   * Comentarios deleteMany
   */
  export type ComentariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentarios to delete
     */
    where?: ComentariosWhereInput
  }


  /**
   * Comentarios without action
   */
  export type ComentariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentarios
     */
    select?: ComentariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComentariosInclude<ExtArgs> | null
  }



  /**
   * Model Reacoes
   */

  export type AggregateReacoes = {
    _count: ReacoesCountAggregateOutputType | null
    _min: ReacoesMinAggregateOutputType | null
    _max: ReacoesMaxAggregateOutputType | null
  }

  export type ReacoesMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ReacoesMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ReacoesCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type ReacoesMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type ReacoesMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type ReacoesCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type ReacoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reacoes to aggregate.
     */
    where?: ReacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacoes to fetch.
     */
    orderBy?: ReacoesOrderByWithRelationInput | ReacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reacoes
    **/
    _count?: true | ReacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReacoesMaxAggregateInputType
  }

  export type GetReacoesAggregateType<T extends ReacoesAggregateArgs> = {
        [P in keyof T & keyof AggregateReacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReacoes[P]>
      : GetScalarType<T[P], AggregateReacoes[P]>
  }




  export type ReacoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReacoesWhereInput
    orderBy?: ReacoesOrderByWithAggregationInput | ReacoesOrderByWithAggregationInput[]
    by: ReacoesScalarFieldEnum[] | ReacoesScalarFieldEnum
    having?: ReacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReacoesCountAggregateInputType | true
    _min?: ReacoesMinAggregateInputType
    _max?: ReacoesMaxAggregateInputType
  }

  export type ReacoesGroupByOutputType = {
    id: string
    postId: string
    userId: string
    type: string
    createdAt: Date
    _count: ReacoesCountAggregateOutputType | null
    _min: ReacoesMinAggregateOutputType | null
    _max: ReacoesMaxAggregateOutputType | null
  }

  type GetReacoesGroupByPayload<T extends ReacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReacoesGroupByOutputType[P]>
            : GetScalarType<T[P], ReacoesGroupByOutputType[P]>
        }
      >
    >


  export type ReacoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reacoes"]>

  export type ReacoesSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type ReacoesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
  }


  export type $ReacoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reacoes"
    objects: {
      post: Prisma.$PublicacoesPayload<ExtArgs>
      user: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["reacoes"]>
    composites: {}
  }


  type ReacoesGetPayload<S extends boolean | null | undefined | ReacoesDefaultArgs> = $Result.GetResult<Prisma.$ReacoesPayload, S>

  type ReacoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReacoesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReacoesCountAggregateInputType | true
    }

  export interface ReacoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reacoes'], meta: { name: 'Reacoes' } }
    /**
     * Find zero or one Reacoes that matches the filter.
     * @param {ReacoesFindUniqueArgs} args - Arguments to find a Reacoes
     * @example
     * // Get one Reacoes
     * const reacoes = await prisma.reacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReacoesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReacoesFindUniqueArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Reacoes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReacoesFindUniqueOrThrowArgs} args - Arguments to find a Reacoes
     * @example
     * // Get one Reacoes
     * const reacoes = await prisma.reacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReacoesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReacoesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Reacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReacoesFindFirstArgs} args - Arguments to find a Reacoes
     * @example
     * // Get one Reacoes
     * const reacoes = await prisma.reacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReacoesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReacoesFindFirstArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Reacoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReacoesFindFirstOrThrowArgs} args - Arguments to find a Reacoes
     * @example
     * // Get one Reacoes
     * const reacoes = await prisma.reacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReacoesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReacoesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReacoesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reacoes
     * const reacoes = await prisma.reacoes.findMany()
     * 
     * // Get first 10 Reacoes
     * const reacoes = await prisma.reacoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reacoesWithIdOnly = await prisma.reacoes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReacoesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReacoesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Reacoes.
     * @param {ReacoesCreateArgs} args - Arguments to create a Reacoes.
     * @example
     * // Create one Reacoes
     * const Reacoes = await prisma.reacoes.create({
     *   data: {
     *     // ... data to create a Reacoes
     *   }
     * })
     * 
    **/
    create<T extends ReacoesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReacoesCreateArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reacoes.
     *     @param {ReacoesCreateManyArgs} args - Arguments to create many Reacoes.
     *     @example
     *     // Create many Reacoes
     *     const reacoes = await prisma.reacoes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReacoesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReacoesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reacoes.
     * @param {ReacoesDeleteArgs} args - Arguments to delete one Reacoes.
     * @example
     * // Delete one Reacoes
     * const Reacoes = await prisma.reacoes.delete({
     *   where: {
     *     // ... filter to delete one Reacoes
     *   }
     * })
     * 
    **/
    delete<T extends ReacoesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReacoesDeleteArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Reacoes.
     * @param {ReacoesUpdateArgs} args - Arguments to update one Reacoes.
     * @example
     * // Update one Reacoes
     * const reacoes = await prisma.reacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReacoesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReacoesUpdateArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reacoes.
     * @param {ReacoesDeleteManyArgs} args - Arguments to filter Reacoes to delete.
     * @example
     * // Delete a few Reacoes
     * const { count } = await prisma.reacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReacoesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReacoesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reacoes
     * const reacoes = await prisma.reacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReacoesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReacoesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reacoes.
     * @param {ReacoesUpsertArgs} args - Arguments to update or create a Reacoes.
     * @example
     * // Update or create a Reacoes
     * const reacoes = await prisma.reacoes.upsert({
     *   create: {
     *     // ... data to create a Reacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reacoes we want to update
     *   }
     * })
    **/
    upsert<T extends ReacoesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReacoesUpsertArgs<ExtArgs>>
    ): Prisma__ReacoesClient<$Result.GetResult<Prisma.$ReacoesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReacoesCountArgs} args - Arguments to filter Reacoes to count.
     * @example
     * // Count the number of Reacoes
     * const count = await prisma.reacoes.count({
     *   where: {
     *     // ... the filter for the Reacoes we want to count
     *   }
     * })
    **/
    count<T extends ReacoesCountArgs>(
      args?: Subset<T, ReacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReacoesAggregateArgs>(args: Subset<T, ReacoesAggregateArgs>): Prisma.PrismaPromise<GetReacoesAggregateType<T>>

    /**
     * Group by Reacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReacoesGroupByArgs['orderBy'] }
        : { orderBy?: ReacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reacoes model
   */
  readonly fields: ReacoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReacoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    post<T extends PublicacoesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicacoesDefaultArgs<ExtArgs>>): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Reacoes model
   */ 
  interface ReacoesFieldRefs {
    readonly id: FieldRef<"Reacoes", 'String'>
    readonly postId: FieldRef<"Reacoes", 'String'>
    readonly userId: FieldRef<"Reacoes", 'String'>
    readonly type: FieldRef<"Reacoes", 'String'>
    readonly createdAt: FieldRef<"Reacoes", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Reacoes findUnique
   */
  export type ReacoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * Filter, which Reacoes to fetch.
     */
    where: ReacoesWhereUniqueInput
  }


  /**
   * Reacoes findUniqueOrThrow
   */
  export type ReacoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * Filter, which Reacoes to fetch.
     */
    where: ReacoesWhereUniqueInput
  }


  /**
   * Reacoes findFirst
   */
  export type ReacoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * Filter, which Reacoes to fetch.
     */
    where?: ReacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacoes to fetch.
     */
    orderBy?: ReacoesOrderByWithRelationInput | ReacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reacoes.
     */
    cursor?: ReacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reacoes.
     */
    distinct?: ReacoesScalarFieldEnum | ReacoesScalarFieldEnum[]
  }


  /**
   * Reacoes findFirstOrThrow
   */
  export type ReacoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * Filter, which Reacoes to fetch.
     */
    where?: ReacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacoes to fetch.
     */
    orderBy?: ReacoesOrderByWithRelationInput | ReacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reacoes.
     */
    cursor?: ReacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reacoes.
     */
    distinct?: ReacoesScalarFieldEnum | ReacoesScalarFieldEnum[]
  }


  /**
   * Reacoes findMany
   */
  export type ReacoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * Filter, which Reacoes to fetch.
     */
    where?: ReacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacoes to fetch.
     */
    orderBy?: ReacoesOrderByWithRelationInput | ReacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reacoes.
     */
    cursor?: ReacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacoes.
     */
    skip?: number
    distinct?: ReacoesScalarFieldEnum | ReacoesScalarFieldEnum[]
  }


  /**
   * Reacoes create
   */
  export type ReacoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * The data needed to create a Reacoes.
     */
    data: XOR<ReacoesCreateInput, ReacoesUncheckedCreateInput>
  }


  /**
   * Reacoes createMany
   */
  export type ReacoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reacoes.
     */
    data: ReacoesCreateManyInput | ReacoesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Reacoes update
   */
  export type ReacoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * The data needed to update a Reacoes.
     */
    data: XOR<ReacoesUpdateInput, ReacoesUncheckedUpdateInput>
    /**
     * Choose, which Reacoes to update.
     */
    where: ReacoesWhereUniqueInput
  }


  /**
   * Reacoes updateMany
   */
  export type ReacoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reacoes.
     */
    data: XOR<ReacoesUpdateManyMutationInput, ReacoesUncheckedUpdateManyInput>
    /**
     * Filter which Reacoes to update
     */
    where?: ReacoesWhereInput
  }


  /**
   * Reacoes upsert
   */
  export type ReacoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * The filter to search for the Reacoes to update in case it exists.
     */
    where: ReacoesWhereUniqueInput
    /**
     * In case the Reacoes found by the `where` argument doesn't exist, create a new Reacoes with this data.
     */
    create: XOR<ReacoesCreateInput, ReacoesUncheckedCreateInput>
    /**
     * In case the Reacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReacoesUpdateInput, ReacoesUncheckedUpdateInput>
  }


  /**
   * Reacoes delete
   */
  export type ReacoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
    /**
     * Filter which Reacoes to delete.
     */
    where: ReacoesWhereUniqueInput
  }


  /**
   * Reacoes deleteMany
   */
  export type ReacoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reacoes to delete
     */
    where?: ReacoesWhereInput
  }


  /**
   * Reacoes without action
   */
  export type ReacoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reacoes
     */
    select?: ReacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReacoesInclude<ExtArgs> | null
  }



  /**
   * Model Notificacoes
   */

  export type AggregateNotificacoes = {
    _count: NotificacoesCountAggregateOutputType | null
    _min: NotificacoesMinAggregateOutputType | null
    _max: NotificacoesMaxAggregateOutputType | null
  }

  export type NotificacoesMinAggregateOutputType = {
    id: string | null
    data: Date | null
    usuarioID: string | null
    destinatarioID: string | null
    consultaID: string | null
    postID: string | null
    tipo: string | null
    visto: string | null
  }

  export type NotificacoesMaxAggregateOutputType = {
    id: string | null
    data: Date | null
    usuarioID: string | null
    destinatarioID: string | null
    consultaID: string | null
    postID: string | null
    tipo: string | null
    visto: string | null
  }

  export type NotificacoesCountAggregateOutputType = {
    id: number
    data: number
    usuarioID: number
    destinatarioID: number
    consultaID: number
    postID: number
    tipo: number
    visto: number
    _all: number
  }


  export type NotificacoesMinAggregateInputType = {
    id?: true
    data?: true
    usuarioID?: true
    destinatarioID?: true
    consultaID?: true
    postID?: true
    tipo?: true
    visto?: true
  }

  export type NotificacoesMaxAggregateInputType = {
    id?: true
    data?: true
    usuarioID?: true
    destinatarioID?: true
    consultaID?: true
    postID?: true
    tipo?: true
    visto?: true
  }

  export type NotificacoesCountAggregateInputType = {
    id?: true
    data?: true
    usuarioID?: true
    destinatarioID?: true
    consultaID?: true
    postID?: true
    tipo?: true
    visto?: true
    _all?: true
  }

  export type NotificacoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacoes to aggregate.
     */
    where?: NotificacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacoes to fetch.
     */
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacoes
    **/
    _count?: true | NotificacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacoesMaxAggregateInputType
  }

  export type GetNotificacoesAggregateType<T extends NotificacoesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacoes[P]>
      : GetScalarType<T[P], AggregateNotificacoes[P]>
  }




  export type NotificacoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacoesWhereInput
    orderBy?: NotificacoesOrderByWithAggregationInput | NotificacoesOrderByWithAggregationInput[]
    by: NotificacoesScalarFieldEnum[] | NotificacoesScalarFieldEnum
    having?: NotificacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacoesCountAggregateInputType | true
    _min?: NotificacoesMinAggregateInputType
    _max?: NotificacoesMaxAggregateInputType
  }

  export type NotificacoesGroupByOutputType = {
    id: string
    data: Date
    usuarioID: string
    destinatarioID: string
    consultaID: string
    postID: string
    tipo: string
    visto: string | null
    _count: NotificacoesCountAggregateOutputType | null
    _min: NotificacoesMinAggregateOutputType | null
    _max: NotificacoesMaxAggregateOutputType | null
  }

  type GetNotificacoesGroupByPayload<T extends NotificacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacoesGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacoesGroupByOutputType[P]>
        }
      >
    >


  export type NotificacoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data?: boolean
    usuarioID?: boolean
    destinatarioID?: boolean
    consultaID?: boolean
    postID?: boolean
    tipo?: boolean
    visto?: boolean
    usuarioNotificacao?: boolean | UsuariosDefaultArgs<ExtArgs>
    destinatarioNotificacao?: boolean | UsuariosDefaultArgs<ExtArgs>
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    consulta?: boolean | ConsultasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacoes"]>

  export type NotificacoesSelectScalar = {
    id?: boolean
    data?: boolean
    usuarioID?: boolean
    destinatarioID?: boolean
    consultaID?: boolean
    postID?: boolean
    tipo?: boolean
    visto?: boolean
  }

  export type NotificacoesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarioNotificacao?: boolean | UsuariosDefaultArgs<ExtArgs>
    destinatarioNotificacao?: boolean | UsuariosDefaultArgs<ExtArgs>
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    consulta?: boolean | ConsultasDefaultArgs<ExtArgs>
  }


  export type $NotificacoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacoes"
    objects: {
      usuarioNotificacao: Prisma.$UsuariosPayload<ExtArgs>
      destinatarioNotificacao: Prisma.$UsuariosPayload<ExtArgs>
      post: Prisma.$PublicacoesPayload<ExtArgs>
      consulta: Prisma.$ConsultasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      data: Date
      usuarioID: string
      destinatarioID: string
      consultaID: string
      postID: string
      tipo: string
      visto: string | null
    }, ExtArgs["result"]["notificacoes"]>
    composites: {}
  }


  type NotificacoesGetPayload<S extends boolean | null | undefined | NotificacoesDefaultArgs> = $Result.GetResult<Prisma.$NotificacoesPayload, S>

  type NotificacoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificacoesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificacoesCountAggregateInputType | true
    }

  export interface NotificacoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacoes'], meta: { name: 'Notificacoes' } }
    /**
     * Find zero or one Notificacoes that matches the filter.
     * @param {NotificacoesFindUniqueArgs} args - Arguments to find a Notificacoes
     * @example
     * // Get one Notificacoes
     * const notificacoes = await prisma.notificacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificacoesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificacoesFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notificacoes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificacoesFindUniqueOrThrowArgs} args - Arguments to find a Notificacoes
     * @example
     * // Get one Notificacoes
     * const notificacoes = await prisma.notificacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificacoesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificacoesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notificacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacoesFindFirstArgs} args - Arguments to find a Notificacoes
     * @example
     * // Get one Notificacoes
     * const notificacoes = await prisma.notificacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificacoesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificacoesFindFirstArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notificacoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacoesFindFirstOrThrowArgs} args - Arguments to find a Notificacoes
     * @example
     * // Get one Notificacoes
     * const notificacoes = await prisma.notificacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificacoesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificacoesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notificacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacoesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacoes
     * const notificacoes = await prisma.notificacoes.findMany()
     * 
     * // Get first 10 Notificacoes
     * const notificacoes = await prisma.notificacoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacoesWithIdOnly = await prisma.notificacoes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificacoesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificacoesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notificacoes.
     * @param {NotificacoesCreateArgs} args - Arguments to create a Notificacoes.
     * @example
     * // Create one Notificacoes
     * const Notificacoes = await prisma.notificacoes.create({
     *   data: {
     *     // ... data to create a Notificacoes
     *   }
     * })
     * 
    **/
    create<T extends NotificacoesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificacoesCreateArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notificacoes.
     *     @param {NotificacoesCreateManyArgs} args - Arguments to create many Notificacoes.
     *     @example
     *     // Create many Notificacoes
     *     const notificacoes = await prisma.notificacoes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificacoesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificacoesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notificacoes.
     * @param {NotificacoesDeleteArgs} args - Arguments to delete one Notificacoes.
     * @example
     * // Delete one Notificacoes
     * const Notificacoes = await prisma.notificacoes.delete({
     *   where: {
     *     // ... filter to delete one Notificacoes
     *   }
     * })
     * 
    **/
    delete<T extends NotificacoesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificacoesDeleteArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notificacoes.
     * @param {NotificacoesUpdateArgs} args - Arguments to update one Notificacoes.
     * @example
     * // Update one Notificacoes
     * const notificacoes = await prisma.notificacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificacoesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificacoesUpdateArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notificacoes.
     * @param {NotificacoesDeleteManyArgs} args - Arguments to filter Notificacoes to delete.
     * @example
     * // Delete a few Notificacoes
     * const { count } = await prisma.notificacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificacoesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificacoesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacoes
     * const notificacoes = await prisma.notificacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificacoesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificacoesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notificacoes.
     * @param {NotificacoesUpsertArgs} args - Arguments to update or create a Notificacoes.
     * @example
     * // Update or create a Notificacoes
     * const notificacoes = await prisma.notificacoes.upsert({
     *   create: {
     *     // ... data to create a Notificacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacoes we want to update
     *   }
     * })
    **/
    upsert<T extends NotificacoesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificacoesUpsertArgs<ExtArgs>>
    ): Prisma__NotificacoesClient<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notificacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacoesCountArgs} args - Arguments to filter Notificacoes to count.
     * @example
     * // Count the number of Notificacoes
     * const count = await prisma.notificacoes.count({
     *   where: {
     *     // ... the filter for the Notificacoes we want to count
     *   }
     * })
    **/
    count<T extends NotificacoesCountArgs>(
      args?: Subset<T, NotificacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacoesAggregateArgs>(args: Subset<T, NotificacoesAggregateArgs>): Prisma.PrismaPromise<GetNotificacoesAggregateType<T>>

    /**
     * Group by Notificacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacoesGroupByArgs['orderBy'] }
        : { orderBy?: NotificacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacoes model
   */
  readonly fields: NotificacoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuarioNotificacao<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    destinatarioNotificacao<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    post<T extends PublicacoesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicacoesDefaultArgs<ExtArgs>>): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    consulta<T extends ConsultasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultasDefaultArgs<ExtArgs>>): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notificacoes model
   */ 
  interface NotificacoesFieldRefs {
    readonly id: FieldRef<"Notificacoes", 'String'>
    readonly data: FieldRef<"Notificacoes", 'DateTime'>
    readonly usuarioID: FieldRef<"Notificacoes", 'String'>
    readonly destinatarioID: FieldRef<"Notificacoes", 'String'>
    readonly consultaID: FieldRef<"Notificacoes", 'String'>
    readonly postID: FieldRef<"Notificacoes", 'String'>
    readonly tipo: FieldRef<"Notificacoes", 'String'>
    readonly visto: FieldRef<"Notificacoes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Notificacoes findUnique
   */
  export type NotificacoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * Filter, which Notificacoes to fetch.
     */
    where: NotificacoesWhereUniqueInput
  }


  /**
   * Notificacoes findUniqueOrThrow
   */
  export type NotificacoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * Filter, which Notificacoes to fetch.
     */
    where: NotificacoesWhereUniqueInput
  }


  /**
   * Notificacoes findFirst
   */
  export type NotificacoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * Filter, which Notificacoes to fetch.
     */
    where?: NotificacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacoes to fetch.
     */
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacoes.
     */
    cursor?: NotificacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacoes.
     */
    distinct?: NotificacoesScalarFieldEnum | NotificacoesScalarFieldEnum[]
  }


  /**
   * Notificacoes findFirstOrThrow
   */
  export type NotificacoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * Filter, which Notificacoes to fetch.
     */
    where?: NotificacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacoes to fetch.
     */
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacoes.
     */
    cursor?: NotificacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacoes.
     */
    distinct?: NotificacoesScalarFieldEnum | NotificacoesScalarFieldEnum[]
  }


  /**
   * Notificacoes findMany
   */
  export type NotificacoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * Filter, which Notificacoes to fetch.
     */
    where?: NotificacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacoes to fetch.
     */
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacoes.
     */
    cursor?: NotificacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacoes.
     */
    skip?: number
    distinct?: NotificacoesScalarFieldEnum | NotificacoesScalarFieldEnum[]
  }


  /**
   * Notificacoes create
   */
  export type NotificacoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacoes.
     */
    data: XOR<NotificacoesCreateInput, NotificacoesUncheckedCreateInput>
  }


  /**
   * Notificacoes createMany
   */
  export type NotificacoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacoes.
     */
    data: NotificacoesCreateManyInput | NotificacoesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notificacoes update
   */
  export type NotificacoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacoes.
     */
    data: XOR<NotificacoesUpdateInput, NotificacoesUncheckedUpdateInput>
    /**
     * Choose, which Notificacoes to update.
     */
    where: NotificacoesWhereUniqueInput
  }


  /**
   * Notificacoes updateMany
   */
  export type NotificacoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacoes.
     */
    data: XOR<NotificacoesUpdateManyMutationInput, NotificacoesUncheckedUpdateManyInput>
    /**
     * Filter which Notificacoes to update
     */
    where?: NotificacoesWhereInput
  }


  /**
   * Notificacoes upsert
   */
  export type NotificacoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacoes to update in case it exists.
     */
    where: NotificacoesWhereUniqueInput
    /**
     * In case the Notificacoes found by the `where` argument doesn't exist, create a new Notificacoes with this data.
     */
    create: XOR<NotificacoesCreateInput, NotificacoesUncheckedCreateInput>
    /**
     * In case the Notificacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacoesUpdateInput, NotificacoesUncheckedUpdateInput>
  }


  /**
   * Notificacoes delete
   */
  export type NotificacoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    /**
     * Filter which Notificacoes to delete.
     */
    where: NotificacoesWhereUniqueInput
  }


  /**
   * Notificacoes deleteMany
   */
  export type NotificacoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacoes to delete
     */
    where?: NotificacoesWhereInput
  }


  /**
   * Notificacoes without action
   */
  export type NotificacoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
  }



  /**
   * Model Seguidores
   */

  export type AggregateSeguidores = {
    _count: SeguidoresCountAggregateOutputType | null
    _min: SeguidoresMinAggregateOutputType | null
    _max: SeguidoresMaxAggregateOutputType | null
  }

  export type SeguidoresMinAggregateOutputType = {
    id: string | null
    seguidorID: string | null
    entidadeID: string | null
  }

  export type SeguidoresMaxAggregateOutputType = {
    id: string | null
    seguidorID: string | null
    entidadeID: string | null
  }

  export type SeguidoresCountAggregateOutputType = {
    id: number
    seguidorID: number
    entidadeID: number
    _all: number
  }


  export type SeguidoresMinAggregateInputType = {
    id?: true
    seguidorID?: true
    entidadeID?: true
  }

  export type SeguidoresMaxAggregateInputType = {
    id?: true
    seguidorID?: true
    entidadeID?: true
  }

  export type SeguidoresCountAggregateInputType = {
    id?: true
    seguidorID?: true
    entidadeID?: true
    _all?: true
  }

  export type SeguidoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seguidores to aggregate.
     */
    where?: SeguidoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seguidores to fetch.
     */
    orderBy?: SeguidoresOrderByWithRelationInput | SeguidoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeguidoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seguidores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seguidores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seguidores
    **/
    _count?: true | SeguidoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeguidoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeguidoresMaxAggregateInputType
  }

  export type GetSeguidoresAggregateType<T extends SeguidoresAggregateArgs> = {
        [P in keyof T & keyof AggregateSeguidores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeguidores[P]>
      : GetScalarType<T[P], AggregateSeguidores[P]>
  }




  export type SeguidoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeguidoresWhereInput
    orderBy?: SeguidoresOrderByWithAggregationInput | SeguidoresOrderByWithAggregationInput[]
    by: SeguidoresScalarFieldEnum[] | SeguidoresScalarFieldEnum
    having?: SeguidoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeguidoresCountAggregateInputType | true
    _min?: SeguidoresMinAggregateInputType
    _max?: SeguidoresMaxAggregateInputType
  }

  export type SeguidoresGroupByOutputType = {
    id: string
    seguidorID: string
    entidadeID: string
    _count: SeguidoresCountAggregateOutputType | null
    _min: SeguidoresMinAggregateOutputType | null
    _max: SeguidoresMaxAggregateOutputType | null
  }

  type GetSeguidoresGroupByPayload<T extends SeguidoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeguidoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeguidoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeguidoresGroupByOutputType[P]>
            : GetScalarType<T[P], SeguidoresGroupByOutputType[P]>
        }
      >
    >


  export type SeguidoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seguidorID?: boolean
    entidadeID?: boolean
    seguidor?: boolean | UsuariosDefaultArgs<ExtArgs>
    entidade?: boolean | EntidadesSistemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seguidores"]>

  export type SeguidoresSelectScalar = {
    id?: boolean
    seguidorID?: boolean
    entidadeID?: boolean
  }

  export type SeguidoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seguidor?: boolean | UsuariosDefaultArgs<ExtArgs>
    entidade?: boolean | EntidadesSistemaDefaultArgs<ExtArgs>
  }


  export type $SeguidoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seguidores"
    objects: {
      seguidor: Prisma.$UsuariosPayload<ExtArgs>
      entidade: Prisma.$EntidadesSistemaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seguidorID: string
      entidadeID: string
    }, ExtArgs["result"]["seguidores"]>
    composites: {}
  }


  type SeguidoresGetPayload<S extends boolean | null | undefined | SeguidoresDefaultArgs> = $Result.GetResult<Prisma.$SeguidoresPayload, S>

  type SeguidoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeguidoresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeguidoresCountAggregateInputType | true
    }

  export interface SeguidoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seguidores'], meta: { name: 'Seguidores' } }
    /**
     * Find zero or one Seguidores that matches the filter.
     * @param {SeguidoresFindUniqueArgs} args - Arguments to find a Seguidores
     * @example
     * // Get one Seguidores
     * const seguidores = await prisma.seguidores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SeguidoresFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SeguidoresFindUniqueArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Seguidores that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SeguidoresFindUniqueOrThrowArgs} args - Arguments to find a Seguidores
     * @example
     * // Get one Seguidores
     * const seguidores = await prisma.seguidores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SeguidoresFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SeguidoresFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Seguidores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeguidoresFindFirstArgs} args - Arguments to find a Seguidores
     * @example
     * // Get one Seguidores
     * const seguidores = await prisma.seguidores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SeguidoresFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SeguidoresFindFirstArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Seguidores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeguidoresFindFirstOrThrowArgs} args - Arguments to find a Seguidores
     * @example
     * // Get one Seguidores
     * const seguidores = await prisma.seguidores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SeguidoresFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SeguidoresFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Seguidores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeguidoresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seguidores
     * const seguidores = await prisma.seguidores.findMany()
     * 
     * // Get first 10 Seguidores
     * const seguidores = await prisma.seguidores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seguidoresWithIdOnly = await prisma.seguidores.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SeguidoresFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SeguidoresFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Seguidores.
     * @param {SeguidoresCreateArgs} args - Arguments to create a Seguidores.
     * @example
     * // Create one Seguidores
     * const Seguidores = await prisma.seguidores.create({
     *   data: {
     *     // ... data to create a Seguidores
     *   }
     * })
     * 
    **/
    create<T extends SeguidoresCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SeguidoresCreateArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Seguidores.
     *     @param {SeguidoresCreateManyArgs} args - Arguments to create many Seguidores.
     *     @example
     *     // Create many Seguidores
     *     const seguidores = await prisma.seguidores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SeguidoresCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SeguidoresCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seguidores.
     * @param {SeguidoresDeleteArgs} args - Arguments to delete one Seguidores.
     * @example
     * // Delete one Seguidores
     * const Seguidores = await prisma.seguidores.delete({
     *   where: {
     *     // ... filter to delete one Seguidores
     *   }
     * })
     * 
    **/
    delete<T extends SeguidoresDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SeguidoresDeleteArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Seguidores.
     * @param {SeguidoresUpdateArgs} args - Arguments to update one Seguidores.
     * @example
     * // Update one Seguidores
     * const seguidores = await prisma.seguidores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SeguidoresUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SeguidoresUpdateArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Seguidores.
     * @param {SeguidoresDeleteManyArgs} args - Arguments to filter Seguidores to delete.
     * @example
     * // Delete a few Seguidores
     * const { count } = await prisma.seguidores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SeguidoresDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SeguidoresDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seguidores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeguidoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seguidores
     * const seguidores = await prisma.seguidores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SeguidoresUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SeguidoresUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seguidores.
     * @param {SeguidoresUpsertArgs} args - Arguments to update or create a Seguidores.
     * @example
     * // Update or create a Seguidores
     * const seguidores = await prisma.seguidores.upsert({
     *   create: {
     *     // ... data to create a Seguidores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seguidores we want to update
     *   }
     * })
    **/
    upsert<T extends SeguidoresUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SeguidoresUpsertArgs<ExtArgs>>
    ): Prisma__SeguidoresClient<$Result.GetResult<Prisma.$SeguidoresPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Seguidores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeguidoresCountArgs} args - Arguments to filter Seguidores to count.
     * @example
     * // Count the number of Seguidores
     * const count = await prisma.seguidores.count({
     *   where: {
     *     // ... the filter for the Seguidores we want to count
     *   }
     * })
    **/
    count<T extends SeguidoresCountArgs>(
      args?: Subset<T, SeguidoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeguidoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seguidores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeguidoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeguidoresAggregateArgs>(args: Subset<T, SeguidoresAggregateArgs>): Prisma.PrismaPromise<GetSeguidoresAggregateType<T>>

    /**
     * Group by Seguidores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeguidoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeguidoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeguidoresGroupByArgs['orderBy'] }
        : { orderBy?: SeguidoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeguidoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeguidoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seguidores model
   */
  readonly fields: SeguidoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seguidores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeguidoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    seguidor<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entidade<T extends EntidadesSistemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntidadesSistemaDefaultArgs<ExtArgs>>): Prisma__EntidadesSistemaClient<$Result.GetResult<Prisma.$EntidadesSistemaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Seguidores model
   */ 
  interface SeguidoresFieldRefs {
    readonly id: FieldRef<"Seguidores", 'String'>
    readonly seguidorID: FieldRef<"Seguidores", 'String'>
    readonly entidadeID: FieldRef<"Seguidores", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Seguidores findUnique
   */
  export type SeguidoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * Filter, which Seguidores to fetch.
     */
    where: SeguidoresWhereUniqueInput
  }


  /**
   * Seguidores findUniqueOrThrow
   */
  export type SeguidoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * Filter, which Seguidores to fetch.
     */
    where: SeguidoresWhereUniqueInput
  }


  /**
   * Seguidores findFirst
   */
  export type SeguidoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * Filter, which Seguidores to fetch.
     */
    where?: SeguidoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seguidores to fetch.
     */
    orderBy?: SeguidoresOrderByWithRelationInput | SeguidoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seguidores.
     */
    cursor?: SeguidoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seguidores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seguidores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seguidores.
     */
    distinct?: SeguidoresScalarFieldEnum | SeguidoresScalarFieldEnum[]
  }


  /**
   * Seguidores findFirstOrThrow
   */
  export type SeguidoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * Filter, which Seguidores to fetch.
     */
    where?: SeguidoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seguidores to fetch.
     */
    orderBy?: SeguidoresOrderByWithRelationInput | SeguidoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seguidores.
     */
    cursor?: SeguidoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seguidores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seguidores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seguidores.
     */
    distinct?: SeguidoresScalarFieldEnum | SeguidoresScalarFieldEnum[]
  }


  /**
   * Seguidores findMany
   */
  export type SeguidoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * Filter, which Seguidores to fetch.
     */
    where?: SeguidoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seguidores to fetch.
     */
    orderBy?: SeguidoresOrderByWithRelationInput | SeguidoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seguidores.
     */
    cursor?: SeguidoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seguidores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seguidores.
     */
    skip?: number
    distinct?: SeguidoresScalarFieldEnum | SeguidoresScalarFieldEnum[]
  }


  /**
   * Seguidores create
   */
  export type SeguidoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * The data needed to create a Seguidores.
     */
    data: XOR<SeguidoresCreateInput, SeguidoresUncheckedCreateInput>
  }


  /**
   * Seguidores createMany
   */
  export type SeguidoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seguidores.
     */
    data: SeguidoresCreateManyInput | SeguidoresCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Seguidores update
   */
  export type SeguidoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * The data needed to update a Seguidores.
     */
    data: XOR<SeguidoresUpdateInput, SeguidoresUncheckedUpdateInput>
    /**
     * Choose, which Seguidores to update.
     */
    where: SeguidoresWhereUniqueInput
  }


  /**
   * Seguidores updateMany
   */
  export type SeguidoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seguidores.
     */
    data: XOR<SeguidoresUpdateManyMutationInput, SeguidoresUncheckedUpdateManyInput>
    /**
     * Filter which Seguidores to update
     */
    where?: SeguidoresWhereInput
  }


  /**
   * Seguidores upsert
   */
  export type SeguidoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * The filter to search for the Seguidores to update in case it exists.
     */
    where: SeguidoresWhereUniqueInput
    /**
     * In case the Seguidores found by the `where` argument doesn't exist, create a new Seguidores with this data.
     */
    create: XOR<SeguidoresCreateInput, SeguidoresUncheckedCreateInput>
    /**
     * In case the Seguidores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeguidoresUpdateInput, SeguidoresUncheckedUpdateInput>
  }


  /**
   * Seguidores delete
   */
  export type SeguidoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
    /**
     * Filter which Seguidores to delete.
     */
    where: SeguidoresWhereUniqueInput
  }


  /**
   * Seguidores deleteMany
   */
  export type SeguidoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seguidores to delete
     */
    where?: SeguidoresWhereInput
  }


  /**
   * Seguidores without action
   */
  export type SeguidoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seguidores
     */
    select?: SeguidoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeguidoresInclude<ExtArgs> | null
  }



  /**
   * Model Mensagens
   */

  export type AggregateMensagens = {
    _count: MensagensCountAggregateOutputType | null
    _min: MensagensMinAggregateOutputType | null
    _max: MensagensMaxAggregateOutputType | null
  }

  export type MensagensMinAggregateOutputType = {
    id: string | null
    conteudo: string | null
    foto: string | null
    video: string | null
    arquivo: string | null
    data: Date | null
    emissorID: string | null
    receptorID: string | null
    visto: boolean | null
  }

  export type MensagensMaxAggregateOutputType = {
    id: string | null
    conteudo: string | null
    foto: string | null
    video: string | null
    arquivo: string | null
    data: Date | null
    emissorID: string | null
    receptorID: string | null
    visto: boolean | null
  }

  export type MensagensCountAggregateOutputType = {
    id: number
    conteudo: number
    foto: number
    video: number
    arquivo: number
    data: number
    emissorID: number
    receptorID: number
    visto: number
    _all: number
  }


  export type MensagensMinAggregateInputType = {
    id?: true
    conteudo?: true
    foto?: true
    video?: true
    arquivo?: true
    data?: true
    emissorID?: true
    receptorID?: true
    visto?: true
  }

  export type MensagensMaxAggregateInputType = {
    id?: true
    conteudo?: true
    foto?: true
    video?: true
    arquivo?: true
    data?: true
    emissorID?: true
    receptorID?: true
    visto?: true
  }

  export type MensagensCountAggregateInputType = {
    id?: true
    conteudo?: true
    foto?: true
    video?: true
    arquivo?: true
    data?: true
    emissorID?: true
    receptorID?: true
    visto?: true
    _all?: true
  }

  export type MensagensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensagens to aggregate.
     */
    where?: MensagensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagens to fetch.
     */
    orderBy?: MensagensOrderByWithRelationInput | MensagensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MensagensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mensagens
    **/
    _count?: true | MensagensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MensagensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MensagensMaxAggregateInputType
  }

  export type GetMensagensAggregateType<T extends MensagensAggregateArgs> = {
        [P in keyof T & keyof AggregateMensagens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensagens[P]>
      : GetScalarType<T[P], AggregateMensagens[P]>
  }




  export type MensagensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensagensWhereInput
    orderBy?: MensagensOrderByWithAggregationInput | MensagensOrderByWithAggregationInput[]
    by: MensagensScalarFieldEnum[] | MensagensScalarFieldEnum
    having?: MensagensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MensagensCountAggregateInputType | true
    _min?: MensagensMinAggregateInputType
    _max?: MensagensMaxAggregateInputType
  }

  export type MensagensGroupByOutputType = {
    id: string
    conteudo: string | null
    foto: string | null
    video: string | null
    arquivo: string | null
    data: Date
    emissorID: string
    receptorID: string
    visto: boolean
    _count: MensagensCountAggregateOutputType | null
    _min: MensagensMinAggregateOutputType | null
    _max: MensagensMaxAggregateOutputType | null
  }

  type GetMensagensGroupByPayload<T extends MensagensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MensagensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MensagensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MensagensGroupByOutputType[P]>
            : GetScalarType<T[P], MensagensGroupByOutputType[P]>
        }
      >
    >


  export type MensagensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conteudo?: boolean
    foto?: boolean
    video?: boolean
    arquivo?: boolean
    data?: boolean
    emissorID?: boolean
    receptorID?: boolean
    visto?: boolean
    emissor?: boolean | UsuariosDefaultArgs<ExtArgs>
    receptor?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensagens"]>

  export type MensagensSelectScalar = {
    id?: boolean
    conteudo?: boolean
    foto?: boolean
    video?: boolean
    arquivo?: boolean
    data?: boolean
    emissorID?: boolean
    receptorID?: boolean
    visto?: boolean
  }

  export type MensagensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emissor?: boolean | UsuariosDefaultArgs<ExtArgs>
    receptor?: boolean | UsuariosDefaultArgs<ExtArgs>
  }


  export type $MensagensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mensagens"
    objects: {
      emissor: Prisma.$UsuariosPayload<ExtArgs>
      receptor: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conteudo: string | null
      foto: string | null
      video: string | null
      arquivo: string | null
      data: Date
      emissorID: string
      receptorID: string
      visto: boolean
    }, ExtArgs["result"]["mensagens"]>
    composites: {}
  }


  type MensagensGetPayload<S extends boolean | null | undefined | MensagensDefaultArgs> = $Result.GetResult<Prisma.$MensagensPayload, S>

  type MensagensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MensagensFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MensagensCountAggregateInputType | true
    }

  export interface MensagensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mensagens'], meta: { name: 'Mensagens' } }
    /**
     * Find zero or one Mensagens that matches the filter.
     * @param {MensagensFindUniqueArgs} args - Arguments to find a Mensagens
     * @example
     * // Get one Mensagens
     * const mensagens = await prisma.mensagens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MensagensFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MensagensFindUniqueArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Mensagens that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MensagensFindUniqueOrThrowArgs} args - Arguments to find a Mensagens
     * @example
     * // Get one Mensagens
     * const mensagens = await prisma.mensagens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MensagensFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MensagensFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Mensagens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagensFindFirstArgs} args - Arguments to find a Mensagens
     * @example
     * // Get one Mensagens
     * const mensagens = await prisma.mensagens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MensagensFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MensagensFindFirstArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Mensagens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagensFindFirstOrThrowArgs} args - Arguments to find a Mensagens
     * @example
     * // Get one Mensagens
     * const mensagens = await prisma.mensagens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MensagensFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MensagensFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Mensagens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensagens
     * const mensagens = await prisma.mensagens.findMany()
     * 
     * // Get first 10 Mensagens
     * const mensagens = await prisma.mensagens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensagensWithIdOnly = await prisma.mensagens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MensagensFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MensagensFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Mensagens.
     * @param {MensagensCreateArgs} args - Arguments to create a Mensagens.
     * @example
     * // Create one Mensagens
     * const Mensagens = await prisma.mensagens.create({
     *   data: {
     *     // ... data to create a Mensagens
     *   }
     * })
     * 
    **/
    create<T extends MensagensCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MensagensCreateArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Mensagens.
     *     @param {MensagensCreateManyArgs} args - Arguments to create many Mensagens.
     *     @example
     *     // Create many Mensagens
     *     const mensagens = await prisma.mensagens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MensagensCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MensagensCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mensagens.
     * @param {MensagensDeleteArgs} args - Arguments to delete one Mensagens.
     * @example
     * // Delete one Mensagens
     * const Mensagens = await prisma.mensagens.delete({
     *   where: {
     *     // ... filter to delete one Mensagens
     *   }
     * })
     * 
    **/
    delete<T extends MensagensDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MensagensDeleteArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Mensagens.
     * @param {MensagensUpdateArgs} args - Arguments to update one Mensagens.
     * @example
     * // Update one Mensagens
     * const mensagens = await prisma.mensagens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MensagensUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MensagensUpdateArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Mensagens.
     * @param {MensagensDeleteManyArgs} args - Arguments to filter Mensagens to delete.
     * @example
     * // Delete a few Mensagens
     * const { count } = await prisma.mensagens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MensagensDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MensagensDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensagens
     * const mensagens = await prisma.mensagens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MensagensUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MensagensUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mensagens.
     * @param {MensagensUpsertArgs} args - Arguments to update or create a Mensagens.
     * @example
     * // Update or create a Mensagens
     * const mensagens = await prisma.mensagens.upsert({
     *   create: {
     *     // ... data to create a Mensagens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensagens we want to update
     *   }
     * })
    **/
    upsert<T extends MensagensUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MensagensUpsertArgs<ExtArgs>>
    ): Prisma__MensagensClient<$Result.GetResult<Prisma.$MensagensPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Mensagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagensCountArgs} args - Arguments to filter Mensagens to count.
     * @example
     * // Count the number of Mensagens
     * const count = await prisma.mensagens.count({
     *   where: {
     *     // ... the filter for the Mensagens we want to count
     *   }
     * })
    **/
    count<T extends MensagensCountArgs>(
      args?: Subset<T, MensagensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MensagensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mensagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MensagensAggregateArgs>(args: Subset<T, MensagensAggregateArgs>): Prisma.PrismaPromise<GetMensagensAggregateType<T>>

    /**
     * Group by Mensagens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MensagensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MensagensGroupByArgs['orderBy'] }
        : { orderBy?: MensagensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MensagensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensagensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mensagens model
   */
  readonly fields: MensagensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mensagens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MensagensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    emissor<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    receptor<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Mensagens model
   */ 
  interface MensagensFieldRefs {
    readonly id: FieldRef<"Mensagens", 'String'>
    readonly conteudo: FieldRef<"Mensagens", 'String'>
    readonly foto: FieldRef<"Mensagens", 'String'>
    readonly video: FieldRef<"Mensagens", 'String'>
    readonly arquivo: FieldRef<"Mensagens", 'String'>
    readonly data: FieldRef<"Mensagens", 'DateTime'>
    readonly emissorID: FieldRef<"Mensagens", 'String'>
    readonly receptorID: FieldRef<"Mensagens", 'String'>
    readonly visto: FieldRef<"Mensagens", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Mensagens findUnique
   */
  export type MensagensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * Filter, which Mensagens to fetch.
     */
    where: MensagensWhereUniqueInput
  }


  /**
   * Mensagens findUniqueOrThrow
   */
  export type MensagensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * Filter, which Mensagens to fetch.
     */
    where: MensagensWhereUniqueInput
  }


  /**
   * Mensagens findFirst
   */
  export type MensagensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * Filter, which Mensagens to fetch.
     */
    where?: MensagensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagens to fetch.
     */
    orderBy?: MensagensOrderByWithRelationInput | MensagensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensagens.
     */
    cursor?: MensagensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensagens.
     */
    distinct?: MensagensScalarFieldEnum | MensagensScalarFieldEnum[]
  }


  /**
   * Mensagens findFirstOrThrow
   */
  export type MensagensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * Filter, which Mensagens to fetch.
     */
    where?: MensagensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagens to fetch.
     */
    orderBy?: MensagensOrderByWithRelationInput | MensagensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensagens.
     */
    cursor?: MensagensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensagens.
     */
    distinct?: MensagensScalarFieldEnum | MensagensScalarFieldEnum[]
  }


  /**
   * Mensagens findMany
   */
  export type MensagensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * Filter, which Mensagens to fetch.
     */
    where?: MensagensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagens to fetch.
     */
    orderBy?: MensagensOrderByWithRelationInput | MensagensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mensagens.
     */
    cursor?: MensagensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagens.
     */
    skip?: number
    distinct?: MensagensScalarFieldEnum | MensagensScalarFieldEnum[]
  }


  /**
   * Mensagens create
   */
  export type MensagensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * The data needed to create a Mensagens.
     */
    data: XOR<MensagensCreateInput, MensagensUncheckedCreateInput>
  }


  /**
   * Mensagens createMany
   */
  export type MensagensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mensagens.
     */
    data: MensagensCreateManyInput | MensagensCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Mensagens update
   */
  export type MensagensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * The data needed to update a Mensagens.
     */
    data: XOR<MensagensUpdateInput, MensagensUncheckedUpdateInput>
    /**
     * Choose, which Mensagens to update.
     */
    where: MensagensWhereUniqueInput
  }


  /**
   * Mensagens updateMany
   */
  export type MensagensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mensagens.
     */
    data: XOR<MensagensUpdateManyMutationInput, MensagensUncheckedUpdateManyInput>
    /**
     * Filter which Mensagens to update
     */
    where?: MensagensWhereInput
  }


  /**
   * Mensagens upsert
   */
  export type MensagensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * The filter to search for the Mensagens to update in case it exists.
     */
    where: MensagensWhereUniqueInput
    /**
     * In case the Mensagens found by the `where` argument doesn't exist, create a new Mensagens with this data.
     */
    create: XOR<MensagensCreateInput, MensagensUncheckedCreateInput>
    /**
     * In case the Mensagens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MensagensUpdateInput, MensagensUncheckedUpdateInput>
  }


  /**
   * Mensagens delete
   */
  export type MensagensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
    /**
     * Filter which Mensagens to delete.
     */
    where: MensagensWhereUniqueInput
  }


  /**
   * Mensagens deleteMany
   */
  export type MensagensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensagens to delete
     */
    where?: MensagensWhereInput
  }


  /**
   * Mensagens without action
   */
  export type MensagensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagens
     */
    select?: MensagensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MensagensInclude<ExtArgs> | null
  }



  /**
   * Model DiasDisponiveis
   */

  export type AggregateDiasDisponiveis = {
    _count: DiasDisponiveisCountAggregateOutputType | null
    _min: DiasDisponiveisMinAggregateOutputType | null
    _max: DiasDisponiveisMaxAggregateOutputType | null
  }

  export type DiasDisponiveisMinAggregateOutputType = {
    id: string | null
    date: Date | null
    especialistaID: string | null
  }

  export type DiasDisponiveisMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    especialistaID: string | null
  }

  export type DiasDisponiveisCountAggregateOutputType = {
    id: number
    date: number
    especialistaID: number
    _all: number
  }


  export type DiasDisponiveisMinAggregateInputType = {
    id?: true
    date?: true
    especialistaID?: true
  }

  export type DiasDisponiveisMaxAggregateInputType = {
    id?: true
    date?: true
    especialistaID?: true
  }

  export type DiasDisponiveisCountAggregateInputType = {
    id?: true
    date?: true
    especialistaID?: true
    _all?: true
  }

  export type DiasDisponiveisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiasDisponiveis to aggregate.
     */
    where?: DiasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiasDisponiveis to fetch.
     */
    orderBy?: DiasDisponiveisOrderByWithRelationInput | DiasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiasDisponiveis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiasDisponiveis
    **/
    _count?: true | DiasDisponiveisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiasDisponiveisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiasDisponiveisMaxAggregateInputType
  }

  export type GetDiasDisponiveisAggregateType<T extends DiasDisponiveisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiasDisponiveis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiasDisponiveis[P]>
      : GetScalarType<T[P], AggregateDiasDisponiveis[P]>
  }




  export type DiasDisponiveisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiasDisponiveisWhereInput
    orderBy?: DiasDisponiveisOrderByWithAggregationInput | DiasDisponiveisOrderByWithAggregationInput[]
    by: DiasDisponiveisScalarFieldEnum[] | DiasDisponiveisScalarFieldEnum
    having?: DiasDisponiveisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiasDisponiveisCountAggregateInputType | true
    _min?: DiasDisponiveisMinAggregateInputType
    _max?: DiasDisponiveisMaxAggregateInputType
  }

  export type DiasDisponiveisGroupByOutputType = {
    id: string
    date: Date
    especialistaID: string
    _count: DiasDisponiveisCountAggregateOutputType | null
    _min: DiasDisponiveisMinAggregateOutputType | null
    _max: DiasDisponiveisMaxAggregateOutputType | null
  }

  type GetDiasDisponiveisGroupByPayload<T extends DiasDisponiveisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiasDisponiveisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiasDisponiveisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiasDisponiveisGroupByOutputType[P]>
            : GetScalarType<T[P], DiasDisponiveisGroupByOutputType[P]>
        }
      >
    >


  export type DiasDisponiveisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    especialistaID?: boolean
    horasDisponiveis?: boolean | DiasDisponiveis$horasDisponiveisArgs<ExtArgs>
    especialista?: boolean | EspecialistasDefaultArgs<ExtArgs>
    _count?: boolean | DiasDisponiveisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diasDisponiveis"]>

  export type DiasDisponiveisSelectScalar = {
    id?: boolean
    date?: boolean
    especialistaID?: boolean
  }

  export type DiasDisponiveisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    horasDisponiveis?: boolean | DiasDisponiveis$horasDisponiveisArgs<ExtArgs>
    especialista?: boolean | EspecialistasDefaultArgs<ExtArgs>
    _count?: boolean | DiasDisponiveisCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DiasDisponiveisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiasDisponiveis"
    objects: {
      horasDisponiveis: Prisma.$HorasDisponiveisPayload<ExtArgs>[]
      especialista: Prisma.$EspecialistasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      especialistaID: string
    }, ExtArgs["result"]["diasDisponiveis"]>
    composites: {}
  }


  type DiasDisponiveisGetPayload<S extends boolean | null | undefined | DiasDisponiveisDefaultArgs> = $Result.GetResult<Prisma.$DiasDisponiveisPayload, S>

  type DiasDisponiveisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiasDisponiveisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiasDisponiveisCountAggregateInputType | true
    }

  export interface DiasDisponiveisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiasDisponiveis'], meta: { name: 'DiasDisponiveis' } }
    /**
     * Find zero or one DiasDisponiveis that matches the filter.
     * @param {DiasDisponiveisFindUniqueArgs} args - Arguments to find a DiasDisponiveis
     * @example
     * // Get one DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiasDisponiveisFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiasDisponiveisFindUniqueArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DiasDisponiveis that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DiasDisponiveisFindUniqueOrThrowArgs} args - Arguments to find a DiasDisponiveis
     * @example
     * // Get one DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiasDisponiveisFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiasDisponiveisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DiasDisponiveis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiasDisponiveisFindFirstArgs} args - Arguments to find a DiasDisponiveis
     * @example
     * // Get one DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiasDisponiveisFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiasDisponiveisFindFirstArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DiasDisponiveis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiasDisponiveisFindFirstOrThrowArgs} args - Arguments to find a DiasDisponiveis
     * @example
     * // Get one DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiasDisponiveisFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiasDisponiveisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DiasDisponiveis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiasDisponiveisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.findMany()
     * 
     * // Get first 10 DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diasDisponiveisWithIdOnly = await prisma.diasDisponiveis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiasDisponiveisFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiasDisponiveisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DiasDisponiveis.
     * @param {DiasDisponiveisCreateArgs} args - Arguments to create a DiasDisponiveis.
     * @example
     * // Create one DiasDisponiveis
     * const DiasDisponiveis = await prisma.diasDisponiveis.create({
     *   data: {
     *     // ... data to create a DiasDisponiveis
     *   }
     * })
     * 
    **/
    create<T extends DiasDisponiveisCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiasDisponiveisCreateArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DiasDisponiveis.
     *     @param {DiasDisponiveisCreateManyArgs} args - Arguments to create many DiasDisponiveis.
     *     @example
     *     // Create many DiasDisponiveis
     *     const diasDisponiveis = await prisma.diasDisponiveis.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiasDisponiveisCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiasDisponiveisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DiasDisponiveis.
     * @param {DiasDisponiveisDeleteArgs} args - Arguments to delete one DiasDisponiveis.
     * @example
     * // Delete one DiasDisponiveis
     * const DiasDisponiveis = await prisma.diasDisponiveis.delete({
     *   where: {
     *     // ... filter to delete one DiasDisponiveis
     *   }
     * })
     * 
    **/
    delete<T extends DiasDisponiveisDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiasDisponiveisDeleteArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DiasDisponiveis.
     * @param {DiasDisponiveisUpdateArgs} args - Arguments to update one DiasDisponiveis.
     * @example
     * // Update one DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiasDisponiveisUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiasDisponiveisUpdateArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DiasDisponiveis.
     * @param {DiasDisponiveisDeleteManyArgs} args - Arguments to filter DiasDisponiveis to delete.
     * @example
     * // Delete a few DiasDisponiveis
     * const { count } = await prisma.diasDisponiveis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiasDisponiveisDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiasDisponiveisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiasDisponiveisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiasDisponiveisUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiasDisponiveisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiasDisponiveis.
     * @param {DiasDisponiveisUpsertArgs} args - Arguments to update or create a DiasDisponiveis.
     * @example
     * // Update or create a DiasDisponiveis
     * const diasDisponiveis = await prisma.diasDisponiveis.upsert({
     *   create: {
     *     // ... data to create a DiasDisponiveis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiasDisponiveis we want to update
     *   }
     * })
    **/
    upsert<T extends DiasDisponiveisUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiasDisponiveisUpsertArgs<ExtArgs>>
    ): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DiasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiasDisponiveisCountArgs} args - Arguments to filter DiasDisponiveis to count.
     * @example
     * // Count the number of DiasDisponiveis
     * const count = await prisma.diasDisponiveis.count({
     *   where: {
     *     // ... the filter for the DiasDisponiveis we want to count
     *   }
     * })
    **/
    count<T extends DiasDisponiveisCountArgs>(
      args?: Subset<T, DiasDisponiveisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiasDisponiveisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiasDisponiveisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiasDisponiveisAggregateArgs>(args: Subset<T, DiasDisponiveisAggregateArgs>): Prisma.PrismaPromise<GetDiasDisponiveisAggregateType<T>>

    /**
     * Group by DiasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiasDisponiveisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiasDisponiveisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiasDisponiveisGroupByArgs['orderBy'] }
        : { orderBy?: DiasDisponiveisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiasDisponiveisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiasDisponiveisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiasDisponiveis model
   */
  readonly fields: DiasDisponiveisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiasDisponiveis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiasDisponiveisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    horasDisponiveis<T extends DiasDisponiveis$horasDisponiveisArgs<ExtArgs> = {}>(args?: Subset<T, DiasDisponiveis$horasDisponiveisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'findMany'> | Null>;

    especialista<T extends EspecialistasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspecialistasDefaultArgs<ExtArgs>>): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DiasDisponiveis model
   */ 
  interface DiasDisponiveisFieldRefs {
    readonly id: FieldRef<"DiasDisponiveis", 'String'>
    readonly date: FieldRef<"DiasDisponiveis", 'DateTime'>
    readonly especialistaID: FieldRef<"DiasDisponiveis", 'String'>
  }
    

  // Custom InputTypes

  /**
   * DiasDisponiveis findUnique
   */
  export type DiasDisponiveisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which DiasDisponiveis to fetch.
     */
    where: DiasDisponiveisWhereUniqueInput
  }


  /**
   * DiasDisponiveis findUniqueOrThrow
   */
  export type DiasDisponiveisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which DiasDisponiveis to fetch.
     */
    where: DiasDisponiveisWhereUniqueInput
  }


  /**
   * DiasDisponiveis findFirst
   */
  export type DiasDisponiveisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which DiasDisponiveis to fetch.
     */
    where?: DiasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiasDisponiveis to fetch.
     */
    orderBy?: DiasDisponiveisOrderByWithRelationInput | DiasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiasDisponiveis.
     */
    cursor?: DiasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiasDisponiveis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiasDisponiveis.
     */
    distinct?: DiasDisponiveisScalarFieldEnum | DiasDisponiveisScalarFieldEnum[]
  }


  /**
   * DiasDisponiveis findFirstOrThrow
   */
  export type DiasDisponiveisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which DiasDisponiveis to fetch.
     */
    where?: DiasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiasDisponiveis to fetch.
     */
    orderBy?: DiasDisponiveisOrderByWithRelationInput | DiasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiasDisponiveis.
     */
    cursor?: DiasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiasDisponiveis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiasDisponiveis.
     */
    distinct?: DiasDisponiveisScalarFieldEnum | DiasDisponiveisScalarFieldEnum[]
  }


  /**
   * DiasDisponiveis findMany
   */
  export type DiasDisponiveisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which DiasDisponiveis to fetch.
     */
    where?: DiasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiasDisponiveis to fetch.
     */
    orderBy?: DiasDisponiveisOrderByWithRelationInput | DiasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiasDisponiveis.
     */
    cursor?: DiasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiasDisponiveis.
     */
    skip?: number
    distinct?: DiasDisponiveisScalarFieldEnum | DiasDisponiveisScalarFieldEnum[]
  }


  /**
   * DiasDisponiveis create
   */
  export type DiasDisponiveisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * The data needed to create a DiasDisponiveis.
     */
    data: XOR<DiasDisponiveisCreateInput, DiasDisponiveisUncheckedCreateInput>
  }


  /**
   * DiasDisponiveis createMany
   */
  export type DiasDisponiveisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiasDisponiveis.
     */
    data: DiasDisponiveisCreateManyInput | DiasDisponiveisCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DiasDisponiveis update
   */
  export type DiasDisponiveisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * The data needed to update a DiasDisponiveis.
     */
    data: XOR<DiasDisponiveisUpdateInput, DiasDisponiveisUncheckedUpdateInput>
    /**
     * Choose, which DiasDisponiveis to update.
     */
    where: DiasDisponiveisWhereUniqueInput
  }


  /**
   * DiasDisponiveis updateMany
   */
  export type DiasDisponiveisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiasDisponiveis.
     */
    data: XOR<DiasDisponiveisUpdateManyMutationInput, DiasDisponiveisUncheckedUpdateManyInput>
    /**
     * Filter which DiasDisponiveis to update
     */
    where?: DiasDisponiveisWhereInput
  }


  /**
   * DiasDisponiveis upsert
   */
  export type DiasDisponiveisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * The filter to search for the DiasDisponiveis to update in case it exists.
     */
    where: DiasDisponiveisWhereUniqueInput
    /**
     * In case the DiasDisponiveis found by the `where` argument doesn't exist, create a new DiasDisponiveis with this data.
     */
    create: XOR<DiasDisponiveisCreateInput, DiasDisponiveisUncheckedCreateInput>
    /**
     * In case the DiasDisponiveis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiasDisponiveisUpdateInput, DiasDisponiveisUncheckedUpdateInput>
  }


  /**
   * DiasDisponiveis delete
   */
  export type DiasDisponiveisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter which DiasDisponiveis to delete.
     */
    where: DiasDisponiveisWhereUniqueInput
  }


  /**
   * DiasDisponiveis deleteMany
   */
  export type DiasDisponiveisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiasDisponiveis to delete
     */
    where?: DiasDisponiveisWhereInput
  }


  /**
   * DiasDisponiveis.horasDisponiveis
   */
  export type DiasDisponiveis$horasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    where?: HorasDisponiveisWhereInput
    orderBy?: HorasDisponiveisOrderByWithRelationInput | HorasDisponiveisOrderByWithRelationInput[]
    cursor?: HorasDisponiveisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HorasDisponiveisScalarFieldEnum | HorasDisponiveisScalarFieldEnum[]
  }


  /**
   * DiasDisponiveis without action
   */
  export type DiasDisponiveisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiasDisponiveis
     */
    select?: DiasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiasDisponiveisInclude<ExtArgs> | null
  }



  /**
   * Model HorasDisponiveis
   */

  export type AggregateHorasDisponiveis = {
    _count: HorasDisponiveisCountAggregateOutputType | null
    _min: HorasDisponiveisMinAggregateOutputType | null
    _max: HorasDisponiveisMaxAggregateOutputType | null
  }

  export type HorasDisponiveisMinAggregateOutputType = {
    id: string | null
    hora: string | null
    diasDisponiveisID: string | null
    especialistaID: string | null
  }

  export type HorasDisponiveisMaxAggregateOutputType = {
    id: string | null
    hora: string | null
    diasDisponiveisID: string | null
    especialistaID: string | null
  }

  export type HorasDisponiveisCountAggregateOutputType = {
    id: number
    hora: number
    diasDisponiveisID: number
    especialistaID: number
    _all: number
  }


  export type HorasDisponiveisMinAggregateInputType = {
    id?: true
    hora?: true
    diasDisponiveisID?: true
    especialistaID?: true
  }

  export type HorasDisponiveisMaxAggregateInputType = {
    id?: true
    hora?: true
    diasDisponiveisID?: true
    especialistaID?: true
  }

  export type HorasDisponiveisCountAggregateInputType = {
    id?: true
    hora?: true
    diasDisponiveisID?: true
    especialistaID?: true
    _all?: true
  }

  export type HorasDisponiveisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HorasDisponiveis to aggregate.
     */
    where?: HorasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorasDisponiveis to fetch.
     */
    orderBy?: HorasDisponiveisOrderByWithRelationInput | HorasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HorasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorasDisponiveis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HorasDisponiveis
    **/
    _count?: true | HorasDisponiveisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HorasDisponiveisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HorasDisponiveisMaxAggregateInputType
  }

  export type GetHorasDisponiveisAggregateType<T extends HorasDisponiveisAggregateArgs> = {
        [P in keyof T & keyof AggregateHorasDisponiveis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHorasDisponiveis[P]>
      : GetScalarType<T[P], AggregateHorasDisponiveis[P]>
  }




  export type HorasDisponiveisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HorasDisponiveisWhereInput
    orderBy?: HorasDisponiveisOrderByWithAggregationInput | HorasDisponiveisOrderByWithAggregationInput[]
    by: HorasDisponiveisScalarFieldEnum[] | HorasDisponiveisScalarFieldEnum
    having?: HorasDisponiveisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HorasDisponiveisCountAggregateInputType | true
    _min?: HorasDisponiveisMinAggregateInputType
    _max?: HorasDisponiveisMaxAggregateInputType
  }

  export type HorasDisponiveisGroupByOutputType = {
    id: string
    hora: string
    diasDisponiveisID: string
    especialistaID: string
    _count: HorasDisponiveisCountAggregateOutputType | null
    _min: HorasDisponiveisMinAggregateOutputType | null
    _max: HorasDisponiveisMaxAggregateOutputType | null
  }

  type GetHorasDisponiveisGroupByPayload<T extends HorasDisponiveisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HorasDisponiveisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HorasDisponiveisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HorasDisponiveisGroupByOutputType[P]>
            : GetScalarType<T[P], HorasDisponiveisGroupByOutputType[P]>
        }
      >
    >


  export type HorasDisponiveisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hora?: boolean
    diasDisponiveisID?: boolean
    especialistaID?: boolean
    diasDisponiveis?: boolean | DiasDisponiveisDefaultArgs<ExtArgs>
    especialista?: boolean | EspecialistasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horasDisponiveis"]>

  export type HorasDisponiveisSelectScalar = {
    id?: boolean
    hora?: boolean
    diasDisponiveisID?: boolean
    especialistaID?: boolean
  }

  export type HorasDisponiveisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diasDisponiveis?: boolean | DiasDisponiveisDefaultArgs<ExtArgs>
    especialista?: boolean | EspecialistasDefaultArgs<ExtArgs>
  }


  export type $HorasDisponiveisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HorasDisponiveis"
    objects: {
      diasDisponiveis: Prisma.$DiasDisponiveisPayload<ExtArgs>
      especialista: Prisma.$EspecialistasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hora: string
      diasDisponiveisID: string
      especialistaID: string
    }, ExtArgs["result"]["horasDisponiveis"]>
    composites: {}
  }


  type HorasDisponiveisGetPayload<S extends boolean | null | undefined | HorasDisponiveisDefaultArgs> = $Result.GetResult<Prisma.$HorasDisponiveisPayload, S>

  type HorasDisponiveisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HorasDisponiveisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HorasDisponiveisCountAggregateInputType | true
    }

  export interface HorasDisponiveisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HorasDisponiveis'], meta: { name: 'HorasDisponiveis' } }
    /**
     * Find zero or one HorasDisponiveis that matches the filter.
     * @param {HorasDisponiveisFindUniqueArgs} args - Arguments to find a HorasDisponiveis
     * @example
     * // Get one HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HorasDisponiveisFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HorasDisponiveisFindUniqueArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HorasDisponiveis that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HorasDisponiveisFindUniqueOrThrowArgs} args - Arguments to find a HorasDisponiveis
     * @example
     * // Get one HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HorasDisponiveisFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasDisponiveisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HorasDisponiveis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasDisponiveisFindFirstArgs} args - Arguments to find a HorasDisponiveis
     * @example
     * // Get one HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HorasDisponiveisFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasDisponiveisFindFirstArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HorasDisponiveis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasDisponiveisFindFirstOrThrowArgs} args - Arguments to find a HorasDisponiveis
     * @example
     * // Get one HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HorasDisponiveisFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasDisponiveisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HorasDisponiveis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasDisponiveisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.findMany()
     * 
     * // Get first 10 HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const horasDisponiveisWithIdOnly = await prisma.horasDisponiveis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HorasDisponiveisFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasDisponiveisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HorasDisponiveis.
     * @param {HorasDisponiveisCreateArgs} args - Arguments to create a HorasDisponiveis.
     * @example
     * // Create one HorasDisponiveis
     * const HorasDisponiveis = await prisma.horasDisponiveis.create({
     *   data: {
     *     // ... data to create a HorasDisponiveis
     *   }
     * })
     * 
    **/
    create<T extends HorasDisponiveisCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HorasDisponiveisCreateArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HorasDisponiveis.
     *     @param {HorasDisponiveisCreateManyArgs} args - Arguments to create many HorasDisponiveis.
     *     @example
     *     // Create many HorasDisponiveis
     *     const horasDisponiveis = await prisma.horasDisponiveis.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HorasDisponiveisCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasDisponiveisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HorasDisponiveis.
     * @param {HorasDisponiveisDeleteArgs} args - Arguments to delete one HorasDisponiveis.
     * @example
     * // Delete one HorasDisponiveis
     * const HorasDisponiveis = await prisma.horasDisponiveis.delete({
     *   where: {
     *     // ... filter to delete one HorasDisponiveis
     *   }
     * })
     * 
    **/
    delete<T extends HorasDisponiveisDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HorasDisponiveisDeleteArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HorasDisponiveis.
     * @param {HorasDisponiveisUpdateArgs} args - Arguments to update one HorasDisponiveis.
     * @example
     * // Update one HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HorasDisponiveisUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HorasDisponiveisUpdateArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HorasDisponiveis.
     * @param {HorasDisponiveisDeleteManyArgs} args - Arguments to filter HorasDisponiveis to delete.
     * @example
     * // Delete a few HorasDisponiveis
     * const { count } = await prisma.horasDisponiveis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HorasDisponiveisDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasDisponiveisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HorasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasDisponiveisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HorasDisponiveisUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HorasDisponiveisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HorasDisponiveis.
     * @param {HorasDisponiveisUpsertArgs} args - Arguments to update or create a HorasDisponiveis.
     * @example
     * // Update or create a HorasDisponiveis
     * const horasDisponiveis = await prisma.horasDisponiveis.upsert({
     *   create: {
     *     // ... data to create a HorasDisponiveis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HorasDisponiveis we want to update
     *   }
     * })
    **/
    upsert<T extends HorasDisponiveisUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HorasDisponiveisUpsertArgs<ExtArgs>>
    ): Prisma__HorasDisponiveisClient<$Result.GetResult<Prisma.$HorasDisponiveisPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HorasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasDisponiveisCountArgs} args - Arguments to filter HorasDisponiveis to count.
     * @example
     * // Count the number of HorasDisponiveis
     * const count = await prisma.horasDisponiveis.count({
     *   where: {
     *     // ... the filter for the HorasDisponiveis we want to count
     *   }
     * })
    **/
    count<T extends HorasDisponiveisCountArgs>(
      args?: Subset<T, HorasDisponiveisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HorasDisponiveisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HorasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasDisponiveisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HorasDisponiveisAggregateArgs>(args: Subset<T, HorasDisponiveisAggregateArgs>): Prisma.PrismaPromise<GetHorasDisponiveisAggregateType<T>>

    /**
     * Group by HorasDisponiveis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasDisponiveisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HorasDisponiveisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HorasDisponiveisGroupByArgs['orderBy'] }
        : { orderBy?: HorasDisponiveisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HorasDisponiveisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorasDisponiveisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HorasDisponiveis model
   */
  readonly fields: HorasDisponiveisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HorasDisponiveis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HorasDisponiveisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    diasDisponiveis<T extends DiasDisponiveisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiasDisponiveisDefaultArgs<ExtArgs>>): Prisma__DiasDisponiveisClient<$Result.GetResult<Prisma.$DiasDisponiveisPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    especialista<T extends EspecialistasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspecialistasDefaultArgs<ExtArgs>>): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HorasDisponiveis model
   */ 
  interface HorasDisponiveisFieldRefs {
    readonly id: FieldRef<"HorasDisponiveis", 'String'>
    readonly hora: FieldRef<"HorasDisponiveis", 'String'>
    readonly diasDisponiveisID: FieldRef<"HorasDisponiveis", 'String'>
    readonly especialistaID: FieldRef<"HorasDisponiveis", 'String'>
  }
    

  // Custom InputTypes

  /**
   * HorasDisponiveis findUnique
   */
  export type HorasDisponiveisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which HorasDisponiveis to fetch.
     */
    where: HorasDisponiveisWhereUniqueInput
  }


  /**
   * HorasDisponiveis findUniqueOrThrow
   */
  export type HorasDisponiveisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which HorasDisponiveis to fetch.
     */
    where: HorasDisponiveisWhereUniqueInput
  }


  /**
   * HorasDisponiveis findFirst
   */
  export type HorasDisponiveisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which HorasDisponiveis to fetch.
     */
    where?: HorasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorasDisponiveis to fetch.
     */
    orderBy?: HorasDisponiveisOrderByWithRelationInput | HorasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HorasDisponiveis.
     */
    cursor?: HorasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorasDisponiveis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HorasDisponiveis.
     */
    distinct?: HorasDisponiveisScalarFieldEnum | HorasDisponiveisScalarFieldEnum[]
  }


  /**
   * HorasDisponiveis findFirstOrThrow
   */
  export type HorasDisponiveisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which HorasDisponiveis to fetch.
     */
    where?: HorasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorasDisponiveis to fetch.
     */
    orderBy?: HorasDisponiveisOrderByWithRelationInput | HorasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HorasDisponiveis.
     */
    cursor?: HorasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorasDisponiveis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HorasDisponiveis.
     */
    distinct?: HorasDisponiveisScalarFieldEnum | HorasDisponiveisScalarFieldEnum[]
  }


  /**
   * HorasDisponiveis findMany
   */
  export type HorasDisponiveisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter, which HorasDisponiveis to fetch.
     */
    where?: HorasDisponiveisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HorasDisponiveis to fetch.
     */
    orderBy?: HorasDisponiveisOrderByWithRelationInput | HorasDisponiveisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HorasDisponiveis.
     */
    cursor?: HorasDisponiveisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HorasDisponiveis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HorasDisponiveis.
     */
    skip?: number
    distinct?: HorasDisponiveisScalarFieldEnum | HorasDisponiveisScalarFieldEnum[]
  }


  /**
   * HorasDisponiveis create
   */
  export type HorasDisponiveisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * The data needed to create a HorasDisponiveis.
     */
    data: XOR<HorasDisponiveisCreateInput, HorasDisponiveisUncheckedCreateInput>
  }


  /**
   * HorasDisponiveis createMany
   */
  export type HorasDisponiveisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HorasDisponiveis.
     */
    data: HorasDisponiveisCreateManyInput | HorasDisponiveisCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * HorasDisponiveis update
   */
  export type HorasDisponiveisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * The data needed to update a HorasDisponiveis.
     */
    data: XOR<HorasDisponiveisUpdateInput, HorasDisponiveisUncheckedUpdateInput>
    /**
     * Choose, which HorasDisponiveis to update.
     */
    where: HorasDisponiveisWhereUniqueInput
  }


  /**
   * HorasDisponiveis updateMany
   */
  export type HorasDisponiveisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HorasDisponiveis.
     */
    data: XOR<HorasDisponiveisUpdateManyMutationInput, HorasDisponiveisUncheckedUpdateManyInput>
    /**
     * Filter which HorasDisponiveis to update
     */
    where?: HorasDisponiveisWhereInput
  }


  /**
   * HorasDisponiveis upsert
   */
  export type HorasDisponiveisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * The filter to search for the HorasDisponiveis to update in case it exists.
     */
    where: HorasDisponiveisWhereUniqueInput
    /**
     * In case the HorasDisponiveis found by the `where` argument doesn't exist, create a new HorasDisponiveis with this data.
     */
    create: XOR<HorasDisponiveisCreateInput, HorasDisponiveisUncheckedCreateInput>
    /**
     * In case the HorasDisponiveis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HorasDisponiveisUpdateInput, HorasDisponiveisUncheckedUpdateInput>
  }


  /**
   * HorasDisponiveis delete
   */
  export type HorasDisponiveisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
    /**
     * Filter which HorasDisponiveis to delete.
     */
    where: HorasDisponiveisWhereUniqueInput
  }


  /**
   * HorasDisponiveis deleteMany
   */
  export type HorasDisponiveisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HorasDisponiveis to delete
     */
    where?: HorasDisponiveisWhereInput
  }


  /**
   * HorasDisponiveis without action
   */
  export type HorasDisponiveisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorasDisponiveis
     */
    select?: HorasDisponiveisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasDisponiveisInclude<ExtArgs> | null
  }



  /**
   * Model Consultas
   */

  export type AggregateConsultas = {
    _count: ConsultasCountAggregateOutputType | null
    _min: ConsultasMinAggregateOutputType | null
    _max: ConsultasMaxAggregateOutputType | null
  }

  export type ConsultasMinAggregateOutputType = {
    id: string | null
    tipo_Da_Consulta: string | null
    data: Date | null
    hora: string | null
    especialistaID: string | null
    status: $Enums.Consulta | null
    pacienteID: string | null
  }

  export type ConsultasMaxAggregateOutputType = {
    id: string | null
    tipo_Da_Consulta: string | null
    data: Date | null
    hora: string | null
    especialistaID: string | null
    status: $Enums.Consulta | null
    pacienteID: string | null
  }

  export type ConsultasCountAggregateOutputType = {
    id: number
    tipo_Da_Consulta: number
    data: number
    hora: number
    especialistaID: number
    status: number
    pacienteID: number
    _all: number
  }


  export type ConsultasMinAggregateInputType = {
    id?: true
    tipo_Da_Consulta?: true
    data?: true
    hora?: true
    especialistaID?: true
    status?: true
    pacienteID?: true
  }

  export type ConsultasMaxAggregateInputType = {
    id?: true
    tipo_Da_Consulta?: true
    data?: true
    hora?: true
    especialistaID?: true
    status?: true
    pacienteID?: true
  }

  export type ConsultasCountAggregateInputType = {
    id?: true
    tipo_Da_Consulta?: true
    data?: true
    hora?: true
    especialistaID?: true
    status?: true
    pacienteID?: true
    _all?: true
  }

  export type ConsultasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultas to aggregate.
     */
    where?: ConsultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultas to fetch.
     */
    orderBy?: ConsultasOrderByWithRelationInput | ConsultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultas
    **/
    _count?: true | ConsultasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultasMaxAggregateInputType
  }

  export type GetConsultasAggregateType<T extends ConsultasAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultas[P]>
      : GetScalarType<T[P], AggregateConsultas[P]>
  }




  export type ConsultasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultasWhereInput
    orderBy?: ConsultasOrderByWithAggregationInput | ConsultasOrderByWithAggregationInput[]
    by: ConsultasScalarFieldEnum[] | ConsultasScalarFieldEnum
    having?: ConsultasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultasCountAggregateInputType | true
    _min?: ConsultasMinAggregateInputType
    _max?: ConsultasMaxAggregateInputType
  }

  export type ConsultasGroupByOutputType = {
    id: string
    tipo_Da_Consulta: string
    data: Date
    hora: string
    especialistaID: string
    status: $Enums.Consulta
    pacienteID: string
    _count: ConsultasCountAggregateOutputType | null
    _min: ConsultasMinAggregateOutputType | null
    _max: ConsultasMaxAggregateOutputType | null
  }

  type GetConsultasGroupByPayload<T extends ConsultasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultasGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultasGroupByOutputType[P]>
        }
      >
    >


  export type ConsultasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo_Da_Consulta?: boolean
    data?: boolean
    hora?: boolean
    especialistaID?: boolean
    status?: boolean
    pacienteID?: boolean
    especialista?: boolean | EspecialistasDefaultArgs<ExtArgs>
    usuario?: boolean | UsuariosDefaultArgs<ExtArgs>
    notificacoes?: boolean | Consultas$notificacoesArgs<ExtArgs>
    _count?: boolean | ConsultasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultas"]>

  export type ConsultasSelectScalar = {
    id?: boolean
    tipo_Da_Consulta?: boolean
    data?: boolean
    hora?: boolean
    especialistaID?: boolean
    status?: boolean
    pacienteID?: boolean
  }

  export type ConsultasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especialista?: boolean | EspecialistasDefaultArgs<ExtArgs>
    usuario?: boolean | UsuariosDefaultArgs<ExtArgs>
    notificacoes?: boolean | Consultas$notificacoesArgs<ExtArgs>
    _count?: boolean | ConsultasCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConsultasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consultas"
    objects: {
      especialista: Prisma.$EspecialistasPayload<ExtArgs>
      usuario: Prisma.$UsuariosPayload<ExtArgs>
      notificacoes: Prisma.$NotificacoesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo_Da_Consulta: string
      data: Date
      hora: string
      especialistaID: string
      status: $Enums.Consulta
      pacienteID: string
    }, ExtArgs["result"]["consultas"]>
    composites: {}
  }


  type ConsultasGetPayload<S extends boolean | null | undefined | ConsultasDefaultArgs> = $Result.GetResult<Prisma.$ConsultasPayload, S>

  type ConsultasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultasCountAggregateInputType | true
    }

  export interface ConsultasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consultas'], meta: { name: 'Consultas' } }
    /**
     * Find zero or one Consultas that matches the filter.
     * @param {ConsultasFindUniqueArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConsultasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultasFindUniqueArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Consultas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConsultasFindUniqueOrThrowArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConsultasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Consultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasFindFirstArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConsultasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultasFindFirstArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Consultas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasFindFirstOrThrowArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConsultasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Consultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultas
     * const consultas = await prisma.consultas.findMany()
     * 
     * // Get first 10 Consultas
     * const consultas = await prisma.consultas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultasWithIdOnly = await prisma.consultas.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConsultasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Consultas.
     * @param {ConsultasCreateArgs} args - Arguments to create a Consultas.
     * @example
     * // Create one Consultas
     * const Consultas = await prisma.consultas.create({
     *   data: {
     *     // ... data to create a Consultas
     *   }
     * })
     * 
    **/
    create<T extends ConsultasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultasCreateArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Consultas.
     *     @param {ConsultasCreateManyArgs} args - Arguments to create many Consultas.
     *     @example
     *     // Create many Consultas
     *     const consultas = await prisma.consultas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConsultasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consultas.
     * @param {ConsultasDeleteArgs} args - Arguments to delete one Consultas.
     * @example
     * // Delete one Consultas
     * const Consultas = await prisma.consultas.delete({
     *   where: {
     *     // ... filter to delete one Consultas
     *   }
     * })
     * 
    **/
    delete<T extends ConsultasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultasDeleteArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Consultas.
     * @param {ConsultasUpdateArgs} args - Arguments to update one Consultas.
     * @example
     * // Update one Consultas
     * const consultas = await prisma.consultas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConsultasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultasUpdateArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Consultas.
     * @param {ConsultasDeleteManyArgs} args - Arguments to filter Consultas to delete.
     * @example
     * // Delete a few Consultas
     * const { count } = await prisma.consultas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConsultasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConsultasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultas
     * const consultas = await prisma.consultas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConsultasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultas.
     * @param {ConsultasUpsertArgs} args - Arguments to update or create a Consultas.
     * @example
     * // Update or create a Consultas
     * const consultas = await prisma.consultas.upsert({
     *   create: {
     *     // ... data to create a Consultas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultas we want to update
     *   }
     * })
    **/
    upsert<T extends ConsultasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConsultasUpsertArgs<ExtArgs>>
    ): Prisma__ConsultasClient<$Result.GetResult<Prisma.$ConsultasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasCountArgs} args - Arguments to filter Consultas to count.
     * @example
     * // Count the number of Consultas
     * const count = await prisma.consultas.count({
     *   where: {
     *     // ... the filter for the Consultas we want to count
     *   }
     * })
    **/
    count<T extends ConsultasCountArgs>(
      args?: Subset<T, ConsultasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultasAggregateArgs>(args: Subset<T, ConsultasAggregateArgs>): Prisma.PrismaPromise<GetConsultasAggregateType<T>>

    /**
     * Group by Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultasGroupByArgs['orderBy'] }
        : { orderBy?: ConsultasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consultas model
   */
  readonly fields: ConsultasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    especialista<T extends EspecialistasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspecialistasDefaultArgs<ExtArgs>>): Prisma__EspecialistasClient<$Result.GetResult<Prisma.$EspecialistasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuario<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    notificacoes<T extends Consultas$notificacoesArgs<ExtArgs> = {}>(args?: Subset<T, Consultas$notificacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Consultas model
   */ 
  interface ConsultasFieldRefs {
    readonly id: FieldRef<"Consultas", 'String'>
    readonly tipo_Da_Consulta: FieldRef<"Consultas", 'String'>
    readonly data: FieldRef<"Consultas", 'DateTime'>
    readonly hora: FieldRef<"Consultas", 'String'>
    readonly especialistaID: FieldRef<"Consultas", 'String'>
    readonly status: FieldRef<"Consultas", 'Consulta'>
    readonly pacienteID: FieldRef<"Consultas", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Consultas findUnique
   */
  export type ConsultasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * Filter, which Consultas to fetch.
     */
    where: ConsultasWhereUniqueInput
  }


  /**
   * Consultas findUniqueOrThrow
   */
  export type ConsultasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * Filter, which Consultas to fetch.
     */
    where: ConsultasWhereUniqueInput
  }


  /**
   * Consultas findFirst
   */
  export type ConsultasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * Filter, which Consultas to fetch.
     */
    where?: ConsultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultas to fetch.
     */
    orderBy?: ConsultasOrderByWithRelationInput | ConsultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultas.
     */
    cursor?: ConsultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultas.
     */
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }


  /**
   * Consultas findFirstOrThrow
   */
  export type ConsultasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * Filter, which Consultas to fetch.
     */
    where?: ConsultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultas to fetch.
     */
    orderBy?: ConsultasOrderByWithRelationInput | ConsultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultas.
     */
    cursor?: ConsultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultas.
     */
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }


  /**
   * Consultas findMany
   */
  export type ConsultasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * Filter, which Consultas to fetch.
     */
    where?: ConsultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultas to fetch.
     */
    orderBy?: ConsultasOrderByWithRelationInput | ConsultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultas.
     */
    cursor?: ConsultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultas.
     */
    skip?: number
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }


  /**
   * Consultas create
   */
  export type ConsultasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * The data needed to create a Consultas.
     */
    data: XOR<ConsultasCreateInput, ConsultasUncheckedCreateInput>
  }


  /**
   * Consultas createMany
   */
  export type ConsultasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consultas.
     */
    data: ConsultasCreateManyInput | ConsultasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Consultas update
   */
  export type ConsultasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * The data needed to update a Consultas.
     */
    data: XOR<ConsultasUpdateInput, ConsultasUncheckedUpdateInput>
    /**
     * Choose, which Consultas to update.
     */
    where: ConsultasWhereUniqueInput
  }


  /**
   * Consultas updateMany
   */
  export type ConsultasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consultas.
     */
    data: XOR<ConsultasUpdateManyMutationInput, ConsultasUncheckedUpdateManyInput>
    /**
     * Filter which Consultas to update
     */
    where?: ConsultasWhereInput
  }


  /**
   * Consultas upsert
   */
  export type ConsultasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * The filter to search for the Consultas to update in case it exists.
     */
    where: ConsultasWhereUniqueInput
    /**
     * In case the Consultas found by the `where` argument doesn't exist, create a new Consultas with this data.
     */
    create: XOR<ConsultasCreateInput, ConsultasUncheckedCreateInput>
    /**
     * In case the Consultas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultasUpdateInput, ConsultasUncheckedUpdateInput>
  }


  /**
   * Consultas delete
   */
  export type ConsultasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
    /**
     * Filter which Consultas to delete.
     */
    where: ConsultasWhereUniqueInput
  }


  /**
   * Consultas deleteMany
   */
  export type ConsultasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultas to delete
     */
    where?: ConsultasWhereInput
  }


  /**
   * Consultas.notificacoes
   */
  export type Consultas$notificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacoes
     */
    select?: NotificacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificacoesInclude<ExtArgs> | null
    where?: NotificacoesWhereInput
    orderBy?: NotificacoesOrderByWithRelationInput | NotificacoesOrderByWithRelationInput[]
    cursor?: NotificacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacoesScalarFieldEnum | NotificacoesScalarFieldEnum[]
  }


  /**
   * Consultas without action
   */
  export type ConsultasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultas
     */
    select?: ConsultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultasInclude<ExtArgs> | null
  }



  /**
   * Model VideoCall
   */

  export type AggregateVideoCall = {
    _count: VideoCallCountAggregateOutputType | null
    _min: VideoCallMinAggregateOutputType | null
    _max: VideoCallMaxAggregateOutputType | null
  }

  export type VideoCallMinAggregateOutputType = {
    id: string | null
    emissor: string | null
    destinatario: string | null
  }

  export type VideoCallMaxAggregateOutputType = {
    id: string | null
    emissor: string | null
    destinatario: string | null
  }

  export type VideoCallCountAggregateOutputType = {
    id: number
    emissor: number
    destinatario: number
    offer: number
    answer: number
    _all: number
  }


  export type VideoCallMinAggregateInputType = {
    id?: true
    emissor?: true
    destinatario?: true
  }

  export type VideoCallMaxAggregateInputType = {
    id?: true
    emissor?: true
    destinatario?: true
  }

  export type VideoCallCountAggregateInputType = {
    id?: true
    emissor?: true
    destinatario?: true
    offer?: true
    answer?: true
    _all?: true
  }

  export type VideoCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoCall to aggregate.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoCalls
    **/
    _count?: true | VideoCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoCallMaxAggregateInputType
  }

  export type GetVideoCallAggregateType<T extends VideoCallAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoCall[P]>
      : GetScalarType<T[P], AggregateVideoCall[P]>
  }




  export type VideoCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoCallWhereInput
    orderBy?: VideoCallOrderByWithAggregationInput | VideoCallOrderByWithAggregationInput[]
    by: VideoCallScalarFieldEnum[] | VideoCallScalarFieldEnum
    having?: VideoCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCallCountAggregateInputType | true
    _min?: VideoCallMinAggregateInputType
    _max?: VideoCallMaxAggregateInputType
  }

  export type VideoCallGroupByOutputType = {
    id: string
    emissor: string
    destinatario: string
    offer: JsonValue | null
    answer: JsonValue | null
    _count: VideoCallCountAggregateOutputType | null
    _min: VideoCallMinAggregateOutputType | null
    _max: VideoCallMaxAggregateOutputType | null
  }

  type GetVideoCallGroupByPayload<T extends VideoCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoCallGroupByOutputType[P]>
            : GetScalarType<T[P], VideoCallGroupByOutputType[P]>
        }
      >
    >


  export type VideoCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emissor?: boolean
    destinatario?: boolean
    offer?: boolean
    answer?: boolean
  }, ExtArgs["result"]["videoCall"]>

  export type VideoCallSelectScalar = {
    id?: boolean
    emissor?: boolean
    destinatario?: boolean
    offer?: boolean
    answer?: boolean
  }


  export type $VideoCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoCall"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emissor: string
      destinatario: string
      offer: Prisma.JsonValue | null
      answer: Prisma.JsonValue | null
    }, ExtArgs["result"]["videoCall"]>
    composites: {}
  }


  type VideoCallGetPayload<S extends boolean | null | undefined | VideoCallDefaultArgs> = $Result.GetResult<Prisma.$VideoCallPayload, S>

  type VideoCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoCallFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoCallCountAggregateInputType | true
    }

  export interface VideoCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoCall'], meta: { name: 'VideoCall' } }
    /**
     * Find zero or one VideoCall that matches the filter.
     * @param {VideoCallFindUniqueArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoCallFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VideoCallFindUniqueArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VideoCall that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VideoCallFindUniqueOrThrowArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoCallFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoCallFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VideoCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallFindFirstArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoCallFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoCallFindFirstArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VideoCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallFindFirstOrThrowArgs} args - Arguments to find a VideoCall
     * @example
     * // Get one VideoCall
     * const videoCall = await prisma.videoCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoCallFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoCallFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VideoCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoCalls
     * const videoCalls = await prisma.videoCall.findMany()
     * 
     * // Get first 10 VideoCalls
     * const videoCalls = await prisma.videoCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoCallWithIdOnly = await prisma.videoCall.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoCallFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoCallFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VideoCall.
     * @param {VideoCallCreateArgs} args - Arguments to create a VideoCall.
     * @example
     * // Create one VideoCall
     * const VideoCall = await prisma.videoCall.create({
     *   data: {
     *     // ... data to create a VideoCall
     *   }
     * })
     * 
    **/
    create<T extends VideoCallCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VideoCallCreateArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VideoCalls.
     *     @param {VideoCallCreateManyArgs} args - Arguments to create many VideoCalls.
     *     @example
     *     // Create many VideoCalls
     *     const videoCall = await prisma.videoCall.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCallCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoCallCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VideoCall.
     * @param {VideoCallDeleteArgs} args - Arguments to delete one VideoCall.
     * @example
     * // Delete one VideoCall
     * const VideoCall = await prisma.videoCall.delete({
     *   where: {
     *     // ... filter to delete one VideoCall
     *   }
     * })
     * 
    **/
    delete<T extends VideoCallDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VideoCallDeleteArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VideoCall.
     * @param {VideoCallUpdateArgs} args - Arguments to update one VideoCall.
     * @example
     * // Update one VideoCall
     * const videoCall = await prisma.videoCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoCallUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VideoCallUpdateArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VideoCalls.
     * @param {VideoCallDeleteManyArgs} args - Arguments to filter VideoCalls to delete.
     * @example
     * // Delete a few VideoCalls
     * const { count } = await prisma.videoCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoCallDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VideoCallDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoCalls
     * const videoCall = await prisma.videoCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoCallUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VideoCallUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoCall.
     * @param {VideoCallUpsertArgs} args - Arguments to update or create a VideoCall.
     * @example
     * // Update or create a VideoCall
     * const videoCall = await prisma.videoCall.upsert({
     *   create: {
     *     // ... data to create a VideoCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoCall we want to update
     *   }
     * })
    **/
    upsert<T extends VideoCallUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VideoCallUpsertArgs<ExtArgs>>
    ): Prisma__VideoCallClient<$Result.GetResult<Prisma.$VideoCallPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VideoCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallCountArgs} args - Arguments to filter VideoCalls to count.
     * @example
     * // Count the number of VideoCalls
     * const count = await prisma.videoCall.count({
     *   where: {
     *     // ... the filter for the VideoCalls we want to count
     *   }
     * })
    **/
    count<T extends VideoCallCountArgs>(
      args?: Subset<T, VideoCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoCallAggregateArgs>(args: Subset<T, VideoCallAggregateArgs>): Prisma.PrismaPromise<GetVideoCallAggregateType<T>>

    /**
     * Group by VideoCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoCallGroupByArgs['orderBy'] }
        : { orderBy?: VideoCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoCall model
   */
  readonly fields: VideoCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VideoCall model
   */ 
  interface VideoCallFieldRefs {
    readonly id: FieldRef<"VideoCall", 'String'>
    readonly emissor: FieldRef<"VideoCall", 'String'>
    readonly destinatario: FieldRef<"VideoCall", 'String'>
    readonly offer: FieldRef<"VideoCall", 'Json'>
    readonly answer: FieldRef<"VideoCall", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * VideoCall findUnique
   */
  export type VideoCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where: VideoCallWhereUniqueInput
  }


  /**
   * VideoCall findUniqueOrThrow
   */
  export type VideoCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where: VideoCallWhereUniqueInput
  }


  /**
   * VideoCall findFirst
   */
  export type VideoCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoCalls.
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoCalls.
     */
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }


  /**
   * VideoCall findFirstOrThrow
   */
  export type VideoCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Filter, which VideoCall to fetch.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoCalls.
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoCalls.
     */
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }


  /**
   * VideoCall findMany
   */
  export type VideoCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Filter, which VideoCalls to fetch.
     */
    where?: VideoCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoCalls to fetch.
     */
    orderBy?: VideoCallOrderByWithRelationInput | VideoCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoCalls.
     */
    cursor?: VideoCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoCalls.
     */
    skip?: number
    distinct?: VideoCallScalarFieldEnum | VideoCallScalarFieldEnum[]
  }


  /**
   * VideoCall create
   */
  export type VideoCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * The data needed to create a VideoCall.
     */
    data: XOR<VideoCallCreateInput, VideoCallUncheckedCreateInput>
  }


  /**
   * VideoCall createMany
   */
  export type VideoCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoCalls.
     */
    data: VideoCallCreateManyInput | VideoCallCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * VideoCall update
   */
  export type VideoCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * The data needed to update a VideoCall.
     */
    data: XOR<VideoCallUpdateInput, VideoCallUncheckedUpdateInput>
    /**
     * Choose, which VideoCall to update.
     */
    where: VideoCallWhereUniqueInput
  }


  /**
   * VideoCall updateMany
   */
  export type VideoCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoCalls.
     */
    data: XOR<VideoCallUpdateManyMutationInput, VideoCallUncheckedUpdateManyInput>
    /**
     * Filter which VideoCalls to update
     */
    where?: VideoCallWhereInput
  }


  /**
   * VideoCall upsert
   */
  export type VideoCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * The filter to search for the VideoCall to update in case it exists.
     */
    where: VideoCallWhereUniqueInput
    /**
     * In case the VideoCall found by the `where` argument doesn't exist, create a new VideoCall with this data.
     */
    create: XOR<VideoCallCreateInput, VideoCallUncheckedCreateInput>
    /**
     * In case the VideoCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoCallUpdateInput, VideoCallUncheckedUpdateInput>
  }


  /**
   * VideoCall delete
   */
  export type VideoCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
    /**
     * Filter which VideoCall to delete.
     */
    where: VideoCallWhereUniqueInput
  }


  /**
   * VideoCall deleteMany
   */
  export type VideoCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoCalls to delete
     */
    where?: VideoCallWhereInput
  }


  /**
   * VideoCall without action
   */
  export type VideoCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCall
     */
    select?: VideoCallSelect<ExtArgs> | null
  }



  /**
   * Model MinhasConexoes
   */

  export type AggregateMinhasConexoes = {
    _count: MinhasConexoesCountAggregateOutputType | null
    _min: MinhasConexoesMinAggregateOutputType | null
    _max: MinhasConexoesMaxAggregateOutputType | null
  }

  export type MinhasConexoesMinAggregateOutputType = {
    id: string | null
    userID: string | null
    friendID: string | null
  }

  export type MinhasConexoesMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    friendID: string | null
  }

  export type MinhasConexoesCountAggregateOutputType = {
    id: number
    userID: number
    friendID: number
    _all: number
  }


  export type MinhasConexoesMinAggregateInputType = {
    id?: true
    userID?: true
    friendID?: true
  }

  export type MinhasConexoesMaxAggregateInputType = {
    id?: true
    userID?: true
    friendID?: true
  }

  export type MinhasConexoesCountAggregateInputType = {
    id?: true
    userID?: true
    friendID?: true
    _all?: true
  }

  export type MinhasConexoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinhasConexoes to aggregate.
     */
    where?: MinhasConexoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinhasConexoes to fetch.
     */
    orderBy?: MinhasConexoesOrderByWithRelationInput | MinhasConexoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MinhasConexoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinhasConexoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinhasConexoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MinhasConexoes
    **/
    _count?: true | MinhasConexoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinhasConexoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinhasConexoesMaxAggregateInputType
  }

  export type GetMinhasConexoesAggregateType<T extends MinhasConexoesAggregateArgs> = {
        [P in keyof T & keyof AggregateMinhasConexoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinhasConexoes[P]>
      : GetScalarType<T[P], AggregateMinhasConexoes[P]>
  }




  export type MinhasConexoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinhasConexoesWhereInput
    orderBy?: MinhasConexoesOrderByWithAggregationInput | MinhasConexoesOrderByWithAggregationInput[]
    by: MinhasConexoesScalarFieldEnum[] | MinhasConexoesScalarFieldEnum
    having?: MinhasConexoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinhasConexoesCountAggregateInputType | true
    _min?: MinhasConexoesMinAggregateInputType
    _max?: MinhasConexoesMaxAggregateInputType
  }

  export type MinhasConexoesGroupByOutputType = {
    id: string
    userID: string
    friendID: string
    _count: MinhasConexoesCountAggregateOutputType | null
    _min: MinhasConexoesMinAggregateOutputType | null
    _max: MinhasConexoesMaxAggregateOutputType | null
  }

  type GetMinhasConexoesGroupByPayload<T extends MinhasConexoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinhasConexoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinhasConexoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinhasConexoesGroupByOutputType[P]>
            : GetScalarType<T[P], MinhasConexoesGroupByOutputType[P]>
        }
      >
    >


  export type MinhasConexoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    friendID?: boolean
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
    friend?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minhasConexoes"]>

  export type MinhasConexoesSelectScalar = {
    id?: boolean
    userID?: boolean
    friendID?: boolean
  }

  export type MinhasConexoesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
    friend?: boolean | UsuariosDefaultArgs<ExtArgs>
  }


  export type $MinhasConexoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MinhasConexoes"
    objects: {
      user: Prisma.$UsuariosPayload<ExtArgs>
      friend: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      friendID: string
    }, ExtArgs["result"]["minhasConexoes"]>
    composites: {}
  }


  type MinhasConexoesGetPayload<S extends boolean | null | undefined | MinhasConexoesDefaultArgs> = $Result.GetResult<Prisma.$MinhasConexoesPayload, S>

  type MinhasConexoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MinhasConexoesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MinhasConexoesCountAggregateInputType | true
    }

  export interface MinhasConexoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MinhasConexoes'], meta: { name: 'MinhasConexoes' } }
    /**
     * Find zero or one MinhasConexoes that matches the filter.
     * @param {MinhasConexoesFindUniqueArgs} args - Arguments to find a MinhasConexoes
     * @example
     * // Get one MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MinhasConexoesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MinhasConexoesFindUniqueArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MinhasConexoes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MinhasConexoesFindUniqueOrThrowArgs} args - Arguments to find a MinhasConexoes
     * @example
     * // Get one MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MinhasConexoesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MinhasConexoesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MinhasConexoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinhasConexoesFindFirstArgs} args - Arguments to find a MinhasConexoes
     * @example
     * // Get one MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MinhasConexoesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MinhasConexoesFindFirstArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MinhasConexoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinhasConexoesFindFirstOrThrowArgs} args - Arguments to find a MinhasConexoes
     * @example
     * // Get one MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MinhasConexoesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MinhasConexoesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MinhasConexoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinhasConexoesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.findMany()
     * 
     * // Get first 10 MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const minhasConexoesWithIdOnly = await prisma.minhasConexoes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MinhasConexoesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MinhasConexoesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MinhasConexoes.
     * @param {MinhasConexoesCreateArgs} args - Arguments to create a MinhasConexoes.
     * @example
     * // Create one MinhasConexoes
     * const MinhasConexoes = await prisma.minhasConexoes.create({
     *   data: {
     *     // ... data to create a MinhasConexoes
     *   }
     * })
     * 
    **/
    create<T extends MinhasConexoesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MinhasConexoesCreateArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MinhasConexoes.
     *     @param {MinhasConexoesCreateManyArgs} args - Arguments to create many MinhasConexoes.
     *     @example
     *     // Create many MinhasConexoes
     *     const minhasConexoes = await prisma.minhasConexoes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MinhasConexoesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MinhasConexoesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MinhasConexoes.
     * @param {MinhasConexoesDeleteArgs} args - Arguments to delete one MinhasConexoes.
     * @example
     * // Delete one MinhasConexoes
     * const MinhasConexoes = await prisma.minhasConexoes.delete({
     *   where: {
     *     // ... filter to delete one MinhasConexoes
     *   }
     * })
     * 
    **/
    delete<T extends MinhasConexoesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MinhasConexoesDeleteArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MinhasConexoes.
     * @param {MinhasConexoesUpdateArgs} args - Arguments to update one MinhasConexoes.
     * @example
     * // Update one MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MinhasConexoesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MinhasConexoesUpdateArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MinhasConexoes.
     * @param {MinhasConexoesDeleteManyArgs} args - Arguments to filter MinhasConexoes to delete.
     * @example
     * // Delete a few MinhasConexoes
     * const { count } = await prisma.minhasConexoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MinhasConexoesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MinhasConexoesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MinhasConexoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinhasConexoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MinhasConexoesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MinhasConexoesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MinhasConexoes.
     * @param {MinhasConexoesUpsertArgs} args - Arguments to update or create a MinhasConexoes.
     * @example
     * // Update or create a MinhasConexoes
     * const minhasConexoes = await prisma.minhasConexoes.upsert({
     *   create: {
     *     // ... data to create a MinhasConexoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MinhasConexoes we want to update
     *   }
     * })
    **/
    upsert<T extends MinhasConexoesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MinhasConexoesUpsertArgs<ExtArgs>>
    ): Prisma__MinhasConexoesClient<$Result.GetResult<Prisma.$MinhasConexoesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MinhasConexoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinhasConexoesCountArgs} args - Arguments to filter MinhasConexoes to count.
     * @example
     * // Count the number of MinhasConexoes
     * const count = await prisma.minhasConexoes.count({
     *   where: {
     *     // ... the filter for the MinhasConexoes we want to count
     *   }
     * })
    **/
    count<T extends MinhasConexoesCountArgs>(
      args?: Subset<T, MinhasConexoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinhasConexoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MinhasConexoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinhasConexoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinhasConexoesAggregateArgs>(args: Subset<T, MinhasConexoesAggregateArgs>): Prisma.PrismaPromise<GetMinhasConexoesAggregateType<T>>

    /**
     * Group by MinhasConexoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinhasConexoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MinhasConexoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinhasConexoesGroupByArgs['orderBy'] }
        : { orderBy?: MinhasConexoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MinhasConexoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinhasConexoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MinhasConexoes model
   */
  readonly fields: MinhasConexoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MinhasConexoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinhasConexoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    friend<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MinhasConexoes model
   */ 
  interface MinhasConexoesFieldRefs {
    readonly id: FieldRef<"MinhasConexoes", 'String'>
    readonly userID: FieldRef<"MinhasConexoes", 'String'>
    readonly friendID: FieldRef<"MinhasConexoes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MinhasConexoes findUnique
   */
  export type MinhasConexoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * Filter, which MinhasConexoes to fetch.
     */
    where: MinhasConexoesWhereUniqueInput
  }


  /**
   * MinhasConexoes findUniqueOrThrow
   */
  export type MinhasConexoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * Filter, which MinhasConexoes to fetch.
     */
    where: MinhasConexoesWhereUniqueInput
  }


  /**
   * MinhasConexoes findFirst
   */
  export type MinhasConexoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * Filter, which MinhasConexoes to fetch.
     */
    where?: MinhasConexoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinhasConexoes to fetch.
     */
    orderBy?: MinhasConexoesOrderByWithRelationInput | MinhasConexoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinhasConexoes.
     */
    cursor?: MinhasConexoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinhasConexoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinhasConexoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinhasConexoes.
     */
    distinct?: MinhasConexoesScalarFieldEnum | MinhasConexoesScalarFieldEnum[]
  }


  /**
   * MinhasConexoes findFirstOrThrow
   */
  export type MinhasConexoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * Filter, which MinhasConexoes to fetch.
     */
    where?: MinhasConexoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinhasConexoes to fetch.
     */
    orderBy?: MinhasConexoesOrderByWithRelationInput | MinhasConexoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinhasConexoes.
     */
    cursor?: MinhasConexoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinhasConexoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinhasConexoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinhasConexoes.
     */
    distinct?: MinhasConexoesScalarFieldEnum | MinhasConexoesScalarFieldEnum[]
  }


  /**
   * MinhasConexoes findMany
   */
  export type MinhasConexoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * Filter, which MinhasConexoes to fetch.
     */
    where?: MinhasConexoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinhasConexoes to fetch.
     */
    orderBy?: MinhasConexoesOrderByWithRelationInput | MinhasConexoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MinhasConexoes.
     */
    cursor?: MinhasConexoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinhasConexoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinhasConexoes.
     */
    skip?: number
    distinct?: MinhasConexoesScalarFieldEnum | MinhasConexoesScalarFieldEnum[]
  }


  /**
   * MinhasConexoes create
   */
  export type MinhasConexoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * The data needed to create a MinhasConexoes.
     */
    data: XOR<MinhasConexoesCreateInput, MinhasConexoesUncheckedCreateInput>
  }


  /**
   * MinhasConexoes createMany
   */
  export type MinhasConexoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MinhasConexoes.
     */
    data: MinhasConexoesCreateManyInput | MinhasConexoesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MinhasConexoes update
   */
  export type MinhasConexoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * The data needed to update a MinhasConexoes.
     */
    data: XOR<MinhasConexoesUpdateInput, MinhasConexoesUncheckedUpdateInput>
    /**
     * Choose, which MinhasConexoes to update.
     */
    where: MinhasConexoesWhereUniqueInput
  }


  /**
   * MinhasConexoes updateMany
   */
  export type MinhasConexoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MinhasConexoes.
     */
    data: XOR<MinhasConexoesUpdateManyMutationInput, MinhasConexoesUncheckedUpdateManyInput>
    /**
     * Filter which MinhasConexoes to update
     */
    where?: MinhasConexoesWhereInput
  }


  /**
   * MinhasConexoes upsert
   */
  export type MinhasConexoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * The filter to search for the MinhasConexoes to update in case it exists.
     */
    where: MinhasConexoesWhereUniqueInput
    /**
     * In case the MinhasConexoes found by the `where` argument doesn't exist, create a new MinhasConexoes with this data.
     */
    create: XOR<MinhasConexoesCreateInput, MinhasConexoesUncheckedCreateInput>
    /**
     * In case the MinhasConexoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinhasConexoesUpdateInput, MinhasConexoesUncheckedUpdateInput>
  }


  /**
   * MinhasConexoes delete
   */
  export type MinhasConexoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
    /**
     * Filter which MinhasConexoes to delete.
     */
    where: MinhasConexoesWhereUniqueInput
  }


  /**
   * MinhasConexoes deleteMany
   */
  export type MinhasConexoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinhasConexoes to delete
     */
    where?: MinhasConexoesWhereInput
  }


  /**
   * MinhasConexoes without action
   */
  export type MinhasConexoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinhasConexoes
     */
    select?: MinhasConexoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MinhasConexoesInclude<ExtArgs> | null
  }



  /**
   * Model PedidoDeConexao
   */

  export type AggregatePedidoDeConexao = {
    _count: PedidoDeConexaoCountAggregateOutputType | null
    _min: PedidoDeConexaoMinAggregateOutputType | null
    _max: PedidoDeConexaoMaxAggregateOutputType | null
  }

  export type PedidoDeConexaoMinAggregateOutputType = {
    id: string | null
    userID: string | null
    destinatarioID: string | null
  }

  export type PedidoDeConexaoMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    destinatarioID: string | null
  }

  export type PedidoDeConexaoCountAggregateOutputType = {
    id: number
    userID: number
    destinatarioID: number
    _all: number
  }


  export type PedidoDeConexaoMinAggregateInputType = {
    id?: true
    userID?: true
    destinatarioID?: true
  }

  export type PedidoDeConexaoMaxAggregateInputType = {
    id?: true
    userID?: true
    destinatarioID?: true
  }

  export type PedidoDeConexaoCountAggregateInputType = {
    id?: true
    userID?: true
    destinatarioID?: true
    _all?: true
  }

  export type PedidoDeConexaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoDeConexao to aggregate.
     */
    where?: PedidoDeConexaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoDeConexaos to fetch.
     */
    orderBy?: PedidoDeConexaoOrderByWithRelationInput | PedidoDeConexaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoDeConexaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoDeConexaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoDeConexaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoDeConexaos
    **/
    _count?: true | PedidoDeConexaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoDeConexaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoDeConexaoMaxAggregateInputType
  }

  export type GetPedidoDeConexaoAggregateType<T extends PedidoDeConexaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoDeConexao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoDeConexao[P]>
      : GetScalarType<T[P], AggregatePedidoDeConexao[P]>
  }




  export type PedidoDeConexaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoDeConexaoWhereInput
    orderBy?: PedidoDeConexaoOrderByWithAggregationInput | PedidoDeConexaoOrderByWithAggregationInput[]
    by: PedidoDeConexaoScalarFieldEnum[] | PedidoDeConexaoScalarFieldEnum
    having?: PedidoDeConexaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoDeConexaoCountAggregateInputType | true
    _min?: PedidoDeConexaoMinAggregateInputType
    _max?: PedidoDeConexaoMaxAggregateInputType
  }

  export type PedidoDeConexaoGroupByOutputType = {
    id: string
    userID: string
    destinatarioID: string
    _count: PedidoDeConexaoCountAggregateOutputType | null
    _min: PedidoDeConexaoMinAggregateOutputType | null
    _max: PedidoDeConexaoMaxAggregateOutputType | null
  }

  type GetPedidoDeConexaoGroupByPayload<T extends PedidoDeConexaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoDeConexaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoDeConexaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoDeConexaoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoDeConexaoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoDeConexaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    destinatarioID?: boolean
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
    destinatario?: boolean | UsuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoDeConexao"]>

  export type PedidoDeConexaoSelectScalar = {
    id?: boolean
    userID?: boolean
    destinatarioID?: boolean
  }

  export type PedidoDeConexaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
    destinatario?: boolean | UsuariosDefaultArgs<ExtArgs>
  }


  export type $PedidoDeConexaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PedidoDeConexao"
    objects: {
      user: Prisma.$UsuariosPayload<ExtArgs>
      destinatario: Prisma.$UsuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      destinatarioID: string
    }, ExtArgs["result"]["pedidoDeConexao"]>
    composites: {}
  }


  type PedidoDeConexaoGetPayload<S extends boolean | null | undefined | PedidoDeConexaoDefaultArgs> = $Result.GetResult<Prisma.$PedidoDeConexaoPayload, S>

  type PedidoDeConexaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoDeConexaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoDeConexaoCountAggregateInputType | true
    }

  export interface PedidoDeConexaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PedidoDeConexao'], meta: { name: 'PedidoDeConexao' } }
    /**
     * Find zero or one PedidoDeConexao that matches the filter.
     * @param {PedidoDeConexaoFindUniqueArgs} args - Arguments to find a PedidoDeConexao
     * @example
     * // Get one PedidoDeConexao
     * const pedidoDeConexao = await prisma.pedidoDeConexao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoDeConexaoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeConexaoFindUniqueArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PedidoDeConexao that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PedidoDeConexaoFindUniqueOrThrowArgs} args - Arguments to find a PedidoDeConexao
     * @example
     * // Get one PedidoDeConexao
     * const pedidoDeConexao = await prisma.pedidoDeConexao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoDeConexaoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeConexaoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PedidoDeConexao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoDeConexaoFindFirstArgs} args - Arguments to find a PedidoDeConexao
     * @example
     * // Get one PedidoDeConexao
     * const pedidoDeConexao = await prisma.pedidoDeConexao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoDeConexaoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeConexaoFindFirstArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PedidoDeConexao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoDeConexaoFindFirstOrThrowArgs} args - Arguments to find a PedidoDeConexao
     * @example
     * // Get one PedidoDeConexao
     * const pedidoDeConexao = await prisma.pedidoDeConexao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoDeConexaoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeConexaoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PedidoDeConexaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoDeConexaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoDeConexaos
     * const pedidoDeConexaos = await prisma.pedidoDeConexao.findMany()
     * 
     * // Get first 10 PedidoDeConexaos
     * const pedidoDeConexaos = await prisma.pedidoDeConexao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoDeConexaoWithIdOnly = await prisma.pedidoDeConexao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoDeConexaoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeConexaoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PedidoDeConexao.
     * @param {PedidoDeConexaoCreateArgs} args - Arguments to create a PedidoDeConexao.
     * @example
     * // Create one PedidoDeConexao
     * const PedidoDeConexao = await prisma.pedidoDeConexao.create({
     *   data: {
     *     // ... data to create a PedidoDeConexao
     *   }
     * })
     * 
    **/
    create<T extends PedidoDeConexaoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeConexaoCreateArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PedidoDeConexaos.
     *     @param {PedidoDeConexaoCreateManyArgs} args - Arguments to create many PedidoDeConexaos.
     *     @example
     *     // Create many PedidoDeConexaos
     *     const pedidoDeConexao = await prisma.pedidoDeConexao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoDeConexaoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeConexaoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PedidoDeConexao.
     * @param {PedidoDeConexaoDeleteArgs} args - Arguments to delete one PedidoDeConexao.
     * @example
     * // Delete one PedidoDeConexao
     * const PedidoDeConexao = await prisma.pedidoDeConexao.delete({
     *   where: {
     *     // ... filter to delete one PedidoDeConexao
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeConexaoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeConexaoDeleteArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PedidoDeConexao.
     * @param {PedidoDeConexaoUpdateArgs} args - Arguments to update one PedidoDeConexao.
     * @example
     * // Update one PedidoDeConexao
     * const pedidoDeConexao = await prisma.pedidoDeConexao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoDeConexaoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeConexaoUpdateArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PedidoDeConexaos.
     * @param {PedidoDeConexaoDeleteManyArgs} args - Arguments to filter PedidoDeConexaos to delete.
     * @example
     * // Delete a few PedidoDeConexaos
     * const { count } = await prisma.pedidoDeConexao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeConexaoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PedidoDeConexaoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoDeConexaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoDeConexaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoDeConexaos
     * const pedidoDeConexao = await prisma.pedidoDeConexao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoDeConexaoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeConexaoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PedidoDeConexao.
     * @param {PedidoDeConexaoUpsertArgs} args - Arguments to update or create a PedidoDeConexao.
     * @example
     * // Update or create a PedidoDeConexao
     * const pedidoDeConexao = await prisma.pedidoDeConexao.upsert({
     *   create: {
     *     // ... data to create a PedidoDeConexao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoDeConexao we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoDeConexaoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PedidoDeConexaoUpsertArgs<ExtArgs>>
    ): Prisma__PedidoDeConexaoClient<$Result.GetResult<Prisma.$PedidoDeConexaoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PedidoDeConexaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoDeConexaoCountArgs} args - Arguments to filter PedidoDeConexaos to count.
     * @example
     * // Count the number of PedidoDeConexaos
     * const count = await prisma.pedidoDeConexao.count({
     *   where: {
     *     // ... the filter for the PedidoDeConexaos we want to count
     *   }
     * })
    **/
    count<T extends PedidoDeConexaoCountArgs>(
      args?: Subset<T, PedidoDeConexaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoDeConexaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoDeConexao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoDeConexaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoDeConexaoAggregateArgs>(args: Subset<T, PedidoDeConexaoAggregateArgs>): Prisma.PrismaPromise<GetPedidoDeConexaoAggregateType<T>>

    /**
     * Group by PedidoDeConexao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoDeConexaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoDeConexaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoDeConexaoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoDeConexaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoDeConexaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoDeConexaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PedidoDeConexao model
   */
  readonly fields: PedidoDeConexaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoDeConexao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoDeConexaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    destinatario<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PedidoDeConexao model
   */ 
  interface PedidoDeConexaoFieldRefs {
    readonly id: FieldRef<"PedidoDeConexao", 'String'>
    readonly userID: FieldRef<"PedidoDeConexao", 'String'>
    readonly destinatarioID: FieldRef<"PedidoDeConexao", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PedidoDeConexao findUnique
   */
  export type PedidoDeConexaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoDeConexao to fetch.
     */
    where: PedidoDeConexaoWhereUniqueInput
  }


  /**
   * PedidoDeConexao findUniqueOrThrow
   */
  export type PedidoDeConexaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoDeConexao to fetch.
     */
    where: PedidoDeConexaoWhereUniqueInput
  }


  /**
   * PedidoDeConexao findFirst
   */
  export type PedidoDeConexaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoDeConexao to fetch.
     */
    where?: PedidoDeConexaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoDeConexaos to fetch.
     */
    orderBy?: PedidoDeConexaoOrderByWithRelationInput | PedidoDeConexaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoDeConexaos.
     */
    cursor?: PedidoDeConexaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoDeConexaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoDeConexaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoDeConexaos.
     */
    distinct?: PedidoDeConexaoScalarFieldEnum | PedidoDeConexaoScalarFieldEnum[]
  }


  /**
   * PedidoDeConexao findFirstOrThrow
   */
  export type PedidoDeConexaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoDeConexao to fetch.
     */
    where?: PedidoDeConexaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoDeConexaos to fetch.
     */
    orderBy?: PedidoDeConexaoOrderByWithRelationInput | PedidoDeConexaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoDeConexaos.
     */
    cursor?: PedidoDeConexaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoDeConexaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoDeConexaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoDeConexaos.
     */
    distinct?: PedidoDeConexaoScalarFieldEnum | PedidoDeConexaoScalarFieldEnum[]
  }


  /**
   * PedidoDeConexao findMany
   */
  export type PedidoDeConexaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoDeConexaos to fetch.
     */
    where?: PedidoDeConexaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoDeConexaos to fetch.
     */
    orderBy?: PedidoDeConexaoOrderByWithRelationInput | PedidoDeConexaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoDeConexaos.
     */
    cursor?: PedidoDeConexaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoDeConexaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoDeConexaos.
     */
    skip?: number
    distinct?: PedidoDeConexaoScalarFieldEnum | PedidoDeConexaoScalarFieldEnum[]
  }


  /**
   * PedidoDeConexao create
   */
  export type PedidoDeConexaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * The data needed to create a PedidoDeConexao.
     */
    data: XOR<PedidoDeConexaoCreateInput, PedidoDeConexaoUncheckedCreateInput>
  }


  /**
   * PedidoDeConexao createMany
   */
  export type PedidoDeConexaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PedidoDeConexaos.
     */
    data: PedidoDeConexaoCreateManyInput | PedidoDeConexaoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PedidoDeConexao update
   */
  export type PedidoDeConexaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * The data needed to update a PedidoDeConexao.
     */
    data: XOR<PedidoDeConexaoUpdateInput, PedidoDeConexaoUncheckedUpdateInput>
    /**
     * Choose, which PedidoDeConexao to update.
     */
    where: PedidoDeConexaoWhereUniqueInput
  }


  /**
   * PedidoDeConexao updateMany
   */
  export type PedidoDeConexaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PedidoDeConexaos.
     */
    data: XOR<PedidoDeConexaoUpdateManyMutationInput, PedidoDeConexaoUncheckedUpdateManyInput>
    /**
     * Filter which PedidoDeConexaos to update
     */
    where?: PedidoDeConexaoWhereInput
  }


  /**
   * PedidoDeConexao upsert
   */
  export type PedidoDeConexaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * The filter to search for the PedidoDeConexao to update in case it exists.
     */
    where: PedidoDeConexaoWhereUniqueInput
    /**
     * In case the PedidoDeConexao found by the `where` argument doesn't exist, create a new PedidoDeConexao with this data.
     */
    create: XOR<PedidoDeConexaoCreateInput, PedidoDeConexaoUncheckedCreateInput>
    /**
     * In case the PedidoDeConexao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoDeConexaoUpdateInput, PedidoDeConexaoUncheckedUpdateInput>
  }


  /**
   * PedidoDeConexao delete
   */
  export type PedidoDeConexaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
    /**
     * Filter which PedidoDeConexao to delete.
     */
    where: PedidoDeConexaoWhereUniqueInput
  }


  /**
   * PedidoDeConexao deleteMany
   */
  export type PedidoDeConexaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoDeConexaos to delete
     */
    where?: PedidoDeConexaoWhereInput
  }


  /**
   * PedidoDeConexao without action
   */
  export type PedidoDeConexaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoDeConexao
     */
    select?: PedidoDeConexaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PedidoDeConexaoInclude<ExtArgs> | null
  }



  /**
   * Model Partilha
   */

  export type AggregatePartilha = {
    _count: PartilhaCountAggregateOutputType | null
    _min: PartilhaMinAggregateOutputType | null
    _max: PartilhaMaxAggregateOutputType | null
  }

  export type PartilhaMinAggregateOutputType = {
    id: string | null
    userID: string | null
    createPostShareID: string | null
    postShareID: string | null
    createdAt: Date | null
  }

  export type PartilhaMaxAggregateOutputType = {
    id: string | null
    userID: string | null
    createPostShareID: string | null
    postShareID: string | null
    createdAt: Date | null
  }

  export type PartilhaCountAggregateOutputType = {
    id: number
    userID: number
    createPostShareID: number
    postShareID: number
    createdAt: number
    _all: number
  }


  export type PartilhaMinAggregateInputType = {
    id?: true
    userID?: true
    createPostShareID?: true
    postShareID?: true
    createdAt?: true
  }

  export type PartilhaMaxAggregateInputType = {
    id?: true
    userID?: true
    createPostShareID?: true
    postShareID?: true
    createdAt?: true
  }

  export type PartilhaCountAggregateInputType = {
    id?: true
    userID?: true
    createPostShareID?: true
    postShareID?: true
    createdAt?: true
    _all?: true
  }

  export type PartilhaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partilha to aggregate.
     */
    where?: PartilhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partilhas to fetch.
     */
    orderBy?: PartilhaOrderByWithRelationInput | PartilhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartilhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partilhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partilhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partilhas
    **/
    _count?: true | PartilhaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartilhaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartilhaMaxAggregateInputType
  }

  export type GetPartilhaAggregateType<T extends PartilhaAggregateArgs> = {
        [P in keyof T & keyof AggregatePartilha]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartilha[P]>
      : GetScalarType<T[P], AggregatePartilha[P]>
  }




  export type PartilhaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartilhaWhereInput
    orderBy?: PartilhaOrderByWithAggregationInput | PartilhaOrderByWithAggregationInput[]
    by: PartilhaScalarFieldEnum[] | PartilhaScalarFieldEnum
    having?: PartilhaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartilhaCountAggregateInputType | true
    _min?: PartilhaMinAggregateInputType
    _max?: PartilhaMaxAggregateInputType
  }

  export type PartilhaGroupByOutputType = {
    id: string
    userID: string
    createPostShareID: string
    postShareID: string
    createdAt: Date
    _count: PartilhaCountAggregateOutputType | null
    _min: PartilhaMinAggregateOutputType | null
    _max: PartilhaMaxAggregateOutputType | null
  }

  type GetPartilhaGroupByPayload<T extends PartilhaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartilhaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartilhaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartilhaGroupByOutputType[P]>
            : GetScalarType<T[P], PartilhaGroupByOutputType[P]>
        }
      >
    >


  export type PartilhaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userID?: boolean
    createPostShareID?: boolean
    postShareID?: boolean
    createdAt?: boolean
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    postShare?: boolean | PublicacoesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partilha"]>

  export type PartilhaSelectScalar = {
    id?: boolean
    userID?: boolean
    createPostShareID?: boolean
    postShareID?: boolean
    createdAt?: boolean
  }

  export type PartilhaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsuariosDefaultArgs<ExtArgs>
    post?: boolean | PublicacoesDefaultArgs<ExtArgs>
    postShare?: boolean | PublicacoesDefaultArgs<ExtArgs>
  }


  export type $PartilhaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partilha"
    objects: {
      user: Prisma.$UsuariosPayload<ExtArgs>
      post: Prisma.$PublicacoesPayload<ExtArgs>
      postShare: Prisma.$PublicacoesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userID: string
      createPostShareID: string
      postShareID: string
      createdAt: Date
    }, ExtArgs["result"]["partilha"]>
    composites: {}
  }


  type PartilhaGetPayload<S extends boolean | null | undefined | PartilhaDefaultArgs> = $Result.GetResult<Prisma.$PartilhaPayload, S>

  type PartilhaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartilhaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartilhaCountAggregateInputType | true
    }

  export interface PartilhaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partilha'], meta: { name: 'Partilha' } }
    /**
     * Find zero or one Partilha that matches the filter.
     * @param {PartilhaFindUniqueArgs} args - Arguments to find a Partilha
     * @example
     * // Get one Partilha
     * const partilha = await prisma.partilha.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartilhaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartilhaFindUniqueArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Partilha that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartilhaFindUniqueOrThrowArgs} args - Arguments to find a Partilha
     * @example
     * // Get one Partilha
     * const partilha = await prisma.partilha.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartilhaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartilhaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Partilha that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartilhaFindFirstArgs} args - Arguments to find a Partilha
     * @example
     * // Get one Partilha
     * const partilha = await prisma.partilha.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartilhaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartilhaFindFirstArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Partilha that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartilhaFindFirstOrThrowArgs} args - Arguments to find a Partilha
     * @example
     * // Get one Partilha
     * const partilha = await prisma.partilha.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartilhaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartilhaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Partilhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartilhaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partilhas
     * const partilhas = await prisma.partilha.findMany()
     * 
     * // Get first 10 Partilhas
     * const partilhas = await prisma.partilha.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partilhaWithIdOnly = await prisma.partilha.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartilhaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartilhaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Partilha.
     * @param {PartilhaCreateArgs} args - Arguments to create a Partilha.
     * @example
     * // Create one Partilha
     * const Partilha = await prisma.partilha.create({
     *   data: {
     *     // ... data to create a Partilha
     *   }
     * })
     * 
    **/
    create<T extends PartilhaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartilhaCreateArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Partilhas.
     *     @param {PartilhaCreateManyArgs} args - Arguments to create many Partilhas.
     *     @example
     *     // Create many Partilhas
     *     const partilha = await prisma.partilha.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartilhaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartilhaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Partilha.
     * @param {PartilhaDeleteArgs} args - Arguments to delete one Partilha.
     * @example
     * // Delete one Partilha
     * const Partilha = await prisma.partilha.delete({
     *   where: {
     *     // ... filter to delete one Partilha
     *   }
     * })
     * 
    **/
    delete<T extends PartilhaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartilhaDeleteArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Partilha.
     * @param {PartilhaUpdateArgs} args - Arguments to update one Partilha.
     * @example
     * // Update one Partilha
     * const partilha = await prisma.partilha.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartilhaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartilhaUpdateArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Partilhas.
     * @param {PartilhaDeleteManyArgs} args - Arguments to filter Partilhas to delete.
     * @example
     * // Delete a few Partilhas
     * const { count } = await prisma.partilha.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartilhaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartilhaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partilhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartilhaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partilhas
     * const partilha = await prisma.partilha.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartilhaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartilhaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partilha.
     * @param {PartilhaUpsertArgs} args - Arguments to update or create a Partilha.
     * @example
     * // Update or create a Partilha
     * const partilha = await prisma.partilha.upsert({
     *   create: {
     *     // ... data to create a Partilha
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partilha we want to update
     *   }
     * })
    **/
    upsert<T extends PartilhaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartilhaUpsertArgs<ExtArgs>>
    ): Prisma__PartilhaClient<$Result.GetResult<Prisma.$PartilhaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Partilhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartilhaCountArgs} args - Arguments to filter Partilhas to count.
     * @example
     * // Count the number of Partilhas
     * const count = await prisma.partilha.count({
     *   where: {
     *     // ... the filter for the Partilhas we want to count
     *   }
     * })
    **/
    count<T extends PartilhaCountArgs>(
      args?: Subset<T, PartilhaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartilhaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partilha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartilhaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartilhaAggregateArgs>(args: Subset<T, PartilhaAggregateArgs>): Prisma.PrismaPromise<GetPartilhaAggregateType<T>>

    /**
     * Group by Partilha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartilhaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartilhaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartilhaGroupByArgs['orderBy'] }
        : { orderBy?: PartilhaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartilhaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartilhaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partilha model
   */
  readonly fields: PartilhaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partilha.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartilhaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UsuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuariosDefaultArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    post<T extends PublicacoesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicacoesDefaultArgs<ExtArgs>>): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    postShare<T extends PublicacoesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicacoesDefaultArgs<ExtArgs>>): Prisma__PublicacoesClient<$Result.GetResult<Prisma.$PublicacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Partilha model
   */ 
  interface PartilhaFieldRefs {
    readonly id: FieldRef<"Partilha", 'String'>
    readonly userID: FieldRef<"Partilha", 'String'>
    readonly createPostShareID: FieldRef<"Partilha", 'String'>
    readonly postShareID: FieldRef<"Partilha", 'String'>
    readonly createdAt: FieldRef<"Partilha", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Partilha findUnique
   */
  export type PartilhaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * Filter, which Partilha to fetch.
     */
    where: PartilhaWhereUniqueInput
  }


  /**
   * Partilha findUniqueOrThrow
   */
  export type PartilhaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * Filter, which Partilha to fetch.
     */
    where: PartilhaWhereUniqueInput
  }


  /**
   * Partilha findFirst
   */
  export type PartilhaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * Filter, which Partilha to fetch.
     */
    where?: PartilhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partilhas to fetch.
     */
    orderBy?: PartilhaOrderByWithRelationInput | PartilhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partilhas.
     */
    cursor?: PartilhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partilhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partilhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partilhas.
     */
    distinct?: PartilhaScalarFieldEnum | PartilhaScalarFieldEnum[]
  }


  /**
   * Partilha findFirstOrThrow
   */
  export type PartilhaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * Filter, which Partilha to fetch.
     */
    where?: PartilhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partilhas to fetch.
     */
    orderBy?: PartilhaOrderByWithRelationInput | PartilhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partilhas.
     */
    cursor?: PartilhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partilhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partilhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partilhas.
     */
    distinct?: PartilhaScalarFieldEnum | PartilhaScalarFieldEnum[]
  }


  /**
   * Partilha findMany
   */
  export type PartilhaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * Filter, which Partilhas to fetch.
     */
    where?: PartilhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partilhas to fetch.
     */
    orderBy?: PartilhaOrderByWithRelationInput | PartilhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partilhas.
     */
    cursor?: PartilhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partilhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partilhas.
     */
    skip?: number
    distinct?: PartilhaScalarFieldEnum | PartilhaScalarFieldEnum[]
  }


  /**
   * Partilha create
   */
  export type PartilhaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * The data needed to create a Partilha.
     */
    data: XOR<PartilhaCreateInput, PartilhaUncheckedCreateInput>
  }


  /**
   * Partilha createMany
   */
  export type PartilhaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partilhas.
     */
    data: PartilhaCreateManyInput | PartilhaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Partilha update
   */
  export type PartilhaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * The data needed to update a Partilha.
     */
    data: XOR<PartilhaUpdateInput, PartilhaUncheckedUpdateInput>
    /**
     * Choose, which Partilha to update.
     */
    where: PartilhaWhereUniqueInput
  }


  /**
   * Partilha updateMany
   */
  export type PartilhaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partilhas.
     */
    data: XOR<PartilhaUpdateManyMutationInput, PartilhaUncheckedUpdateManyInput>
    /**
     * Filter which Partilhas to update
     */
    where?: PartilhaWhereInput
  }


  /**
   * Partilha upsert
   */
  export type PartilhaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * The filter to search for the Partilha to update in case it exists.
     */
    where: PartilhaWhereUniqueInput
    /**
     * In case the Partilha found by the `where` argument doesn't exist, create a new Partilha with this data.
     */
    create: XOR<PartilhaCreateInput, PartilhaUncheckedCreateInput>
    /**
     * In case the Partilha was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartilhaUpdateInput, PartilhaUncheckedUpdateInput>
  }


  /**
   * Partilha delete
   */
  export type PartilhaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
    /**
     * Filter which Partilha to delete.
     */
    where: PartilhaWhereUniqueInput
  }


  /**
   * Partilha deleteMany
   */
  export type PartilhaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partilhas to delete
     */
    where?: PartilhaWhereInput
  }


  /**
   * Partilha without action
   */
  export type PartilhaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partilha
     */
    select?: PartilhaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartilhaInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EntidadesSistemaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cnpj: 'cnpj',
    tipo_entidade: 'tipo_entidade',
    sobre: 'sobre',
    email: 'email',
    foto: 'foto',
    enderecoID: 'enderecoID'
  };

  export type EntidadesSistemaScalarFieldEnum = (typeof EntidadesSistemaScalarFieldEnum)[keyof typeof EntidadesSistemaScalarFieldEnum]


  export const EnderecoScalarFieldEnum: {
    id: 'id',
    adress: 'adress'
  };

  export type EnderecoScalarFieldEnum = (typeof EnderecoScalarFieldEnum)[keyof typeof EnderecoScalarFieldEnum]


  export const ContactosScalarFieldEnum: {
    id: 'id',
    contacto: 'contacto',
    entidadeID: 'entidadeID',
    usuarioID: 'usuarioID'
  };

  export type ContactosScalarFieldEnum = (typeof ContactosScalarFieldEnum)[keyof typeof ContactosScalarFieldEnum]


  export const EspecialistasScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    crm: 'crm',
    especialidade: 'especialidade',
    tipo_De_Consulta: 'tipo_De_Consulta',
    valor: 'valor',
    bloqueado: 'bloqueado',
    sexo: 'sexo',
    entidadeID: 'entidadeID'
  };

  export type EspecialistasScalarFieldEnum = (typeof EspecialistasScalarFieldEnum)[keyof typeof EspecialistasScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    crm: 'crm',
    cnpj: 'cnpj',
    foto: 'foto',
    senha: 'senha',
    sobre: 'sobre',
    sexo: 'sexo',
    socketID: 'socketID',
    nascimento: 'nascimento'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const PublicacoesScalarFieldEnum: {
    id: 'id',
    conteudo: 'conteudo',
    foto: 'foto',
    video: 'video',
    data: 'data',
    updatedAt: 'updatedAt',
    usuarioID: 'usuarioID'
  };

  export type PublicacoesScalarFieldEnum = (typeof PublicacoesScalarFieldEnum)[keyof typeof PublicacoesScalarFieldEnum]


  export const ComentariosScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    autorId: 'autorId',
    conteudo: 'conteudo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComentariosScalarFieldEnum = (typeof ComentariosScalarFieldEnum)[keyof typeof ComentariosScalarFieldEnum]


  export const ReacoesScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type ReacoesScalarFieldEnum = (typeof ReacoesScalarFieldEnum)[keyof typeof ReacoesScalarFieldEnum]


  export const NotificacoesScalarFieldEnum: {
    id: 'id',
    data: 'data',
    usuarioID: 'usuarioID',
    destinatarioID: 'destinatarioID',
    consultaID: 'consultaID',
    postID: 'postID',
    tipo: 'tipo',
    visto: 'visto'
  };

  export type NotificacoesScalarFieldEnum = (typeof NotificacoesScalarFieldEnum)[keyof typeof NotificacoesScalarFieldEnum]


  export const SeguidoresScalarFieldEnum: {
    id: 'id',
    seguidorID: 'seguidorID',
    entidadeID: 'entidadeID'
  };

  export type SeguidoresScalarFieldEnum = (typeof SeguidoresScalarFieldEnum)[keyof typeof SeguidoresScalarFieldEnum]


  export const MensagensScalarFieldEnum: {
    id: 'id',
    conteudo: 'conteudo',
    foto: 'foto',
    video: 'video',
    arquivo: 'arquivo',
    data: 'data',
    emissorID: 'emissorID',
    receptorID: 'receptorID',
    visto: 'visto'
  };

  export type MensagensScalarFieldEnum = (typeof MensagensScalarFieldEnum)[keyof typeof MensagensScalarFieldEnum]


  export const DiasDisponiveisScalarFieldEnum: {
    id: 'id',
    date: 'date',
    especialistaID: 'especialistaID'
  };

  export type DiasDisponiveisScalarFieldEnum = (typeof DiasDisponiveisScalarFieldEnum)[keyof typeof DiasDisponiveisScalarFieldEnum]


  export const HorasDisponiveisScalarFieldEnum: {
    id: 'id',
    hora: 'hora',
    diasDisponiveisID: 'diasDisponiveisID',
    especialistaID: 'especialistaID'
  };

  export type HorasDisponiveisScalarFieldEnum = (typeof HorasDisponiveisScalarFieldEnum)[keyof typeof HorasDisponiveisScalarFieldEnum]


  export const ConsultasScalarFieldEnum: {
    id: 'id',
    tipo_Da_Consulta: 'tipo_Da_Consulta',
    data: 'data',
    hora: 'hora',
    especialistaID: 'especialistaID',
    status: 'status',
    pacienteID: 'pacienteID'
  };

  export type ConsultasScalarFieldEnum = (typeof ConsultasScalarFieldEnum)[keyof typeof ConsultasScalarFieldEnum]


  export const VideoCallScalarFieldEnum: {
    id: 'id',
    emissor: 'emissor',
    destinatario: 'destinatario',
    offer: 'offer',
    answer: 'answer'
  };

  export type VideoCallScalarFieldEnum = (typeof VideoCallScalarFieldEnum)[keyof typeof VideoCallScalarFieldEnum]


  export const MinhasConexoesScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    friendID: 'friendID'
  };

  export type MinhasConexoesScalarFieldEnum = (typeof MinhasConexoesScalarFieldEnum)[keyof typeof MinhasConexoesScalarFieldEnum]


  export const PedidoDeConexaoScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    destinatarioID: 'destinatarioID'
  };

  export type PedidoDeConexaoScalarFieldEnum = (typeof PedidoDeConexaoScalarFieldEnum)[keyof typeof PedidoDeConexaoScalarFieldEnum]


  export const PartilhaScalarFieldEnum: {
    id: 'id',
    userID: 'userID',
    createPostShareID: 'createPostShareID',
    postShareID: 'postShareID',
    createdAt: 'createdAt'
  };

  export type PartilhaScalarFieldEnum = (typeof PartilhaScalarFieldEnum)[keyof typeof PartilhaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Sexo'
   */
  export type EnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Consulta'
   */
  export type EnumConsultaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Consulta'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type EntidadesSistemaWhereInput = {
    AND?: EntidadesSistemaWhereInput | EntidadesSistemaWhereInput[]
    OR?: EntidadesSistemaWhereInput[]
    NOT?: EntidadesSistemaWhereInput | EntidadesSistemaWhereInput[]
    id?: StringFilter<"EntidadesSistema"> | string
    name?: StringFilter<"EntidadesSistema"> | string
    cnpj?: StringFilter<"EntidadesSistema"> | string
    tipo_entidade?: StringFilter<"EntidadesSistema"> | string
    sobre?: StringNullableFilter<"EntidadesSistema"> | string | null
    email?: StringFilter<"EntidadesSistema"> | string
    foto?: StringNullableFilter<"EntidadesSistema"> | string | null
    enderecoID?: StringFilter<"EntidadesSistema"> | string
    endereco?: XOR<EnderecoRelationFilter, EnderecoWhereInput>
    contactos?: ContactosListRelationFilter
    especialista?: EspecialistasListRelationFilter
    seguidores?: SeguidoresListRelationFilter
  }

  export type EntidadesSistemaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    tipo_entidade?: SortOrder
    sobre?: SortOrderInput | SortOrder
    email?: SortOrder
    foto?: SortOrderInput | SortOrder
    enderecoID?: SortOrder
    endereco?: EnderecoOrderByWithRelationInput
    contactos?: ContactosOrderByRelationAggregateInput
    especialista?: EspecialistasOrderByRelationAggregateInput
    seguidores?: SeguidoresOrderByRelationAggregateInput
  }

  export type EntidadesSistemaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnpj?: string
    email?: string
    AND?: EntidadesSistemaWhereInput | EntidadesSistemaWhereInput[]
    OR?: EntidadesSistemaWhereInput[]
    NOT?: EntidadesSistemaWhereInput | EntidadesSistemaWhereInput[]
    name?: StringFilter<"EntidadesSistema"> | string
    tipo_entidade?: StringFilter<"EntidadesSistema"> | string
    sobre?: StringNullableFilter<"EntidadesSistema"> | string | null
    foto?: StringNullableFilter<"EntidadesSistema"> | string | null
    enderecoID?: StringFilter<"EntidadesSistema"> | string
    endereco?: XOR<EnderecoRelationFilter, EnderecoWhereInput>
    contactos?: ContactosListRelationFilter
    especialista?: EspecialistasListRelationFilter
    seguidores?: SeguidoresListRelationFilter
  }, "id" | "cnpj" | "email">

  export type EntidadesSistemaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    tipo_entidade?: SortOrder
    sobre?: SortOrderInput | SortOrder
    email?: SortOrder
    foto?: SortOrderInput | SortOrder
    enderecoID?: SortOrder
    _count?: EntidadesSistemaCountOrderByAggregateInput
    _max?: EntidadesSistemaMaxOrderByAggregateInput
    _min?: EntidadesSistemaMinOrderByAggregateInput
  }

  export type EntidadesSistemaScalarWhereWithAggregatesInput = {
    AND?: EntidadesSistemaScalarWhereWithAggregatesInput | EntidadesSistemaScalarWhereWithAggregatesInput[]
    OR?: EntidadesSistemaScalarWhereWithAggregatesInput[]
    NOT?: EntidadesSistemaScalarWhereWithAggregatesInput | EntidadesSistemaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EntidadesSistema"> | string
    name?: StringWithAggregatesFilter<"EntidadesSistema"> | string
    cnpj?: StringWithAggregatesFilter<"EntidadesSistema"> | string
    tipo_entidade?: StringWithAggregatesFilter<"EntidadesSistema"> | string
    sobre?: StringNullableWithAggregatesFilter<"EntidadesSistema"> | string | null
    email?: StringWithAggregatesFilter<"EntidadesSistema"> | string
    foto?: StringNullableWithAggregatesFilter<"EntidadesSistema"> | string | null
    enderecoID?: StringWithAggregatesFilter<"EntidadesSistema"> | string
  }

  export type EnderecoWhereInput = {
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    id?: StringFilter<"Endereco"> | string
    adress?: StringFilter<"Endereco"> | string
    entitie?: EntidadesSistemaListRelationFilter
  }

  export type EnderecoOrderByWithRelationInput = {
    id?: SortOrder
    adress?: SortOrder
    entitie?: EntidadesSistemaOrderByRelationAggregateInput
  }

  export type EnderecoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    adress?: StringFilter<"Endereco"> | string
    entitie?: EntidadesSistemaListRelationFilter
  }, "id">

  export type EnderecoOrderByWithAggregationInput = {
    id?: SortOrder
    adress?: SortOrder
    _count?: EnderecoCountOrderByAggregateInput
    _max?: EnderecoMaxOrderByAggregateInput
    _min?: EnderecoMinOrderByAggregateInput
  }

  export type EnderecoScalarWhereWithAggregatesInput = {
    AND?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    OR?: EnderecoScalarWhereWithAggregatesInput[]
    NOT?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Endereco"> | string
    adress?: StringWithAggregatesFilter<"Endereco"> | string
  }

  export type ContactosWhereInput = {
    AND?: ContactosWhereInput | ContactosWhereInput[]
    OR?: ContactosWhereInput[]
    NOT?: ContactosWhereInput | ContactosWhereInput[]
    id?: StringFilter<"Contactos"> | string
    contacto?: StringFilter<"Contactos"> | string
    entidadeID?: StringFilter<"Contactos"> | string
    usuarioID?: StringFilter<"Contactos"> | string
    entidade?: XOR<EntidadesSistemaRelationFilter, EntidadesSistemaWhereInput>
    usuario?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }

  export type ContactosOrderByWithRelationInput = {
    id?: SortOrder
    contacto?: SortOrder
    entidadeID?: SortOrder
    usuarioID?: SortOrder
    entidade?: EntidadesSistemaOrderByWithRelationInput
    usuario?: UsuariosOrderByWithRelationInput
  }

  export type ContactosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactosWhereInput | ContactosWhereInput[]
    OR?: ContactosWhereInput[]
    NOT?: ContactosWhereInput | ContactosWhereInput[]
    contacto?: StringFilter<"Contactos"> | string
    entidadeID?: StringFilter<"Contactos"> | string
    usuarioID?: StringFilter<"Contactos"> | string
    entidade?: XOR<EntidadesSistemaRelationFilter, EntidadesSistemaWhereInput>
    usuario?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }, "id">

  export type ContactosOrderByWithAggregationInput = {
    id?: SortOrder
    contacto?: SortOrder
    entidadeID?: SortOrder
    usuarioID?: SortOrder
    _count?: ContactosCountOrderByAggregateInput
    _max?: ContactosMaxOrderByAggregateInput
    _min?: ContactosMinOrderByAggregateInput
  }

  export type ContactosScalarWhereWithAggregatesInput = {
    AND?: ContactosScalarWhereWithAggregatesInput | ContactosScalarWhereWithAggregatesInput[]
    OR?: ContactosScalarWhereWithAggregatesInput[]
    NOT?: ContactosScalarWhereWithAggregatesInput | ContactosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contactos"> | string
    contacto?: StringWithAggregatesFilter<"Contactos"> | string
    entidadeID?: StringWithAggregatesFilter<"Contactos"> | string
    usuarioID?: StringWithAggregatesFilter<"Contactos"> | string
  }

  export type EspecialistasWhereInput = {
    AND?: EspecialistasWhereInput | EspecialistasWhereInput[]
    OR?: EspecialistasWhereInput[]
    NOT?: EspecialistasWhereInput | EspecialistasWhereInput[]
    id?: StringFilter<"Especialistas"> | string
    nome?: StringFilter<"Especialistas"> | string
    crm?: StringFilter<"Especialistas"> | string
    especialidade?: StringFilter<"Especialistas"> | string
    tipo_De_Consulta?: StringFilter<"Especialistas"> | string
    valor?: StringNullableFilter<"Especialistas"> | string | null
    bloqueado?: StringNullableFilter<"Especialistas"> | string | null
    sexo?: EnumSexoFilter<"Especialistas"> | $Enums.Sexo
    entidadeID?: StringNullableFilter<"Especialistas"> | string | null
    entidade?: XOR<EntidadesSistemaNullableRelationFilter, EntidadesSistemaWhereInput> | null
    diasDisponiveis?: DiasDisponiveisListRelationFilter
    horasDisponiveis?: HorasDisponiveisListRelationFilter
    consultas?: ConsultasListRelationFilter
  }

  export type EspecialistasOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    crm?: SortOrder
    especialidade?: SortOrder
    tipo_De_Consulta?: SortOrder
    valor?: SortOrderInput | SortOrder
    bloqueado?: SortOrderInput | SortOrder
    sexo?: SortOrder
    entidadeID?: SortOrderInput | SortOrder
    entidade?: EntidadesSistemaOrderByWithRelationInput
    diasDisponiveis?: DiasDisponiveisOrderByRelationAggregateInput
    horasDisponiveis?: HorasDisponiveisOrderByRelationAggregateInput
    consultas?: ConsultasOrderByRelationAggregateInput
  }

  export type EspecialistasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    crm?: string
    AND?: EspecialistasWhereInput | EspecialistasWhereInput[]
    OR?: EspecialistasWhereInput[]
    NOT?: EspecialistasWhereInput | EspecialistasWhereInput[]
    nome?: StringFilter<"Especialistas"> | string
    especialidade?: StringFilter<"Especialistas"> | string
    tipo_De_Consulta?: StringFilter<"Especialistas"> | string
    valor?: StringNullableFilter<"Especialistas"> | string | null
    bloqueado?: StringNullableFilter<"Especialistas"> | string | null
    sexo?: EnumSexoFilter<"Especialistas"> | $Enums.Sexo
    entidadeID?: StringNullableFilter<"Especialistas"> | string | null
    entidade?: XOR<EntidadesSistemaNullableRelationFilter, EntidadesSistemaWhereInput> | null
    diasDisponiveis?: DiasDisponiveisListRelationFilter
    horasDisponiveis?: HorasDisponiveisListRelationFilter
    consultas?: ConsultasListRelationFilter
  }, "id" | "crm">

  export type EspecialistasOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    crm?: SortOrder
    especialidade?: SortOrder
    tipo_De_Consulta?: SortOrder
    valor?: SortOrderInput | SortOrder
    bloqueado?: SortOrderInput | SortOrder
    sexo?: SortOrder
    entidadeID?: SortOrderInput | SortOrder
    _count?: EspecialistasCountOrderByAggregateInput
    _max?: EspecialistasMaxOrderByAggregateInput
    _min?: EspecialistasMinOrderByAggregateInput
  }

  export type EspecialistasScalarWhereWithAggregatesInput = {
    AND?: EspecialistasScalarWhereWithAggregatesInput | EspecialistasScalarWhereWithAggregatesInput[]
    OR?: EspecialistasScalarWhereWithAggregatesInput[]
    NOT?: EspecialistasScalarWhereWithAggregatesInput | EspecialistasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Especialistas"> | string
    nome?: StringWithAggregatesFilter<"Especialistas"> | string
    crm?: StringWithAggregatesFilter<"Especialistas"> | string
    especialidade?: StringWithAggregatesFilter<"Especialistas"> | string
    tipo_De_Consulta?: StringWithAggregatesFilter<"Especialistas"> | string
    valor?: StringNullableWithAggregatesFilter<"Especialistas"> | string | null
    bloqueado?: StringNullableWithAggregatesFilter<"Especialistas"> | string | null
    sexo?: EnumSexoWithAggregatesFilter<"Especialistas"> | $Enums.Sexo
    entidadeID?: StringNullableWithAggregatesFilter<"Especialistas"> | string | null
  }

  export type UsuariosWhereInput = {
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    id?: StringFilter<"Usuarios"> | string
    name?: StringFilter<"Usuarios"> | string
    email?: StringFilter<"Usuarios"> | string
    crm?: StringNullableFilter<"Usuarios"> | string | null
    cnpj?: StringNullableFilter<"Usuarios"> | string | null
    foto?: StringNullableFilter<"Usuarios"> | string | null
    senha?: StringFilter<"Usuarios"> | string
    sobre?: StringNullableFilter<"Usuarios"> | string | null
    sexo?: EnumSexoFilter<"Usuarios"> | $Enums.Sexo
    socketID?: StringNullableFilter<"Usuarios"> | string | null
    nascimento?: DateTimeFilter<"Usuarios"> | Date | string
    contactos?: ContactosListRelationFilter
    pubblicacoes?: PublicacoesListRelationFilter
    origem?: NotificacoesListRelationFilter
    destinatarioNotificacao?: NotificacoesListRelationFilter
    consultas?: ConsultasListRelationFilter
    mensagensEnviadas?: MensagensListRelationFilter
    mensagensRecebidas?: MensagensListRelationFilter
    remetente?: MinhasConexoesListRelationFilter
    destinatario?: MinhasConexoesListRelationFilter
    emissorDoPedido?: PedidoDeConexaoListRelationFilter
    receptorDoPedido?: PedidoDeConexaoListRelationFilter
    reacoes?: ReacoesListRelationFilter
    comentarios?: ComentariosListRelationFilter
    seguidor?: SeguidoresListRelationFilter
    partilha?: PartilhaListRelationFilter
  }

  export type UsuariosOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    crm?: SortOrderInput | SortOrder
    cnpj?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    senha?: SortOrder
    sobre?: SortOrderInput | SortOrder
    sexo?: SortOrder
    socketID?: SortOrderInput | SortOrder
    nascimento?: SortOrder
    contactos?: ContactosOrderByRelationAggregateInput
    pubblicacoes?: PublicacoesOrderByRelationAggregateInput
    origem?: NotificacoesOrderByRelationAggregateInput
    destinatarioNotificacao?: NotificacoesOrderByRelationAggregateInput
    consultas?: ConsultasOrderByRelationAggregateInput
    mensagensEnviadas?: MensagensOrderByRelationAggregateInput
    mensagensRecebidas?: MensagensOrderByRelationAggregateInput
    remetente?: MinhasConexoesOrderByRelationAggregateInput
    destinatario?: MinhasConexoesOrderByRelationAggregateInput
    emissorDoPedido?: PedidoDeConexaoOrderByRelationAggregateInput
    receptorDoPedido?: PedidoDeConexaoOrderByRelationAggregateInput
    reacoes?: ReacoesOrderByRelationAggregateInput
    comentarios?: ComentariosOrderByRelationAggregateInput
    seguidor?: SeguidoresOrderByRelationAggregateInput
    partilha?: PartilhaOrderByRelationAggregateInput
  }

  export type UsuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    crm?: string
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    name?: StringFilter<"Usuarios"> | string
    cnpj?: StringNullableFilter<"Usuarios"> | string | null
    foto?: StringNullableFilter<"Usuarios"> | string | null
    senha?: StringFilter<"Usuarios"> | string
    sobre?: StringNullableFilter<"Usuarios"> | string | null
    sexo?: EnumSexoFilter<"Usuarios"> | $Enums.Sexo
    socketID?: StringNullableFilter<"Usuarios"> | string | null
    nascimento?: DateTimeFilter<"Usuarios"> | Date | string
    contactos?: ContactosListRelationFilter
    pubblicacoes?: PublicacoesListRelationFilter
    origem?: NotificacoesListRelationFilter
    destinatarioNotificacao?: NotificacoesListRelationFilter
    consultas?: ConsultasListRelationFilter
    mensagensEnviadas?: MensagensListRelationFilter
    mensagensRecebidas?: MensagensListRelationFilter
    remetente?: MinhasConexoesListRelationFilter
    destinatario?: MinhasConexoesListRelationFilter
    emissorDoPedido?: PedidoDeConexaoListRelationFilter
    receptorDoPedido?: PedidoDeConexaoListRelationFilter
    reacoes?: ReacoesListRelationFilter
    comentarios?: ComentariosListRelationFilter
    seguidor?: SeguidoresListRelationFilter
    partilha?: PartilhaListRelationFilter
  }, "id" | "email" | "crm">

  export type UsuariosOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    crm?: SortOrderInput | SortOrder
    cnpj?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    senha?: SortOrder
    sobre?: SortOrderInput | SortOrder
    sexo?: SortOrder
    socketID?: SortOrderInput | SortOrder
    nascimento?: SortOrder
    _count?: UsuariosCountOrderByAggregateInput
    _max?: UsuariosMaxOrderByAggregateInput
    _min?: UsuariosMinOrderByAggregateInput
  }

  export type UsuariosScalarWhereWithAggregatesInput = {
    AND?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    OR?: UsuariosScalarWhereWithAggregatesInput[]
    NOT?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuarios"> | string
    name?: StringWithAggregatesFilter<"Usuarios"> | string
    email?: StringWithAggregatesFilter<"Usuarios"> | string
    crm?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    cnpj?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    foto?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    senha?: StringWithAggregatesFilter<"Usuarios"> | string
    sobre?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    sexo?: EnumSexoWithAggregatesFilter<"Usuarios"> | $Enums.Sexo
    socketID?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    nascimento?: DateTimeWithAggregatesFilter<"Usuarios"> | Date | string
  }

  export type PublicacoesWhereInput = {
    AND?: PublicacoesWhereInput | PublicacoesWhereInput[]
    OR?: PublicacoesWhereInput[]
    NOT?: PublicacoesWhereInput | PublicacoesWhereInput[]
    id?: StringFilter<"Publicacoes"> | string
    conteudo?: StringFilter<"Publicacoes"> | string
    foto?: StringNullableFilter<"Publicacoes"> | string | null
    video?: StringNullableFilter<"Publicacoes"> | string | null
    data?: DateTimeFilter<"Publicacoes"> | Date | string
    updatedAt?: DateTimeFilter<"Publicacoes"> | Date | string
    usuarioID?: StringFilter<"Publicacoes"> | string
    usuarioPub?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    reacoes?: ReacoesListRelationFilter
    comentarios?: ComentariosListRelationFilter
    notificacao?: NotificacoesListRelationFilter
    postPartilhado?: PartilhaListRelationFilter
    postCriado?: PartilhaListRelationFilter
  }

  export type PublicacoesOrderByWithRelationInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    usuarioID?: SortOrder
    usuarioPub?: UsuariosOrderByWithRelationInput
    reacoes?: ReacoesOrderByRelationAggregateInput
    comentarios?: ComentariosOrderByRelationAggregateInput
    notificacao?: NotificacoesOrderByRelationAggregateInput
    postPartilhado?: PartilhaOrderByRelationAggregateInput
    postCriado?: PartilhaOrderByRelationAggregateInput
  }

  export type PublicacoesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublicacoesWhereInput | PublicacoesWhereInput[]
    OR?: PublicacoesWhereInput[]
    NOT?: PublicacoesWhereInput | PublicacoesWhereInput[]
    conteudo?: StringFilter<"Publicacoes"> | string
    foto?: StringNullableFilter<"Publicacoes"> | string | null
    video?: StringNullableFilter<"Publicacoes"> | string | null
    data?: DateTimeFilter<"Publicacoes"> | Date | string
    updatedAt?: DateTimeFilter<"Publicacoes"> | Date | string
    usuarioID?: StringFilter<"Publicacoes"> | string
    usuarioPub?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    reacoes?: ReacoesListRelationFilter
    comentarios?: ComentariosListRelationFilter
    notificacao?: NotificacoesListRelationFilter
    postPartilhado?: PartilhaListRelationFilter
    postCriado?: PartilhaListRelationFilter
  }, "id">

  export type PublicacoesOrderByWithAggregationInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    usuarioID?: SortOrder
    _count?: PublicacoesCountOrderByAggregateInput
    _max?: PublicacoesMaxOrderByAggregateInput
    _min?: PublicacoesMinOrderByAggregateInput
  }

  export type PublicacoesScalarWhereWithAggregatesInput = {
    AND?: PublicacoesScalarWhereWithAggregatesInput | PublicacoesScalarWhereWithAggregatesInput[]
    OR?: PublicacoesScalarWhereWithAggregatesInput[]
    NOT?: PublicacoesScalarWhereWithAggregatesInput | PublicacoesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Publicacoes"> | string
    conteudo?: StringWithAggregatesFilter<"Publicacoes"> | string
    foto?: StringNullableWithAggregatesFilter<"Publicacoes"> | string | null
    video?: StringNullableWithAggregatesFilter<"Publicacoes"> | string | null
    data?: DateTimeWithAggregatesFilter<"Publicacoes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Publicacoes"> | Date | string
    usuarioID?: StringWithAggregatesFilter<"Publicacoes"> | string
  }

  export type ComentariosWhereInput = {
    AND?: ComentariosWhereInput | ComentariosWhereInput[]
    OR?: ComentariosWhereInput[]
    NOT?: ComentariosWhereInput | ComentariosWhereInput[]
    id?: StringFilter<"Comentarios"> | string
    postId?: StringFilter<"Comentarios"> | string
    autorId?: StringFilter<"Comentarios"> | string
    conteudo?: StringFilter<"Comentarios"> | string
    createdAt?: DateTimeFilter<"Comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"Comentarios"> | Date | string
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    autor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }

  export type ComentariosOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    autorId?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PublicacoesOrderByWithRelationInput
    autor?: UsuariosOrderByWithRelationInput
  }

  export type ComentariosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComentariosWhereInput | ComentariosWhereInput[]
    OR?: ComentariosWhereInput[]
    NOT?: ComentariosWhereInput | ComentariosWhereInput[]
    postId?: StringFilter<"Comentarios"> | string
    autorId?: StringFilter<"Comentarios"> | string
    conteudo?: StringFilter<"Comentarios"> | string
    createdAt?: DateTimeFilter<"Comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"Comentarios"> | Date | string
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    autor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }, "id">

  export type ComentariosOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    autorId?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComentariosCountOrderByAggregateInput
    _max?: ComentariosMaxOrderByAggregateInput
    _min?: ComentariosMinOrderByAggregateInput
  }

  export type ComentariosScalarWhereWithAggregatesInput = {
    AND?: ComentariosScalarWhereWithAggregatesInput | ComentariosScalarWhereWithAggregatesInput[]
    OR?: ComentariosScalarWhereWithAggregatesInput[]
    NOT?: ComentariosScalarWhereWithAggregatesInput | ComentariosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comentarios"> | string
    postId?: StringWithAggregatesFilter<"Comentarios"> | string
    autorId?: StringWithAggregatesFilter<"Comentarios"> | string
    conteudo?: StringWithAggregatesFilter<"Comentarios"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comentarios"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comentarios"> | Date | string
  }

  export type ReacoesWhereInput = {
    AND?: ReacoesWhereInput | ReacoesWhereInput[]
    OR?: ReacoesWhereInput[]
    NOT?: ReacoesWhereInput | ReacoesWhereInput[]
    id?: StringFilter<"Reacoes"> | string
    postId?: StringFilter<"Reacoes"> | string
    userId?: StringFilter<"Reacoes"> | string
    type?: StringFilter<"Reacoes"> | string
    createdAt?: DateTimeFilter<"Reacoes"> | Date | string
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }

  export type ReacoesOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    post?: PublicacoesOrderByWithRelationInput
    user?: UsuariosOrderByWithRelationInput
  }

  export type ReacoesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReacoesWhereInput | ReacoesWhereInput[]
    OR?: ReacoesWhereInput[]
    NOT?: ReacoesWhereInput | ReacoesWhereInput[]
    postId?: StringFilter<"Reacoes"> | string
    userId?: StringFilter<"Reacoes"> | string
    type?: StringFilter<"Reacoes"> | string
    createdAt?: DateTimeFilter<"Reacoes"> | Date | string
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }, "id">

  export type ReacoesOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: ReacoesCountOrderByAggregateInput
    _max?: ReacoesMaxOrderByAggregateInput
    _min?: ReacoesMinOrderByAggregateInput
  }

  export type ReacoesScalarWhereWithAggregatesInput = {
    AND?: ReacoesScalarWhereWithAggregatesInput | ReacoesScalarWhereWithAggregatesInput[]
    OR?: ReacoesScalarWhereWithAggregatesInput[]
    NOT?: ReacoesScalarWhereWithAggregatesInput | ReacoesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reacoes"> | string
    postId?: StringWithAggregatesFilter<"Reacoes"> | string
    userId?: StringWithAggregatesFilter<"Reacoes"> | string
    type?: StringWithAggregatesFilter<"Reacoes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reacoes"> | Date | string
  }

  export type NotificacoesWhereInput = {
    AND?: NotificacoesWhereInput | NotificacoesWhereInput[]
    OR?: NotificacoesWhereInput[]
    NOT?: NotificacoesWhereInput | NotificacoesWhereInput[]
    id?: StringFilter<"Notificacoes"> | string
    data?: DateTimeFilter<"Notificacoes"> | Date | string
    usuarioID?: StringFilter<"Notificacoes"> | string
    destinatarioID?: StringFilter<"Notificacoes"> | string
    consultaID?: StringFilter<"Notificacoes"> | string
    postID?: StringFilter<"Notificacoes"> | string
    tipo?: StringFilter<"Notificacoes"> | string
    visto?: StringNullableFilter<"Notificacoes"> | string | null
    usuarioNotificacao?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    destinatarioNotificacao?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    consulta?: XOR<ConsultasRelationFilter, ConsultasWhereInput>
  }

  export type NotificacoesOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    usuarioID?: SortOrder
    destinatarioID?: SortOrder
    consultaID?: SortOrder
    postID?: SortOrder
    tipo?: SortOrder
    visto?: SortOrderInput | SortOrder
    usuarioNotificacao?: UsuariosOrderByWithRelationInput
    destinatarioNotificacao?: UsuariosOrderByWithRelationInput
    post?: PublicacoesOrderByWithRelationInput
    consulta?: ConsultasOrderByWithRelationInput
  }

  export type NotificacoesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificacoesWhereInput | NotificacoesWhereInput[]
    OR?: NotificacoesWhereInput[]
    NOT?: NotificacoesWhereInput | NotificacoesWhereInput[]
    data?: DateTimeFilter<"Notificacoes"> | Date | string
    usuarioID?: StringFilter<"Notificacoes"> | string
    destinatarioID?: StringFilter<"Notificacoes"> | string
    consultaID?: StringFilter<"Notificacoes"> | string
    postID?: StringFilter<"Notificacoes"> | string
    tipo?: StringFilter<"Notificacoes"> | string
    visto?: StringNullableFilter<"Notificacoes"> | string | null
    usuarioNotificacao?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    destinatarioNotificacao?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    consulta?: XOR<ConsultasRelationFilter, ConsultasWhereInput>
  }, "id">

  export type NotificacoesOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    usuarioID?: SortOrder
    destinatarioID?: SortOrder
    consultaID?: SortOrder
    postID?: SortOrder
    tipo?: SortOrder
    visto?: SortOrderInput | SortOrder
    _count?: NotificacoesCountOrderByAggregateInput
    _max?: NotificacoesMaxOrderByAggregateInput
    _min?: NotificacoesMinOrderByAggregateInput
  }

  export type NotificacoesScalarWhereWithAggregatesInput = {
    AND?: NotificacoesScalarWhereWithAggregatesInput | NotificacoesScalarWhereWithAggregatesInput[]
    OR?: NotificacoesScalarWhereWithAggregatesInput[]
    NOT?: NotificacoesScalarWhereWithAggregatesInput | NotificacoesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notificacoes"> | string
    data?: DateTimeWithAggregatesFilter<"Notificacoes"> | Date | string
    usuarioID?: StringWithAggregatesFilter<"Notificacoes"> | string
    destinatarioID?: StringWithAggregatesFilter<"Notificacoes"> | string
    consultaID?: StringWithAggregatesFilter<"Notificacoes"> | string
    postID?: StringWithAggregatesFilter<"Notificacoes"> | string
    tipo?: StringWithAggregatesFilter<"Notificacoes"> | string
    visto?: StringNullableWithAggregatesFilter<"Notificacoes"> | string | null
  }

  export type SeguidoresWhereInput = {
    AND?: SeguidoresWhereInput | SeguidoresWhereInput[]
    OR?: SeguidoresWhereInput[]
    NOT?: SeguidoresWhereInput | SeguidoresWhereInput[]
    id?: StringFilter<"Seguidores"> | string
    seguidorID?: StringFilter<"Seguidores"> | string
    entidadeID?: StringFilter<"Seguidores"> | string
    seguidor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    entidade?: XOR<EntidadesSistemaRelationFilter, EntidadesSistemaWhereInput>
  }

  export type SeguidoresOrderByWithRelationInput = {
    id?: SortOrder
    seguidorID?: SortOrder
    entidadeID?: SortOrder
    seguidor?: UsuariosOrderByWithRelationInput
    entidade?: EntidadesSistemaOrderByWithRelationInput
  }

  export type SeguidoresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeguidoresWhereInput | SeguidoresWhereInput[]
    OR?: SeguidoresWhereInput[]
    NOT?: SeguidoresWhereInput | SeguidoresWhereInput[]
    seguidorID?: StringFilter<"Seguidores"> | string
    entidadeID?: StringFilter<"Seguidores"> | string
    seguidor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    entidade?: XOR<EntidadesSistemaRelationFilter, EntidadesSistemaWhereInput>
  }, "id">

  export type SeguidoresOrderByWithAggregationInput = {
    id?: SortOrder
    seguidorID?: SortOrder
    entidadeID?: SortOrder
    _count?: SeguidoresCountOrderByAggregateInput
    _max?: SeguidoresMaxOrderByAggregateInput
    _min?: SeguidoresMinOrderByAggregateInput
  }

  export type SeguidoresScalarWhereWithAggregatesInput = {
    AND?: SeguidoresScalarWhereWithAggregatesInput | SeguidoresScalarWhereWithAggregatesInput[]
    OR?: SeguidoresScalarWhereWithAggregatesInput[]
    NOT?: SeguidoresScalarWhereWithAggregatesInput | SeguidoresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Seguidores"> | string
    seguidorID?: StringWithAggregatesFilter<"Seguidores"> | string
    entidadeID?: StringWithAggregatesFilter<"Seguidores"> | string
  }

  export type MensagensWhereInput = {
    AND?: MensagensWhereInput | MensagensWhereInput[]
    OR?: MensagensWhereInput[]
    NOT?: MensagensWhereInput | MensagensWhereInput[]
    id?: StringFilter<"Mensagens"> | string
    conteudo?: StringNullableFilter<"Mensagens"> | string | null
    foto?: StringNullableFilter<"Mensagens"> | string | null
    video?: StringNullableFilter<"Mensagens"> | string | null
    arquivo?: StringNullableFilter<"Mensagens"> | string | null
    data?: DateTimeFilter<"Mensagens"> | Date | string
    emissorID?: StringFilter<"Mensagens"> | string
    receptorID?: StringFilter<"Mensagens"> | string
    visto?: BoolFilter<"Mensagens"> | boolean
    emissor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    receptor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }

  export type MensagensOrderByWithRelationInput = {
    id?: SortOrder
    conteudo?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    arquivo?: SortOrderInput | SortOrder
    data?: SortOrder
    emissorID?: SortOrder
    receptorID?: SortOrder
    visto?: SortOrder
    emissor?: UsuariosOrderByWithRelationInput
    receptor?: UsuariosOrderByWithRelationInput
  }

  export type MensagensWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MensagensWhereInput | MensagensWhereInput[]
    OR?: MensagensWhereInput[]
    NOT?: MensagensWhereInput | MensagensWhereInput[]
    conteudo?: StringNullableFilter<"Mensagens"> | string | null
    foto?: StringNullableFilter<"Mensagens"> | string | null
    video?: StringNullableFilter<"Mensagens"> | string | null
    arquivo?: StringNullableFilter<"Mensagens"> | string | null
    data?: DateTimeFilter<"Mensagens"> | Date | string
    emissorID?: StringFilter<"Mensagens"> | string
    receptorID?: StringFilter<"Mensagens"> | string
    visto?: BoolFilter<"Mensagens"> | boolean
    emissor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    receptor?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }, "id">

  export type MensagensOrderByWithAggregationInput = {
    id?: SortOrder
    conteudo?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    video?: SortOrderInput | SortOrder
    arquivo?: SortOrderInput | SortOrder
    data?: SortOrder
    emissorID?: SortOrder
    receptorID?: SortOrder
    visto?: SortOrder
    _count?: MensagensCountOrderByAggregateInput
    _max?: MensagensMaxOrderByAggregateInput
    _min?: MensagensMinOrderByAggregateInput
  }

  export type MensagensScalarWhereWithAggregatesInput = {
    AND?: MensagensScalarWhereWithAggregatesInput | MensagensScalarWhereWithAggregatesInput[]
    OR?: MensagensScalarWhereWithAggregatesInput[]
    NOT?: MensagensScalarWhereWithAggregatesInput | MensagensScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mensagens"> | string
    conteudo?: StringNullableWithAggregatesFilter<"Mensagens"> | string | null
    foto?: StringNullableWithAggregatesFilter<"Mensagens"> | string | null
    video?: StringNullableWithAggregatesFilter<"Mensagens"> | string | null
    arquivo?: StringNullableWithAggregatesFilter<"Mensagens"> | string | null
    data?: DateTimeWithAggregatesFilter<"Mensagens"> | Date | string
    emissorID?: StringWithAggregatesFilter<"Mensagens"> | string
    receptorID?: StringWithAggregatesFilter<"Mensagens"> | string
    visto?: BoolWithAggregatesFilter<"Mensagens"> | boolean
  }

  export type DiasDisponiveisWhereInput = {
    AND?: DiasDisponiveisWhereInput | DiasDisponiveisWhereInput[]
    OR?: DiasDisponiveisWhereInput[]
    NOT?: DiasDisponiveisWhereInput | DiasDisponiveisWhereInput[]
    id?: StringFilter<"DiasDisponiveis"> | string
    date?: DateTimeFilter<"DiasDisponiveis"> | Date | string
    especialistaID?: StringFilter<"DiasDisponiveis"> | string
    horasDisponiveis?: HorasDisponiveisListRelationFilter
    especialista?: XOR<EspecialistasRelationFilter, EspecialistasWhereInput>
  }

  export type DiasDisponiveisOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    especialistaID?: SortOrder
    horasDisponiveis?: HorasDisponiveisOrderByRelationAggregateInput
    especialista?: EspecialistasOrderByWithRelationInput
  }

  export type DiasDisponiveisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiasDisponiveisWhereInput | DiasDisponiveisWhereInput[]
    OR?: DiasDisponiveisWhereInput[]
    NOT?: DiasDisponiveisWhereInput | DiasDisponiveisWhereInput[]
    date?: DateTimeFilter<"DiasDisponiveis"> | Date | string
    especialistaID?: StringFilter<"DiasDisponiveis"> | string
    horasDisponiveis?: HorasDisponiveisListRelationFilter
    especialista?: XOR<EspecialistasRelationFilter, EspecialistasWhereInput>
  }, "id">

  export type DiasDisponiveisOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    especialistaID?: SortOrder
    _count?: DiasDisponiveisCountOrderByAggregateInput
    _max?: DiasDisponiveisMaxOrderByAggregateInput
    _min?: DiasDisponiveisMinOrderByAggregateInput
  }

  export type DiasDisponiveisScalarWhereWithAggregatesInput = {
    AND?: DiasDisponiveisScalarWhereWithAggregatesInput | DiasDisponiveisScalarWhereWithAggregatesInput[]
    OR?: DiasDisponiveisScalarWhereWithAggregatesInput[]
    NOT?: DiasDisponiveisScalarWhereWithAggregatesInput | DiasDisponiveisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiasDisponiveis"> | string
    date?: DateTimeWithAggregatesFilter<"DiasDisponiveis"> | Date | string
    especialistaID?: StringWithAggregatesFilter<"DiasDisponiveis"> | string
  }

  export type HorasDisponiveisWhereInput = {
    AND?: HorasDisponiveisWhereInput | HorasDisponiveisWhereInput[]
    OR?: HorasDisponiveisWhereInput[]
    NOT?: HorasDisponiveisWhereInput | HorasDisponiveisWhereInput[]
    id?: StringFilter<"HorasDisponiveis"> | string
    hora?: StringFilter<"HorasDisponiveis"> | string
    diasDisponiveisID?: StringFilter<"HorasDisponiveis"> | string
    especialistaID?: StringFilter<"HorasDisponiveis"> | string
    diasDisponiveis?: XOR<DiasDisponiveisRelationFilter, DiasDisponiveisWhereInput>
    especialista?: XOR<EspecialistasRelationFilter, EspecialistasWhereInput>
  }

  export type HorasDisponiveisOrderByWithRelationInput = {
    id?: SortOrder
    hora?: SortOrder
    diasDisponiveisID?: SortOrder
    especialistaID?: SortOrder
    diasDisponiveis?: DiasDisponiveisOrderByWithRelationInput
    especialista?: EspecialistasOrderByWithRelationInput
  }

  export type HorasDisponiveisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HorasDisponiveisWhereInput | HorasDisponiveisWhereInput[]
    OR?: HorasDisponiveisWhereInput[]
    NOT?: HorasDisponiveisWhereInput | HorasDisponiveisWhereInput[]
    hora?: StringFilter<"HorasDisponiveis"> | string
    diasDisponiveisID?: StringFilter<"HorasDisponiveis"> | string
    especialistaID?: StringFilter<"HorasDisponiveis"> | string
    diasDisponiveis?: XOR<DiasDisponiveisRelationFilter, DiasDisponiveisWhereInput>
    especialista?: XOR<EspecialistasRelationFilter, EspecialistasWhereInput>
  }, "id">

  export type HorasDisponiveisOrderByWithAggregationInput = {
    id?: SortOrder
    hora?: SortOrder
    diasDisponiveisID?: SortOrder
    especialistaID?: SortOrder
    _count?: HorasDisponiveisCountOrderByAggregateInput
    _max?: HorasDisponiveisMaxOrderByAggregateInput
    _min?: HorasDisponiveisMinOrderByAggregateInput
  }

  export type HorasDisponiveisScalarWhereWithAggregatesInput = {
    AND?: HorasDisponiveisScalarWhereWithAggregatesInput | HorasDisponiveisScalarWhereWithAggregatesInput[]
    OR?: HorasDisponiveisScalarWhereWithAggregatesInput[]
    NOT?: HorasDisponiveisScalarWhereWithAggregatesInput | HorasDisponiveisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HorasDisponiveis"> | string
    hora?: StringWithAggregatesFilter<"HorasDisponiveis"> | string
    diasDisponiveisID?: StringWithAggregatesFilter<"HorasDisponiveis"> | string
    especialistaID?: StringWithAggregatesFilter<"HorasDisponiveis"> | string
  }

  export type ConsultasWhereInput = {
    AND?: ConsultasWhereInput | ConsultasWhereInput[]
    OR?: ConsultasWhereInput[]
    NOT?: ConsultasWhereInput | ConsultasWhereInput[]
    id?: StringFilter<"Consultas"> | string
    tipo_Da_Consulta?: StringFilter<"Consultas"> | string
    data?: DateTimeFilter<"Consultas"> | Date | string
    hora?: StringFilter<"Consultas"> | string
    especialistaID?: StringFilter<"Consultas"> | string
    status?: EnumConsultaFilter<"Consultas"> | $Enums.Consulta
    pacienteID?: StringFilter<"Consultas"> | string
    especialista?: XOR<EspecialistasRelationFilter, EspecialistasWhereInput>
    usuario?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    notificacoes?: NotificacoesListRelationFilter
  }

  export type ConsultasOrderByWithRelationInput = {
    id?: SortOrder
    tipo_Da_Consulta?: SortOrder
    data?: SortOrder
    hora?: SortOrder
    especialistaID?: SortOrder
    status?: SortOrder
    pacienteID?: SortOrder
    especialista?: EspecialistasOrderByWithRelationInput
    usuario?: UsuariosOrderByWithRelationInput
    notificacoes?: NotificacoesOrderByRelationAggregateInput
  }

  export type ConsultasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultasWhereInput | ConsultasWhereInput[]
    OR?: ConsultasWhereInput[]
    NOT?: ConsultasWhereInput | ConsultasWhereInput[]
    tipo_Da_Consulta?: StringFilter<"Consultas"> | string
    data?: DateTimeFilter<"Consultas"> | Date | string
    hora?: StringFilter<"Consultas"> | string
    especialistaID?: StringFilter<"Consultas"> | string
    status?: EnumConsultaFilter<"Consultas"> | $Enums.Consulta
    pacienteID?: StringFilter<"Consultas"> | string
    especialista?: XOR<EspecialistasRelationFilter, EspecialistasWhereInput>
    usuario?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    notificacoes?: NotificacoesListRelationFilter
  }, "id">

  export type ConsultasOrderByWithAggregationInput = {
    id?: SortOrder
    tipo_Da_Consulta?: SortOrder
    data?: SortOrder
    hora?: SortOrder
    especialistaID?: SortOrder
    status?: SortOrder
    pacienteID?: SortOrder
    _count?: ConsultasCountOrderByAggregateInput
    _max?: ConsultasMaxOrderByAggregateInput
    _min?: ConsultasMinOrderByAggregateInput
  }

  export type ConsultasScalarWhereWithAggregatesInput = {
    AND?: ConsultasScalarWhereWithAggregatesInput | ConsultasScalarWhereWithAggregatesInput[]
    OR?: ConsultasScalarWhereWithAggregatesInput[]
    NOT?: ConsultasScalarWhereWithAggregatesInput | ConsultasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consultas"> | string
    tipo_Da_Consulta?: StringWithAggregatesFilter<"Consultas"> | string
    data?: DateTimeWithAggregatesFilter<"Consultas"> | Date | string
    hora?: StringWithAggregatesFilter<"Consultas"> | string
    especialistaID?: StringWithAggregatesFilter<"Consultas"> | string
    status?: EnumConsultaWithAggregatesFilter<"Consultas"> | $Enums.Consulta
    pacienteID?: StringWithAggregatesFilter<"Consultas"> | string
  }

  export type VideoCallWhereInput = {
    AND?: VideoCallWhereInput | VideoCallWhereInput[]
    OR?: VideoCallWhereInput[]
    NOT?: VideoCallWhereInput | VideoCallWhereInput[]
    id?: StringFilter<"VideoCall"> | string
    emissor?: StringFilter<"VideoCall"> | string
    destinatario?: StringFilter<"VideoCall"> | string
    offer?: JsonNullableFilter<"VideoCall">
    answer?: JsonNullableFilter<"VideoCall">
  }

  export type VideoCallOrderByWithRelationInput = {
    id?: SortOrder
    emissor?: SortOrder
    destinatario?: SortOrder
    offer?: SortOrderInput | SortOrder
    answer?: SortOrderInput | SortOrder
  }

  export type VideoCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoCallWhereInput | VideoCallWhereInput[]
    OR?: VideoCallWhereInput[]
    NOT?: VideoCallWhereInput | VideoCallWhereInput[]
    emissor?: StringFilter<"VideoCall"> | string
    destinatario?: StringFilter<"VideoCall"> | string
    offer?: JsonNullableFilter<"VideoCall">
    answer?: JsonNullableFilter<"VideoCall">
  }, "id">

  export type VideoCallOrderByWithAggregationInput = {
    id?: SortOrder
    emissor?: SortOrder
    destinatario?: SortOrder
    offer?: SortOrderInput | SortOrder
    answer?: SortOrderInput | SortOrder
    _count?: VideoCallCountOrderByAggregateInput
    _max?: VideoCallMaxOrderByAggregateInput
    _min?: VideoCallMinOrderByAggregateInput
  }

  export type VideoCallScalarWhereWithAggregatesInput = {
    AND?: VideoCallScalarWhereWithAggregatesInput | VideoCallScalarWhereWithAggregatesInput[]
    OR?: VideoCallScalarWhereWithAggregatesInput[]
    NOT?: VideoCallScalarWhereWithAggregatesInput | VideoCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoCall"> | string
    emissor?: StringWithAggregatesFilter<"VideoCall"> | string
    destinatario?: StringWithAggregatesFilter<"VideoCall"> | string
    offer?: JsonNullableWithAggregatesFilter<"VideoCall">
    answer?: JsonNullableWithAggregatesFilter<"VideoCall">
  }

  export type MinhasConexoesWhereInput = {
    AND?: MinhasConexoesWhereInput | MinhasConexoesWhereInput[]
    OR?: MinhasConexoesWhereInput[]
    NOT?: MinhasConexoesWhereInput | MinhasConexoesWhereInput[]
    id?: StringFilter<"MinhasConexoes"> | string
    userID?: StringFilter<"MinhasConexoes"> | string
    friendID?: StringFilter<"MinhasConexoes"> | string
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    friend?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }

  export type MinhasConexoesOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    friendID?: SortOrder
    user?: UsuariosOrderByWithRelationInput
    friend?: UsuariosOrderByWithRelationInput
  }

  export type MinhasConexoesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MinhasConexoesWhereInput | MinhasConexoesWhereInput[]
    OR?: MinhasConexoesWhereInput[]
    NOT?: MinhasConexoesWhereInput | MinhasConexoesWhereInput[]
    userID?: StringFilter<"MinhasConexoes"> | string
    friendID?: StringFilter<"MinhasConexoes"> | string
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    friend?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }, "id">

  export type MinhasConexoesOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    friendID?: SortOrder
    _count?: MinhasConexoesCountOrderByAggregateInput
    _max?: MinhasConexoesMaxOrderByAggregateInput
    _min?: MinhasConexoesMinOrderByAggregateInput
  }

  export type MinhasConexoesScalarWhereWithAggregatesInput = {
    AND?: MinhasConexoesScalarWhereWithAggregatesInput | MinhasConexoesScalarWhereWithAggregatesInput[]
    OR?: MinhasConexoesScalarWhereWithAggregatesInput[]
    NOT?: MinhasConexoesScalarWhereWithAggregatesInput | MinhasConexoesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MinhasConexoes"> | string
    userID?: StringWithAggregatesFilter<"MinhasConexoes"> | string
    friendID?: StringWithAggregatesFilter<"MinhasConexoes"> | string
  }

  export type PedidoDeConexaoWhereInput = {
    AND?: PedidoDeConexaoWhereInput | PedidoDeConexaoWhereInput[]
    OR?: PedidoDeConexaoWhereInput[]
    NOT?: PedidoDeConexaoWhereInput | PedidoDeConexaoWhereInput[]
    id?: StringFilter<"PedidoDeConexao"> | string
    userID?: StringFilter<"PedidoDeConexao"> | string
    destinatarioID?: StringFilter<"PedidoDeConexao"> | string
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    destinatario?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }

  export type PedidoDeConexaoOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    destinatarioID?: SortOrder
    user?: UsuariosOrderByWithRelationInput
    destinatario?: UsuariosOrderByWithRelationInput
  }

  export type PedidoDeConexaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PedidoDeConexaoWhereInput | PedidoDeConexaoWhereInput[]
    OR?: PedidoDeConexaoWhereInput[]
    NOT?: PedidoDeConexaoWhereInput | PedidoDeConexaoWhereInput[]
    userID?: StringFilter<"PedidoDeConexao"> | string
    destinatarioID?: StringFilter<"PedidoDeConexao"> | string
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    destinatario?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
  }, "id">

  export type PedidoDeConexaoOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    destinatarioID?: SortOrder
    _count?: PedidoDeConexaoCountOrderByAggregateInput
    _max?: PedidoDeConexaoMaxOrderByAggregateInput
    _min?: PedidoDeConexaoMinOrderByAggregateInput
  }

  export type PedidoDeConexaoScalarWhereWithAggregatesInput = {
    AND?: PedidoDeConexaoScalarWhereWithAggregatesInput | PedidoDeConexaoScalarWhereWithAggregatesInput[]
    OR?: PedidoDeConexaoScalarWhereWithAggregatesInput[]
    NOT?: PedidoDeConexaoScalarWhereWithAggregatesInput | PedidoDeConexaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PedidoDeConexao"> | string
    userID?: StringWithAggregatesFilter<"PedidoDeConexao"> | string
    destinatarioID?: StringWithAggregatesFilter<"PedidoDeConexao"> | string
  }

  export type PartilhaWhereInput = {
    AND?: PartilhaWhereInput | PartilhaWhereInput[]
    OR?: PartilhaWhereInput[]
    NOT?: PartilhaWhereInput | PartilhaWhereInput[]
    id?: StringFilter<"Partilha"> | string
    userID?: StringFilter<"Partilha"> | string
    createPostShareID?: StringFilter<"Partilha"> | string
    postShareID?: StringFilter<"Partilha"> | string
    createdAt?: DateTimeFilter<"Partilha"> | Date | string
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    postShare?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
  }

  export type PartilhaOrderByWithRelationInput = {
    id?: SortOrder
    userID?: SortOrder
    createPostShareID?: SortOrder
    postShareID?: SortOrder
    createdAt?: SortOrder
    user?: UsuariosOrderByWithRelationInput
    post?: PublicacoesOrderByWithRelationInput
    postShare?: PublicacoesOrderByWithRelationInput
  }

  export type PartilhaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartilhaWhereInput | PartilhaWhereInput[]
    OR?: PartilhaWhereInput[]
    NOT?: PartilhaWhereInput | PartilhaWhereInput[]
    userID?: StringFilter<"Partilha"> | string
    createPostShareID?: StringFilter<"Partilha"> | string
    postShareID?: StringFilter<"Partilha"> | string
    createdAt?: DateTimeFilter<"Partilha"> | Date | string
    user?: XOR<UsuariosRelationFilter, UsuariosWhereInput>
    post?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
    postShare?: XOR<PublicacoesRelationFilter, PublicacoesWhereInput>
  }, "id">

  export type PartilhaOrderByWithAggregationInput = {
    id?: SortOrder
    userID?: SortOrder
    createPostShareID?: SortOrder
    postShareID?: SortOrder
    createdAt?: SortOrder
    _count?: PartilhaCountOrderByAggregateInput
    _max?: PartilhaMaxOrderByAggregateInput
    _min?: PartilhaMinOrderByAggregateInput
  }

  export type PartilhaScalarWhereWithAggregatesInput = {
    AND?: PartilhaScalarWhereWithAggregatesInput | PartilhaScalarWhereWithAggregatesInput[]
    OR?: PartilhaScalarWhereWithAggregatesInput[]
    NOT?: PartilhaScalarWhereWithAggregatesInput | PartilhaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partilha"> | string
    userID?: StringWithAggregatesFilter<"Partilha"> | string
    createPostShareID?: StringWithAggregatesFilter<"Partilha"> | string
    postShareID?: StringWithAggregatesFilter<"Partilha"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Partilha"> | Date | string
  }

  export type EntidadesSistemaCreateInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    endereco: EnderecoCreateNestedOneWithoutEntitieInput
    contactos?: ContactosCreateNestedManyWithoutEntidadeInput
    especialista?: EspecialistasCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaUncheckedCreateInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    enderecoID: string
    contactos?: ContactosUncheckedCreateNestedManyWithoutEntidadeInput
    especialista?: EspecialistasUncheckedCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresUncheckedCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: EnderecoUpdateOneRequiredWithoutEntitieNestedInput
    contactos?: ContactosUpdateManyWithoutEntidadeNestedInput
    especialista?: EspecialistasUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUpdateManyWithoutEntidadeNestedInput
  }

  export type EntidadesSistemaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoID?: StringFieldUpdateOperationsInput | string
    contactos?: ContactosUncheckedUpdateManyWithoutEntidadeNestedInput
    especialista?: EspecialistasUncheckedUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUncheckedUpdateManyWithoutEntidadeNestedInput
  }

  export type EntidadesSistemaCreateManyInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    enderecoID: string
  }

  export type EntidadesSistemaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntidadesSistemaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoID?: StringFieldUpdateOperationsInput | string
  }

  export type EnderecoCreateInput = {
    id?: string
    adress: string
    entitie?: EntidadesSistemaCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateInput = {
    id?: string
    adress: string
    entitie?: EntidadesSistemaUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adress?: StringFieldUpdateOperationsInput | string
    entitie?: EntidadesSistemaUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adress?: StringFieldUpdateOperationsInput | string
    entitie?: EntidadesSistemaUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoCreateManyInput = {
    id?: string
    adress: string
  }

  export type EnderecoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type EnderecoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type ContactosCreateInput = {
    id?: string
    contacto: string
    entidade: EntidadesSistemaCreateNestedOneWithoutContactosInput
    usuario: UsuariosCreateNestedOneWithoutContactosInput
  }

  export type ContactosUncheckedCreateInput = {
    id?: string
    contacto: string
    entidadeID: string
    usuarioID: string
  }

  export type ContactosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    entidade?: EntidadesSistemaUpdateOneRequiredWithoutContactosNestedInput
    usuario?: UsuariosUpdateOneRequiredWithoutContactosNestedInput
  }

  export type ContactosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
    usuarioID?: StringFieldUpdateOperationsInput | string
  }

  export type ContactosCreateManyInput = {
    id?: string
    contacto: string
    entidadeID: string
    usuarioID: string
  }

  export type ContactosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
  }

  export type ContactosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
    usuarioID?: StringFieldUpdateOperationsInput | string
  }

  export type EspecialistasCreateInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidade?: EntidadesSistemaCreateNestedOneWithoutEspecialistaInput
    diasDisponiveis?: DiasDisponiveisCreateNestedManyWithoutEspecialistaInput
    horasDisponiveis?: HorasDisponiveisCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasUncheckedCreateInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidadeID?: string | null
    diasDisponiveis?: DiasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
    horasDisponiveis?: HorasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidade?: EntidadesSistemaUpdateOneWithoutEspecialistaNestedInput
    diasDisponiveis?: DiasDisponiveisUpdateManyWithoutEspecialistaNestedInput
    horasDisponiveis?: HorasDisponiveisUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidadeID?: NullableStringFieldUpdateOperationsInput | string | null
    diasDisponiveis?: DiasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
    horasDisponiveis?: HorasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasCreateManyInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidadeID?: string | null
  }

  export type EspecialistasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
  }

  export type EspecialistasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidadeID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuariosCreateInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosCreateManyInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
  }

  export type UsuariosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicacoesCreateInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioPub: UsuariosCreateNestedOneWithoutPubblicacoesInput
    reacoes?: ReacoesCreateNestedManyWithoutPostInput
    comentarios?: ComentariosCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaCreateNestedManyWithoutPostInput
    postCriado?: PartilhaCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesUncheckedCreateInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioID: string
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutPostInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesUncheckedCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaUncheckedCreateNestedManyWithoutPostInput
    postCriado?: PartilhaUncheckedCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioPub?: UsuariosUpdateOneRequiredWithoutPubblicacoesNestedInput
    reacoes?: ReacoesUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    reacoes?: ReacoesUncheckedUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUncheckedUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUncheckedUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUncheckedUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesCreateManyInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioID: string
  }

  export type PublicacoesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicacoesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
  }

  export type ComentariosCreateInput = {
    id?: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PublicacoesCreateNestedOneWithoutComentariosInput
    autor: UsuariosCreateNestedOneWithoutComentariosInput
  }

  export type ComentariosUncheckedCreateInput = {
    id?: string
    postId: string
    autorId: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentariosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PublicacoesUpdateOneRequiredWithoutComentariosNestedInput
    autor?: UsuariosUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentariosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentariosCreateManyInput = {
    id?: string
    postId: string
    autorId: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentariosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentariosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReacoesCreateInput = {
    id?: string
    type: string
    createdAt?: Date | string
    post: PublicacoesCreateNestedOneWithoutReacoesInput
    user: UsuariosCreateNestedOneWithoutReacoesInput
  }

  export type ReacoesUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type ReacoesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PublicacoesUpdateOneRequiredWithoutReacoesNestedInput
    user?: UsuariosUpdateOneRequiredWithoutReacoesNestedInput
  }

  export type ReacoesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReacoesCreateManyInput = {
    id?: string
    postId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type ReacoesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReacoesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacoesCreateInput = {
    id?: string
    data?: Date | string
    tipo: string
    visto?: string | null
    usuarioNotificacao: UsuariosCreateNestedOneWithoutOrigemInput
    destinatarioNotificacao: UsuariosCreateNestedOneWithoutDestinatarioNotificacaoInput
    post: PublicacoesCreateNestedOneWithoutNotificacaoInput
    consulta: ConsultasCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificacoesUncheckedCreateInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    destinatarioID: string
    consultaID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNotificacao?: UsuariosUpdateOneRequiredWithoutOrigemNestedInput
    destinatarioNotificacao?: UsuariosUpdateOneRequiredWithoutDestinatarioNotificacaoNestedInput
    post?: PublicacoesUpdateOneRequiredWithoutNotificacaoNestedInput
    consulta?: ConsultasUpdateOneRequiredWithoutNotificacoesNestedInput
  }

  export type NotificacoesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacoesCreateManyInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    destinatarioID: string
    consultaID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacoesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeguidoresCreateInput = {
    id?: string
    seguidor: UsuariosCreateNestedOneWithoutSeguidorInput
    entidade: EntidadesSistemaCreateNestedOneWithoutSeguidoresInput
  }

  export type SeguidoresUncheckedCreateInput = {
    id?: string
    seguidorID: string
    entidadeID: string
  }

  export type SeguidoresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seguidor?: UsuariosUpdateOneRequiredWithoutSeguidorNestedInput
    entidade?: EntidadesSistemaUpdateOneRequiredWithoutSeguidoresNestedInput
  }

  export type SeguidoresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seguidorID?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
  }

  export type SeguidoresCreateManyInput = {
    id?: string
    seguidorID: string
    entidadeID: string
  }

  export type SeguidoresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type SeguidoresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seguidorID?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
  }

  export type MensagensCreateInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    visto?: boolean
    emissor: UsuariosCreateNestedOneWithoutMensagensEnviadasInput
    receptor: UsuariosCreateNestedOneWithoutMensagensRecebidasInput
  }

  export type MensagensUncheckedCreateInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    emissorID: string
    receptorID: string
    visto?: boolean
  }

  export type MensagensUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    visto?: BoolFieldUpdateOperationsInput | boolean
    emissor?: UsuariosUpdateOneRequiredWithoutMensagensEnviadasNestedInput
    receptor?: UsuariosUpdateOneRequiredWithoutMensagensRecebidasNestedInput
  }

  export type MensagensUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    emissorID?: StringFieldUpdateOperationsInput | string
    receptorID?: StringFieldUpdateOperationsInput | string
    visto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensagensCreateManyInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    emissorID: string
    receptorID: string
    visto?: boolean
  }

  export type MensagensUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    visto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensagensUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    emissorID?: StringFieldUpdateOperationsInput | string
    receptorID?: StringFieldUpdateOperationsInput | string
    visto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiasDisponiveisCreateInput = {
    id?: string
    date: Date | string
    horasDisponiveis?: HorasDisponiveisCreateNestedManyWithoutDiasDisponiveisInput
    especialista: EspecialistasCreateNestedOneWithoutDiasDisponiveisInput
  }

  export type DiasDisponiveisUncheckedCreateInput = {
    id?: string
    date: Date | string
    especialistaID: string
    horasDisponiveis?: HorasDisponiveisUncheckedCreateNestedManyWithoutDiasDisponiveisInput
  }

  export type DiasDisponiveisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    horasDisponiveis?: HorasDisponiveisUpdateManyWithoutDiasDisponiveisNestedInput
    especialista?: EspecialistasUpdateOneRequiredWithoutDiasDisponiveisNestedInput
  }

  export type DiasDisponiveisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    especialistaID?: StringFieldUpdateOperationsInput | string
    horasDisponiveis?: HorasDisponiveisUncheckedUpdateManyWithoutDiasDisponiveisNestedInput
  }

  export type DiasDisponiveisCreateManyInput = {
    id?: string
    date: Date | string
    especialistaID: string
  }

  export type DiasDisponiveisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiasDisponiveisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    especialistaID?: StringFieldUpdateOperationsInput | string
  }

  export type HorasDisponiveisCreateInput = {
    id?: string
    hora: string
    diasDisponiveis: DiasDisponiveisCreateNestedOneWithoutHorasDisponiveisInput
    especialista: EspecialistasCreateNestedOneWithoutHorasDisponiveisInput
  }

  export type HorasDisponiveisUncheckedCreateInput = {
    id?: string
    hora: string
    diasDisponiveisID: string
    especialistaID: string
  }

  export type HorasDisponiveisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    diasDisponiveis?: DiasDisponiveisUpdateOneRequiredWithoutHorasDisponiveisNestedInput
    especialista?: EspecialistasUpdateOneRequiredWithoutHorasDisponiveisNestedInput
  }

  export type HorasDisponiveisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    diasDisponiveisID?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
  }

  export type HorasDisponiveisCreateManyInput = {
    id?: string
    hora: string
    diasDisponiveisID: string
    especialistaID: string
  }

  export type HorasDisponiveisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
  }

  export type HorasDisponiveisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    diasDisponiveisID?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
  }

  export type ConsultasCreateInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    status: $Enums.Consulta
    especialista: EspecialistasCreateNestedOneWithoutConsultasInput
    usuario: UsuariosCreateNestedOneWithoutConsultasInput
    notificacoes?: NotificacoesCreateNestedManyWithoutConsultaInput
  }

  export type ConsultasUncheckedCreateInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    especialistaID: string
    status: $Enums.Consulta
    pacienteID: string
    notificacoes?: NotificacoesUncheckedCreateNestedManyWithoutConsultaInput
  }

  export type ConsultasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    especialista?: EspecialistasUpdateOneRequiredWithoutConsultasNestedInput
    usuario?: UsuariosUpdateOneRequiredWithoutConsultasNestedInput
    notificacoes?: NotificacoesUpdateManyWithoutConsultaNestedInput
  }

  export type ConsultasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    pacienteID?: StringFieldUpdateOperationsInput | string
    notificacoes?: NotificacoesUncheckedUpdateManyWithoutConsultaNestedInput
  }

  export type ConsultasCreateManyInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    especialistaID: string
    status: $Enums.Consulta
    pacienteID: string
  }

  export type ConsultasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
  }

  export type ConsultasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    pacienteID?: StringFieldUpdateOperationsInput | string
  }

  export type VideoCallCreateInput = {
    id?: string
    emissor: string
    destinatario: string
    offer?: NullableJsonNullValueInput | InputJsonValue
    answer?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VideoCallUncheckedCreateInput = {
    id?: string
    emissor: string
    destinatario: string
    offer?: NullableJsonNullValueInput | InputJsonValue
    answer?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VideoCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emissor?: StringFieldUpdateOperationsInput | string
    destinatario?: StringFieldUpdateOperationsInput | string
    offer?: NullableJsonNullValueInput | InputJsonValue
    answer?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VideoCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emissor?: StringFieldUpdateOperationsInput | string
    destinatario?: StringFieldUpdateOperationsInput | string
    offer?: NullableJsonNullValueInput | InputJsonValue
    answer?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VideoCallCreateManyInput = {
    id?: string
    emissor: string
    destinatario: string
    offer?: NullableJsonNullValueInput | InputJsonValue
    answer?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VideoCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emissor?: StringFieldUpdateOperationsInput | string
    destinatario?: StringFieldUpdateOperationsInput | string
    offer?: NullableJsonNullValueInput | InputJsonValue
    answer?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VideoCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emissor?: StringFieldUpdateOperationsInput | string
    destinatario?: StringFieldUpdateOperationsInput | string
    offer?: NullableJsonNullValueInput | InputJsonValue
    answer?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MinhasConexoesCreateInput = {
    id?: string
    user: UsuariosCreateNestedOneWithoutRemetenteInput
    friend: UsuariosCreateNestedOneWithoutDestinatarioInput
  }

  export type MinhasConexoesUncheckedCreateInput = {
    id?: string
    userID: string
    friendID: string
  }

  export type MinhasConexoesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UsuariosUpdateOneRequiredWithoutRemetenteNestedInput
    friend?: UsuariosUpdateOneRequiredWithoutDestinatarioNestedInput
  }

  export type MinhasConexoesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    friendID?: StringFieldUpdateOperationsInput | string
  }

  export type MinhasConexoesCreateManyInput = {
    id?: string
    userID: string
    friendID: string
  }

  export type MinhasConexoesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type MinhasConexoesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    friendID?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoDeConexaoCreateInput = {
    id?: string
    user: UsuariosCreateNestedOneWithoutEmissorDoPedidoInput
    destinatario: UsuariosCreateNestedOneWithoutReceptorDoPedidoInput
  }

  export type PedidoDeConexaoUncheckedCreateInput = {
    id?: string
    userID: string
    destinatarioID: string
  }

  export type PedidoDeConexaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UsuariosUpdateOneRequiredWithoutEmissorDoPedidoNestedInput
    destinatario?: UsuariosUpdateOneRequiredWithoutReceptorDoPedidoNestedInput
  }

  export type PedidoDeConexaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoDeConexaoCreateManyInput = {
    id?: string
    userID: string
    destinatarioID: string
  }

  export type PedidoDeConexaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoDeConexaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
  }

  export type PartilhaCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UsuariosCreateNestedOneWithoutPartilhaInput
    post: PublicacoesCreateNestedOneWithoutPostPartilhadoInput
    postShare: PublicacoesCreateNestedOneWithoutPostCriadoInput
  }

  export type PartilhaUncheckedCreateInput = {
    id?: string
    userID: string
    createPostShareID: string
    postShareID: string
    createdAt?: Date | string
  }

  export type PartilhaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsuariosUpdateOneRequiredWithoutPartilhaNestedInput
    post?: PublicacoesUpdateOneRequiredWithoutPostPartilhadoNestedInput
    postShare?: PublicacoesUpdateOneRequiredWithoutPostCriadoNestedInput
  }

  export type PartilhaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createPostShareID?: StringFieldUpdateOperationsInput | string
    postShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartilhaCreateManyInput = {
    id?: string
    userID: string
    createPostShareID: string
    postShareID: string
    createdAt?: Date | string
  }

  export type PartilhaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartilhaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createPostShareID?: StringFieldUpdateOperationsInput | string
    postShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnderecoRelationFilter = {
    is?: EnderecoWhereInput
    isNot?: EnderecoWhereInput
  }

  export type ContactosListRelationFilter = {
    every?: ContactosWhereInput
    some?: ContactosWhereInput
    none?: ContactosWhereInput
  }

  export type EspecialistasListRelationFilter = {
    every?: EspecialistasWhereInput
    some?: EspecialistasWhereInput
    none?: EspecialistasWhereInput
  }

  export type SeguidoresListRelationFilter = {
    every?: SeguidoresWhereInput
    some?: SeguidoresWhereInput
    none?: SeguidoresWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ContactosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EspecialistasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeguidoresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntidadesSistemaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    tipo_entidade?: SortOrder
    sobre?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    enderecoID?: SortOrder
  }

  export type EntidadesSistemaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    tipo_entidade?: SortOrder
    sobre?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    enderecoID?: SortOrder
  }

  export type EntidadesSistemaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    tipo_entidade?: SortOrder
    sobre?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    enderecoID?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EntidadesSistemaListRelationFilter = {
    every?: EntidadesSistemaWhereInput
    some?: EntidadesSistemaWhereInput
    none?: EntidadesSistemaWhereInput
  }

  export type EntidadesSistemaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnderecoCountOrderByAggregateInput = {
    id?: SortOrder
    adress?: SortOrder
  }

  export type EnderecoMaxOrderByAggregateInput = {
    id?: SortOrder
    adress?: SortOrder
  }

  export type EnderecoMinOrderByAggregateInput = {
    id?: SortOrder
    adress?: SortOrder
  }

  export type EntidadesSistemaRelationFilter = {
    is?: EntidadesSistemaWhereInput
    isNot?: EntidadesSistemaWhereInput
  }

  export type UsuariosRelationFilter = {
    is?: UsuariosWhereInput
    isNot?: UsuariosWhereInput
  }

  export type ContactosCountOrderByAggregateInput = {
    id?: SortOrder
    contacto?: SortOrder
    entidadeID?: SortOrder
    usuarioID?: SortOrder
  }

  export type ContactosMaxOrderByAggregateInput = {
    id?: SortOrder
    contacto?: SortOrder
    entidadeID?: SortOrder
    usuarioID?: SortOrder
  }

  export type ContactosMinOrderByAggregateInput = {
    id?: SortOrder
    contacto?: SortOrder
    entidadeID?: SortOrder
    usuarioID?: SortOrder
  }

  export type EnumSexoFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[]
    notIn?: $Enums.Sexo[]
    not?: NestedEnumSexoFilter<$PrismaModel> | $Enums.Sexo
  }

  export type EntidadesSistemaNullableRelationFilter = {
    is?: EntidadesSistemaWhereInput | null
    isNot?: EntidadesSistemaWhereInput | null
  }

  export type DiasDisponiveisListRelationFilter = {
    every?: DiasDisponiveisWhereInput
    some?: DiasDisponiveisWhereInput
    none?: DiasDisponiveisWhereInput
  }

  export type HorasDisponiveisListRelationFilter = {
    every?: HorasDisponiveisWhereInput
    some?: HorasDisponiveisWhereInput
    none?: HorasDisponiveisWhereInput
  }

  export type ConsultasListRelationFilter = {
    every?: ConsultasWhereInput
    some?: ConsultasWhereInput
    none?: ConsultasWhereInput
  }

  export type DiasDisponiveisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HorasDisponiveisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EspecialistasCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    crm?: SortOrder
    especialidade?: SortOrder
    tipo_De_Consulta?: SortOrder
    valor?: SortOrder
    bloqueado?: SortOrder
    sexo?: SortOrder
    entidadeID?: SortOrder
  }

  export type EspecialistasMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    crm?: SortOrder
    especialidade?: SortOrder
    tipo_De_Consulta?: SortOrder
    valor?: SortOrder
    bloqueado?: SortOrder
    sexo?: SortOrder
    entidadeID?: SortOrder
  }

  export type EspecialistasMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    crm?: SortOrder
    especialidade?: SortOrder
    tipo_De_Consulta?: SortOrder
    valor?: SortOrder
    bloqueado?: SortOrder
    sexo?: SortOrder
    entidadeID?: SortOrder
  }

  export type EnumSexoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[]
    notIn?: $Enums.Sexo[]
    not?: NestedEnumSexoWithAggregatesFilter<$PrismaModel> | $Enums.Sexo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoFilter<$PrismaModel>
    _max?: NestedEnumSexoFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PublicacoesListRelationFilter = {
    every?: PublicacoesWhereInput
    some?: PublicacoesWhereInput
    none?: PublicacoesWhereInput
  }

  export type NotificacoesListRelationFilter = {
    every?: NotificacoesWhereInput
    some?: NotificacoesWhereInput
    none?: NotificacoesWhereInput
  }

  export type MensagensListRelationFilter = {
    every?: MensagensWhereInput
    some?: MensagensWhereInput
    none?: MensagensWhereInput
  }

  export type MinhasConexoesListRelationFilter = {
    every?: MinhasConexoesWhereInput
    some?: MinhasConexoesWhereInput
    none?: MinhasConexoesWhereInput
  }

  export type PedidoDeConexaoListRelationFilter = {
    every?: PedidoDeConexaoWhereInput
    some?: PedidoDeConexaoWhereInput
    none?: PedidoDeConexaoWhereInput
  }

  export type ReacoesListRelationFilter = {
    every?: ReacoesWhereInput
    some?: ReacoesWhereInput
    none?: ReacoesWhereInput
  }

  export type ComentariosListRelationFilter = {
    every?: ComentariosWhereInput
    some?: ComentariosWhereInput
    none?: ComentariosWhereInput
  }

  export type PartilhaListRelationFilter = {
    every?: PartilhaWhereInput
    some?: PartilhaWhereInput
    none?: PartilhaWhereInput
  }

  export type PublicacoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificacoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MensagensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MinhasConexoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoDeConexaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReacoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartilhaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuariosCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    crm?: SortOrder
    cnpj?: SortOrder
    foto?: SortOrder
    senha?: SortOrder
    sobre?: SortOrder
    sexo?: SortOrder
    socketID?: SortOrder
    nascimento?: SortOrder
  }

  export type UsuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    crm?: SortOrder
    cnpj?: SortOrder
    foto?: SortOrder
    senha?: SortOrder
    sobre?: SortOrder
    sexo?: SortOrder
    socketID?: SortOrder
    nascimento?: SortOrder
  }

  export type UsuariosMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    crm?: SortOrder
    cnpj?: SortOrder
    foto?: SortOrder
    senha?: SortOrder
    sobre?: SortOrder
    sexo?: SortOrder
    socketID?: SortOrder
    nascimento?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PublicacoesCountOrderByAggregateInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrder
    video?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    usuarioID?: SortOrder
  }

  export type PublicacoesMaxOrderByAggregateInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrder
    video?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    usuarioID?: SortOrder
  }

  export type PublicacoesMinOrderByAggregateInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrder
    video?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    usuarioID?: SortOrder
  }

  export type PublicacoesRelationFilter = {
    is?: PublicacoesWhereInput
    isNot?: PublicacoesWhereInput
  }

  export type ComentariosCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    autorId?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComentariosMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    autorId?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComentariosMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    autorId?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReacoesCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReacoesMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReacoesMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultasRelationFilter = {
    is?: ConsultasWhereInput
    isNot?: ConsultasWhereInput
  }

  export type NotificacoesCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    usuarioID?: SortOrder
    destinatarioID?: SortOrder
    consultaID?: SortOrder
    postID?: SortOrder
    tipo?: SortOrder
    visto?: SortOrder
  }

  export type NotificacoesMaxOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    usuarioID?: SortOrder
    destinatarioID?: SortOrder
    consultaID?: SortOrder
    postID?: SortOrder
    tipo?: SortOrder
    visto?: SortOrder
  }

  export type NotificacoesMinOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    usuarioID?: SortOrder
    destinatarioID?: SortOrder
    consultaID?: SortOrder
    postID?: SortOrder
    tipo?: SortOrder
    visto?: SortOrder
  }

  export type SeguidoresCountOrderByAggregateInput = {
    id?: SortOrder
    seguidorID?: SortOrder
    entidadeID?: SortOrder
  }

  export type SeguidoresMaxOrderByAggregateInput = {
    id?: SortOrder
    seguidorID?: SortOrder
    entidadeID?: SortOrder
  }

  export type SeguidoresMinOrderByAggregateInput = {
    id?: SortOrder
    seguidorID?: SortOrder
    entidadeID?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MensagensCountOrderByAggregateInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrder
    video?: SortOrder
    arquivo?: SortOrder
    data?: SortOrder
    emissorID?: SortOrder
    receptorID?: SortOrder
    visto?: SortOrder
  }

  export type MensagensMaxOrderByAggregateInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrder
    video?: SortOrder
    arquivo?: SortOrder
    data?: SortOrder
    emissorID?: SortOrder
    receptorID?: SortOrder
    visto?: SortOrder
  }

  export type MensagensMinOrderByAggregateInput = {
    id?: SortOrder
    conteudo?: SortOrder
    foto?: SortOrder
    video?: SortOrder
    arquivo?: SortOrder
    data?: SortOrder
    emissorID?: SortOrder
    receptorID?: SortOrder
    visto?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EspecialistasRelationFilter = {
    is?: EspecialistasWhereInput
    isNot?: EspecialistasWhereInput
  }

  export type DiasDisponiveisCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    especialistaID?: SortOrder
  }

  export type DiasDisponiveisMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    especialistaID?: SortOrder
  }

  export type DiasDisponiveisMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    especialistaID?: SortOrder
  }

  export type DiasDisponiveisRelationFilter = {
    is?: DiasDisponiveisWhereInput
    isNot?: DiasDisponiveisWhereInput
  }

  export type HorasDisponiveisCountOrderByAggregateInput = {
    id?: SortOrder
    hora?: SortOrder
    diasDisponiveisID?: SortOrder
    especialistaID?: SortOrder
  }

  export type HorasDisponiveisMaxOrderByAggregateInput = {
    id?: SortOrder
    hora?: SortOrder
    diasDisponiveisID?: SortOrder
    especialistaID?: SortOrder
  }

  export type HorasDisponiveisMinOrderByAggregateInput = {
    id?: SortOrder
    hora?: SortOrder
    diasDisponiveisID?: SortOrder
    especialistaID?: SortOrder
  }

  export type EnumConsultaFilter<$PrismaModel = never> = {
    equals?: $Enums.Consulta | EnumConsultaFieldRefInput<$PrismaModel>
    in?: $Enums.Consulta[]
    notIn?: $Enums.Consulta[]
    not?: NestedEnumConsultaFilter<$PrismaModel> | $Enums.Consulta
  }

  export type ConsultasCountOrderByAggregateInput = {
    id?: SortOrder
    tipo_Da_Consulta?: SortOrder
    data?: SortOrder
    hora?: SortOrder
    especialistaID?: SortOrder
    status?: SortOrder
    pacienteID?: SortOrder
  }

  export type ConsultasMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo_Da_Consulta?: SortOrder
    data?: SortOrder
    hora?: SortOrder
    especialistaID?: SortOrder
    status?: SortOrder
    pacienteID?: SortOrder
  }

  export type ConsultasMinOrderByAggregateInput = {
    id?: SortOrder
    tipo_Da_Consulta?: SortOrder
    data?: SortOrder
    hora?: SortOrder
    especialistaID?: SortOrder
    status?: SortOrder
    pacienteID?: SortOrder
  }

  export type EnumConsultaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Consulta | EnumConsultaFieldRefInput<$PrismaModel>
    in?: $Enums.Consulta[]
    notIn?: $Enums.Consulta[]
    not?: NestedEnumConsultaWithAggregatesFilter<$PrismaModel> | $Enums.Consulta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultaFilter<$PrismaModel>
    _max?: NestedEnumConsultaFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VideoCallCountOrderByAggregateInput = {
    id?: SortOrder
    emissor?: SortOrder
    destinatario?: SortOrder
    offer?: SortOrder
    answer?: SortOrder
  }

  export type VideoCallMaxOrderByAggregateInput = {
    id?: SortOrder
    emissor?: SortOrder
    destinatario?: SortOrder
  }

  export type VideoCallMinOrderByAggregateInput = {
    id?: SortOrder
    emissor?: SortOrder
    destinatario?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MinhasConexoesCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    friendID?: SortOrder
  }

  export type MinhasConexoesMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    friendID?: SortOrder
  }

  export type MinhasConexoesMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    friendID?: SortOrder
  }

  export type PedidoDeConexaoCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    destinatarioID?: SortOrder
  }

  export type PedidoDeConexaoMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    destinatarioID?: SortOrder
  }

  export type PedidoDeConexaoMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    destinatarioID?: SortOrder
  }

  export type PartilhaCountOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    createPostShareID?: SortOrder
    postShareID?: SortOrder
    createdAt?: SortOrder
  }

  export type PartilhaMaxOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    createPostShareID?: SortOrder
    postShareID?: SortOrder
    createdAt?: SortOrder
  }

  export type PartilhaMinOrderByAggregateInput = {
    id?: SortOrder
    userID?: SortOrder
    createPostShareID?: SortOrder
    postShareID?: SortOrder
    createdAt?: SortOrder
  }

  export type EnderecoCreateNestedOneWithoutEntitieInput = {
    create?: XOR<EnderecoCreateWithoutEntitieInput, EnderecoUncheckedCreateWithoutEntitieInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutEntitieInput
    connect?: EnderecoWhereUniqueInput
  }

  export type ContactosCreateNestedManyWithoutEntidadeInput = {
    create?: XOR<ContactosCreateWithoutEntidadeInput, ContactosUncheckedCreateWithoutEntidadeInput> | ContactosCreateWithoutEntidadeInput[] | ContactosUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutEntidadeInput | ContactosCreateOrConnectWithoutEntidadeInput[]
    createMany?: ContactosCreateManyEntidadeInputEnvelope
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
  }

  export type EspecialistasCreateNestedManyWithoutEntidadeInput = {
    create?: XOR<EspecialistasCreateWithoutEntidadeInput, EspecialistasUncheckedCreateWithoutEntidadeInput> | EspecialistasCreateWithoutEntidadeInput[] | EspecialistasUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: EspecialistasCreateOrConnectWithoutEntidadeInput | EspecialistasCreateOrConnectWithoutEntidadeInput[]
    createMany?: EspecialistasCreateManyEntidadeInputEnvelope
    connect?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
  }

  export type SeguidoresCreateNestedManyWithoutEntidadeInput = {
    create?: XOR<SeguidoresCreateWithoutEntidadeInput, SeguidoresUncheckedCreateWithoutEntidadeInput> | SeguidoresCreateWithoutEntidadeInput[] | SeguidoresUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutEntidadeInput | SeguidoresCreateOrConnectWithoutEntidadeInput[]
    createMany?: SeguidoresCreateManyEntidadeInputEnvelope
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
  }

  export type ContactosUncheckedCreateNestedManyWithoutEntidadeInput = {
    create?: XOR<ContactosCreateWithoutEntidadeInput, ContactosUncheckedCreateWithoutEntidadeInput> | ContactosCreateWithoutEntidadeInput[] | ContactosUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutEntidadeInput | ContactosCreateOrConnectWithoutEntidadeInput[]
    createMany?: ContactosCreateManyEntidadeInputEnvelope
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
  }

  export type EspecialistasUncheckedCreateNestedManyWithoutEntidadeInput = {
    create?: XOR<EspecialistasCreateWithoutEntidadeInput, EspecialistasUncheckedCreateWithoutEntidadeInput> | EspecialistasCreateWithoutEntidadeInput[] | EspecialistasUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: EspecialistasCreateOrConnectWithoutEntidadeInput | EspecialistasCreateOrConnectWithoutEntidadeInput[]
    createMany?: EspecialistasCreateManyEntidadeInputEnvelope
    connect?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
  }

  export type SeguidoresUncheckedCreateNestedManyWithoutEntidadeInput = {
    create?: XOR<SeguidoresCreateWithoutEntidadeInput, SeguidoresUncheckedCreateWithoutEntidadeInput> | SeguidoresCreateWithoutEntidadeInput[] | SeguidoresUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutEntidadeInput | SeguidoresCreateOrConnectWithoutEntidadeInput[]
    createMany?: SeguidoresCreateManyEntidadeInputEnvelope
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnderecoUpdateOneRequiredWithoutEntitieNestedInput = {
    create?: XOR<EnderecoCreateWithoutEntitieInput, EnderecoUncheckedCreateWithoutEntitieInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutEntitieInput
    upsert?: EnderecoUpsertWithoutEntitieInput
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutEntitieInput, EnderecoUpdateWithoutEntitieInput>, EnderecoUncheckedUpdateWithoutEntitieInput>
  }

  export type ContactosUpdateManyWithoutEntidadeNestedInput = {
    create?: XOR<ContactosCreateWithoutEntidadeInput, ContactosUncheckedCreateWithoutEntidadeInput> | ContactosCreateWithoutEntidadeInput[] | ContactosUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutEntidadeInput | ContactosCreateOrConnectWithoutEntidadeInput[]
    upsert?: ContactosUpsertWithWhereUniqueWithoutEntidadeInput | ContactosUpsertWithWhereUniqueWithoutEntidadeInput[]
    createMany?: ContactosCreateManyEntidadeInputEnvelope
    set?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    disconnect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    delete?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    update?: ContactosUpdateWithWhereUniqueWithoutEntidadeInput | ContactosUpdateWithWhereUniqueWithoutEntidadeInput[]
    updateMany?: ContactosUpdateManyWithWhereWithoutEntidadeInput | ContactosUpdateManyWithWhereWithoutEntidadeInput[]
    deleteMany?: ContactosScalarWhereInput | ContactosScalarWhereInput[]
  }

  export type EspecialistasUpdateManyWithoutEntidadeNestedInput = {
    create?: XOR<EspecialistasCreateWithoutEntidadeInput, EspecialistasUncheckedCreateWithoutEntidadeInput> | EspecialistasCreateWithoutEntidadeInput[] | EspecialistasUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: EspecialistasCreateOrConnectWithoutEntidadeInput | EspecialistasCreateOrConnectWithoutEntidadeInput[]
    upsert?: EspecialistasUpsertWithWhereUniqueWithoutEntidadeInput | EspecialistasUpsertWithWhereUniqueWithoutEntidadeInput[]
    createMany?: EspecialistasCreateManyEntidadeInputEnvelope
    set?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    disconnect?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    delete?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    connect?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    update?: EspecialistasUpdateWithWhereUniqueWithoutEntidadeInput | EspecialistasUpdateWithWhereUniqueWithoutEntidadeInput[]
    updateMany?: EspecialistasUpdateManyWithWhereWithoutEntidadeInput | EspecialistasUpdateManyWithWhereWithoutEntidadeInput[]
    deleteMany?: EspecialistasScalarWhereInput | EspecialistasScalarWhereInput[]
  }

  export type SeguidoresUpdateManyWithoutEntidadeNestedInput = {
    create?: XOR<SeguidoresCreateWithoutEntidadeInput, SeguidoresUncheckedCreateWithoutEntidadeInput> | SeguidoresCreateWithoutEntidadeInput[] | SeguidoresUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutEntidadeInput | SeguidoresCreateOrConnectWithoutEntidadeInput[]
    upsert?: SeguidoresUpsertWithWhereUniqueWithoutEntidadeInput | SeguidoresUpsertWithWhereUniqueWithoutEntidadeInput[]
    createMany?: SeguidoresCreateManyEntidadeInputEnvelope
    set?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    disconnect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    delete?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    update?: SeguidoresUpdateWithWhereUniqueWithoutEntidadeInput | SeguidoresUpdateWithWhereUniqueWithoutEntidadeInput[]
    updateMany?: SeguidoresUpdateManyWithWhereWithoutEntidadeInput | SeguidoresUpdateManyWithWhereWithoutEntidadeInput[]
    deleteMany?: SeguidoresScalarWhereInput | SeguidoresScalarWhereInput[]
  }

  export type ContactosUncheckedUpdateManyWithoutEntidadeNestedInput = {
    create?: XOR<ContactosCreateWithoutEntidadeInput, ContactosUncheckedCreateWithoutEntidadeInput> | ContactosCreateWithoutEntidadeInput[] | ContactosUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutEntidadeInput | ContactosCreateOrConnectWithoutEntidadeInput[]
    upsert?: ContactosUpsertWithWhereUniqueWithoutEntidadeInput | ContactosUpsertWithWhereUniqueWithoutEntidadeInput[]
    createMany?: ContactosCreateManyEntidadeInputEnvelope
    set?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    disconnect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    delete?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    update?: ContactosUpdateWithWhereUniqueWithoutEntidadeInput | ContactosUpdateWithWhereUniqueWithoutEntidadeInput[]
    updateMany?: ContactosUpdateManyWithWhereWithoutEntidadeInput | ContactosUpdateManyWithWhereWithoutEntidadeInput[]
    deleteMany?: ContactosScalarWhereInput | ContactosScalarWhereInput[]
  }

  export type EspecialistasUncheckedUpdateManyWithoutEntidadeNestedInput = {
    create?: XOR<EspecialistasCreateWithoutEntidadeInput, EspecialistasUncheckedCreateWithoutEntidadeInput> | EspecialistasCreateWithoutEntidadeInput[] | EspecialistasUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: EspecialistasCreateOrConnectWithoutEntidadeInput | EspecialistasCreateOrConnectWithoutEntidadeInput[]
    upsert?: EspecialistasUpsertWithWhereUniqueWithoutEntidadeInput | EspecialistasUpsertWithWhereUniqueWithoutEntidadeInput[]
    createMany?: EspecialistasCreateManyEntidadeInputEnvelope
    set?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    disconnect?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    delete?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    connect?: EspecialistasWhereUniqueInput | EspecialistasWhereUniqueInput[]
    update?: EspecialistasUpdateWithWhereUniqueWithoutEntidadeInput | EspecialistasUpdateWithWhereUniqueWithoutEntidadeInput[]
    updateMany?: EspecialistasUpdateManyWithWhereWithoutEntidadeInput | EspecialistasUpdateManyWithWhereWithoutEntidadeInput[]
    deleteMany?: EspecialistasScalarWhereInput | EspecialistasScalarWhereInput[]
  }

  export type SeguidoresUncheckedUpdateManyWithoutEntidadeNestedInput = {
    create?: XOR<SeguidoresCreateWithoutEntidadeInput, SeguidoresUncheckedCreateWithoutEntidadeInput> | SeguidoresCreateWithoutEntidadeInput[] | SeguidoresUncheckedCreateWithoutEntidadeInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutEntidadeInput | SeguidoresCreateOrConnectWithoutEntidadeInput[]
    upsert?: SeguidoresUpsertWithWhereUniqueWithoutEntidadeInput | SeguidoresUpsertWithWhereUniqueWithoutEntidadeInput[]
    createMany?: SeguidoresCreateManyEntidadeInputEnvelope
    set?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    disconnect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    delete?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    update?: SeguidoresUpdateWithWhereUniqueWithoutEntidadeInput | SeguidoresUpdateWithWhereUniqueWithoutEntidadeInput[]
    updateMany?: SeguidoresUpdateManyWithWhereWithoutEntidadeInput | SeguidoresUpdateManyWithWhereWithoutEntidadeInput[]
    deleteMany?: SeguidoresScalarWhereInput | SeguidoresScalarWhereInput[]
  }

  export type EntidadesSistemaCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EntidadesSistemaCreateWithoutEnderecoInput, EntidadesSistemaUncheckedCreateWithoutEnderecoInput> | EntidadesSistemaCreateWithoutEnderecoInput[] | EntidadesSistemaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutEnderecoInput | EntidadesSistemaCreateOrConnectWithoutEnderecoInput[]
    createMany?: EntidadesSistemaCreateManyEnderecoInputEnvelope
    connect?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
  }

  export type EntidadesSistemaUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EntidadesSistemaCreateWithoutEnderecoInput, EntidadesSistemaUncheckedCreateWithoutEnderecoInput> | EntidadesSistemaCreateWithoutEnderecoInput[] | EntidadesSistemaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutEnderecoInput | EntidadesSistemaCreateOrConnectWithoutEnderecoInput[]
    createMany?: EntidadesSistemaCreateManyEnderecoInputEnvelope
    connect?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
  }

  export type EntidadesSistemaUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EntidadesSistemaCreateWithoutEnderecoInput, EntidadesSistemaUncheckedCreateWithoutEnderecoInput> | EntidadesSistemaCreateWithoutEnderecoInput[] | EntidadesSistemaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutEnderecoInput | EntidadesSistemaCreateOrConnectWithoutEnderecoInput[]
    upsert?: EntidadesSistemaUpsertWithWhereUniqueWithoutEnderecoInput | EntidadesSistemaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EntidadesSistemaCreateManyEnderecoInputEnvelope
    set?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    disconnect?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    delete?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    connect?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    update?: EntidadesSistemaUpdateWithWhereUniqueWithoutEnderecoInput | EntidadesSistemaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EntidadesSistemaUpdateManyWithWhereWithoutEnderecoInput | EntidadesSistemaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EntidadesSistemaScalarWhereInput | EntidadesSistemaScalarWhereInput[]
  }

  export type EntidadesSistemaUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EntidadesSistemaCreateWithoutEnderecoInput, EntidadesSistemaUncheckedCreateWithoutEnderecoInput> | EntidadesSistemaCreateWithoutEnderecoInput[] | EntidadesSistemaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutEnderecoInput | EntidadesSistemaCreateOrConnectWithoutEnderecoInput[]
    upsert?: EntidadesSistemaUpsertWithWhereUniqueWithoutEnderecoInput | EntidadesSistemaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EntidadesSistemaCreateManyEnderecoInputEnvelope
    set?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    disconnect?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    delete?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    connect?: EntidadesSistemaWhereUniqueInput | EntidadesSistemaWhereUniqueInput[]
    update?: EntidadesSistemaUpdateWithWhereUniqueWithoutEnderecoInput | EntidadesSistemaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EntidadesSistemaUpdateManyWithWhereWithoutEnderecoInput | EntidadesSistemaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EntidadesSistemaScalarWhereInput | EntidadesSistemaScalarWhereInput[]
  }

  export type EntidadesSistemaCreateNestedOneWithoutContactosInput = {
    create?: XOR<EntidadesSistemaCreateWithoutContactosInput, EntidadesSistemaUncheckedCreateWithoutContactosInput>
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutContactosInput
    connect?: EntidadesSistemaWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutContactosInput = {
    create?: XOR<UsuariosCreateWithoutContactosInput, UsuariosUncheckedCreateWithoutContactosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutContactosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type EntidadesSistemaUpdateOneRequiredWithoutContactosNestedInput = {
    create?: XOR<EntidadesSistemaCreateWithoutContactosInput, EntidadesSistemaUncheckedCreateWithoutContactosInput>
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutContactosInput
    upsert?: EntidadesSistemaUpsertWithoutContactosInput
    connect?: EntidadesSistemaWhereUniqueInput
    update?: XOR<XOR<EntidadesSistemaUpdateToOneWithWhereWithoutContactosInput, EntidadesSistemaUpdateWithoutContactosInput>, EntidadesSistemaUncheckedUpdateWithoutContactosInput>
  }

  export type UsuariosUpdateOneRequiredWithoutContactosNestedInput = {
    create?: XOR<UsuariosCreateWithoutContactosInput, UsuariosUncheckedCreateWithoutContactosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutContactosInput
    upsert?: UsuariosUpsertWithoutContactosInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutContactosInput, UsuariosUpdateWithoutContactosInput>, UsuariosUncheckedUpdateWithoutContactosInput>
  }

  export type EntidadesSistemaCreateNestedOneWithoutEspecialistaInput = {
    create?: XOR<EntidadesSistemaCreateWithoutEspecialistaInput, EntidadesSistemaUncheckedCreateWithoutEspecialistaInput>
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutEspecialistaInput
    connect?: EntidadesSistemaWhereUniqueInput
  }

  export type DiasDisponiveisCreateNestedManyWithoutEspecialistaInput = {
    create?: XOR<DiasDisponiveisCreateWithoutEspecialistaInput, DiasDisponiveisUncheckedCreateWithoutEspecialistaInput> | DiasDisponiveisCreateWithoutEspecialistaInput[] | DiasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: DiasDisponiveisCreateOrConnectWithoutEspecialistaInput | DiasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    createMany?: DiasDisponiveisCreateManyEspecialistaInputEnvelope
    connect?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
  }

  export type HorasDisponiveisCreateNestedManyWithoutEspecialistaInput = {
    create?: XOR<HorasDisponiveisCreateWithoutEspecialistaInput, HorasDisponiveisUncheckedCreateWithoutEspecialistaInput> | HorasDisponiveisCreateWithoutEspecialistaInput[] | HorasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutEspecialistaInput | HorasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    createMany?: HorasDisponiveisCreateManyEspecialistaInputEnvelope
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
  }

  export type ConsultasCreateNestedManyWithoutEspecialistaInput = {
    create?: XOR<ConsultasCreateWithoutEspecialistaInput, ConsultasUncheckedCreateWithoutEspecialistaInput> | ConsultasCreateWithoutEspecialistaInput[] | ConsultasUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutEspecialistaInput | ConsultasCreateOrConnectWithoutEspecialistaInput[]
    createMany?: ConsultasCreateManyEspecialistaInputEnvelope
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
  }

  export type DiasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput = {
    create?: XOR<DiasDisponiveisCreateWithoutEspecialistaInput, DiasDisponiveisUncheckedCreateWithoutEspecialistaInput> | DiasDisponiveisCreateWithoutEspecialistaInput[] | DiasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: DiasDisponiveisCreateOrConnectWithoutEspecialistaInput | DiasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    createMany?: DiasDisponiveisCreateManyEspecialistaInputEnvelope
    connect?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
  }

  export type HorasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput = {
    create?: XOR<HorasDisponiveisCreateWithoutEspecialistaInput, HorasDisponiveisUncheckedCreateWithoutEspecialistaInput> | HorasDisponiveisCreateWithoutEspecialistaInput[] | HorasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutEspecialistaInput | HorasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    createMany?: HorasDisponiveisCreateManyEspecialistaInputEnvelope
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
  }

  export type ConsultasUncheckedCreateNestedManyWithoutEspecialistaInput = {
    create?: XOR<ConsultasCreateWithoutEspecialistaInput, ConsultasUncheckedCreateWithoutEspecialistaInput> | ConsultasCreateWithoutEspecialistaInput[] | ConsultasUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutEspecialistaInput | ConsultasCreateOrConnectWithoutEspecialistaInput[]
    createMany?: ConsultasCreateManyEspecialistaInputEnvelope
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
  }

  export type EnumSexoFieldUpdateOperationsInput = {
    set?: $Enums.Sexo
  }

  export type EntidadesSistemaUpdateOneWithoutEspecialistaNestedInput = {
    create?: XOR<EntidadesSistemaCreateWithoutEspecialistaInput, EntidadesSistemaUncheckedCreateWithoutEspecialistaInput>
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutEspecialistaInput
    upsert?: EntidadesSistemaUpsertWithoutEspecialistaInput
    disconnect?: EntidadesSistemaWhereInput | boolean
    delete?: EntidadesSistemaWhereInput | boolean
    connect?: EntidadesSistemaWhereUniqueInput
    update?: XOR<XOR<EntidadesSistemaUpdateToOneWithWhereWithoutEspecialistaInput, EntidadesSistemaUpdateWithoutEspecialistaInput>, EntidadesSistemaUncheckedUpdateWithoutEspecialistaInput>
  }

  export type DiasDisponiveisUpdateManyWithoutEspecialistaNestedInput = {
    create?: XOR<DiasDisponiveisCreateWithoutEspecialistaInput, DiasDisponiveisUncheckedCreateWithoutEspecialistaInput> | DiasDisponiveisCreateWithoutEspecialistaInput[] | DiasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: DiasDisponiveisCreateOrConnectWithoutEspecialistaInput | DiasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    upsert?: DiasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput | DiasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput[]
    createMany?: DiasDisponiveisCreateManyEspecialistaInputEnvelope
    set?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    disconnect?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    delete?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    connect?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    update?: DiasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput | DiasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput[]
    updateMany?: DiasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput | DiasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput[]
    deleteMany?: DiasDisponiveisScalarWhereInput | DiasDisponiveisScalarWhereInput[]
  }

  export type HorasDisponiveisUpdateManyWithoutEspecialistaNestedInput = {
    create?: XOR<HorasDisponiveisCreateWithoutEspecialistaInput, HorasDisponiveisUncheckedCreateWithoutEspecialistaInput> | HorasDisponiveisCreateWithoutEspecialistaInput[] | HorasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutEspecialistaInput | HorasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    upsert?: HorasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput | HorasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput[]
    createMany?: HorasDisponiveisCreateManyEspecialistaInputEnvelope
    set?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    disconnect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    delete?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    update?: HorasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput | HorasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput[]
    updateMany?: HorasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput | HorasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput[]
    deleteMany?: HorasDisponiveisScalarWhereInput | HorasDisponiveisScalarWhereInput[]
  }

  export type ConsultasUpdateManyWithoutEspecialistaNestedInput = {
    create?: XOR<ConsultasCreateWithoutEspecialistaInput, ConsultasUncheckedCreateWithoutEspecialistaInput> | ConsultasCreateWithoutEspecialistaInput[] | ConsultasUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutEspecialistaInput | ConsultasCreateOrConnectWithoutEspecialistaInput[]
    upsert?: ConsultasUpsertWithWhereUniqueWithoutEspecialistaInput | ConsultasUpsertWithWhereUniqueWithoutEspecialistaInput[]
    createMany?: ConsultasCreateManyEspecialistaInputEnvelope
    set?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    disconnect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    delete?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    update?: ConsultasUpdateWithWhereUniqueWithoutEspecialistaInput | ConsultasUpdateWithWhereUniqueWithoutEspecialistaInput[]
    updateMany?: ConsultasUpdateManyWithWhereWithoutEspecialistaInput | ConsultasUpdateManyWithWhereWithoutEspecialistaInput[]
    deleteMany?: ConsultasScalarWhereInput | ConsultasScalarWhereInput[]
  }

  export type DiasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput = {
    create?: XOR<DiasDisponiveisCreateWithoutEspecialistaInput, DiasDisponiveisUncheckedCreateWithoutEspecialistaInput> | DiasDisponiveisCreateWithoutEspecialistaInput[] | DiasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: DiasDisponiveisCreateOrConnectWithoutEspecialistaInput | DiasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    upsert?: DiasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput | DiasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput[]
    createMany?: DiasDisponiveisCreateManyEspecialistaInputEnvelope
    set?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    disconnect?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    delete?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    connect?: DiasDisponiveisWhereUniqueInput | DiasDisponiveisWhereUniqueInput[]
    update?: DiasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput | DiasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput[]
    updateMany?: DiasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput | DiasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput[]
    deleteMany?: DiasDisponiveisScalarWhereInput | DiasDisponiveisScalarWhereInput[]
  }

  export type HorasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput = {
    create?: XOR<HorasDisponiveisCreateWithoutEspecialistaInput, HorasDisponiveisUncheckedCreateWithoutEspecialistaInput> | HorasDisponiveisCreateWithoutEspecialistaInput[] | HorasDisponiveisUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutEspecialistaInput | HorasDisponiveisCreateOrConnectWithoutEspecialistaInput[]
    upsert?: HorasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput | HorasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput[]
    createMany?: HorasDisponiveisCreateManyEspecialistaInputEnvelope
    set?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    disconnect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    delete?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    update?: HorasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput | HorasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput[]
    updateMany?: HorasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput | HorasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput[]
    deleteMany?: HorasDisponiveisScalarWhereInput | HorasDisponiveisScalarWhereInput[]
  }

  export type ConsultasUncheckedUpdateManyWithoutEspecialistaNestedInput = {
    create?: XOR<ConsultasCreateWithoutEspecialistaInput, ConsultasUncheckedCreateWithoutEspecialistaInput> | ConsultasCreateWithoutEspecialistaInput[] | ConsultasUncheckedCreateWithoutEspecialistaInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutEspecialistaInput | ConsultasCreateOrConnectWithoutEspecialistaInput[]
    upsert?: ConsultasUpsertWithWhereUniqueWithoutEspecialistaInput | ConsultasUpsertWithWhereUniqueWithoutEspecialistaInput[]
    createMany?: ConsultasCreateManyEspecialistaInputEnvelope
    set?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    disconnect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    delete?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    update?: ConsultasUpdateWithWhereUniqueWithoutEspecialistaInput | ConsultasUpdateWithWhereUniqueWithoutEspecialistaInput[]
    updateMany?: ConsultasUpdateManyWithWhereWithoutEspecialistaInput | ConsultasUpdateManyWithWhereWithoutEspecialistaInput[]
    deleteMany?: ConsultasScalarWhereInput | ConsultasScalarWhereInput[]
  }

  export type ContactosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ContactosCreateWithoutUsuarioInput, ContactosUncheckedCreateWithoutUsuarioInput> | ContactosCreateWithoutUsuarioInput[] | ContactosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutUsuarioInput | ContactosCreateOrConnectWithoutUsuarioInput[]
    createMany?: ContactosCreateManyUsuarioInputEnvelope
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
  }

  export type PublicacoesCreateNestedManyWithoutUsuarioPubInput = {
    create?: XOR<PublicacoesCreateWithoutUsuarioPubInput, PublicacoesUncheckedCreateWithoutUsuarioPubInput> | PublicacoesCreateWithoutUsuarioPubInput[] | PublicacoesUncheckedCreateWithoutUsuarioPubInput[]
    connectOrCreate?: PublicacoesCreateOrConnectWithoutUsuarioPubInput | PublicacoesCreateOrConnectWithoutUsuarioPubInput[]
    createMany?: PublicacoesCreateManyUsuarioPubInputEnvelope
    connect?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
  }

  export type NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput = {
    create?: XOR<NotificacoesCreateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput> | NotificacoesCreateWithoutUsuarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput | NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyUsuarioNotificacaoInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput = {
    create?: XOR<NotificacoesCreateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput> | NotificacoesCreateWithoutDestinatarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput | NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyDestinatarioNotificacaoInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type ConsultasCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ConsultasCreateWithoutUsuarioInput, ConsultasUncheckedCreateWithoutUsuarioInput> | ConsultasCreateWithoutUsuarioInput[] | ConsultasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutUsuarioInput | ConsultasCreateOrConnectWithoutUsuarioInput[]
    createMany?: ConsultasCreateManyUsuarioInputEnvelope
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
  }

  export type MensagensCreateNestedManyWithoutEmissorInput = {
    create?: XOR<MensagensCreateWithoutEmissorInput, MensagensUncheckedCreateWithoutEmissorInput> | MensagensCreateWithoutEmissorInput[] | MensagensUncheckedCreateWithoutEmissorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutEmissorInput | MensagensCreateOrConnectWithoutEmissorInput[]
    createMany?: MensagensCreateManyEmissorInputEnvelope
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
  }

  export type MensagensCreateNestedManyWithoutReceptorInput = {
    create?: XOR<MensagensCreateWithoutReceptorInput, MensagensUncheckedCreateWithoutReceptorInput> | MensagensCreateWithoutReceptorInput[] | MensagensUncheckedCreateWithoutReceptorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutReceptorInput | MensagensCreateOrConnectWithoutReceptorInput[]
    createMany?: MensagensCreateManyReceptorInputEnvelope
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
  }

  export type MinhasConexoesCreateNestedManyWithoutUserInput = {
    create?: XOR<MinhasConexoesCreateWithoutUserInput, MinhasConexoesUncheckedCreateWithoutUserInput> | MinhasConexoesCreateWithoutUserInput[] | MinhasConexoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutUserInput | MinhasConexoesCreateOrConnectWithoutUserInput[]
    createMany?: MinhasConexoesCreateManyUserInputEnvelope
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
  }

  export type MinhasConexoesCreateNestedManyWithoutFriendInput = {
    create?: XOR<MinhasConexoesCreateWithoutFriendInput, MinhasConexoesUncheckedCreateWithoutFriendInput> | MinhasConexoesCreateWithoutFriendInput[] | MinhasConexoesUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutFriendInput | MinhasConexoesCreateOrConnectWithoutFriendInput[]
    createMany?: MinhasConexoesCreateManyFriendInputEnvelope
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
  }

  export type PedidoDeConexaoCreateNestedManyWithoutUserInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutUserInput, PedidoDeConexaoUncheckedCreateWithoutUserInput> | PedidoDeConexaoCreateWithoutUserInput[] | PedidoDeConexaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutUserInput | PedidoDeConexaoCreateOrConnectWithoutUserInput[]
    createMany?: PedidoDeConexaoCreateManyUserInputEnvelope
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
  }

  export type PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutDestinatarioInput, PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput> | PedidoDeConexaoCreateWithoutDestinatarioInput[] | PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput | PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput[]
    createMany?: PedidoDeConexaoCreateManyDestinatarioInputEnvelope
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
  }

  export type ReacoesCreateNestedManyWithoutUserInput = {
    create?: XOR<ReacoesCreateWithoutUserInput, ReacoesUncheckedCreateWithoutUserInput> | ReacoesCreateWithoutUserInput[] | ReacoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutUserInput | ReacoesCreateOrConnectWithoutUserInput[]
    createMany?: ReacoesCreateManyUserInputEnvelope
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
  }

  export type ComentariosCreateNestedManyWithoutAutorInput = {
    create?: XOR<ComentariosCreateWithoutAutorInput, ComentariosUncheckedCreateWithoutAutorInput> | ComentariosCreateWithoutAutorInput[] | ComentariosUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutAutorInput | ComentariosCreateOrConnectWithoutAutorInput[]
    createMany?: ComentariosCreateManyAutorInputEnvelope
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
  }

  export type SeguidoresCreateNestedManyWithoutSeguidorInput = {
    create?: XOR<SeguidoresCreateWithoutSeguidorInput, SeguidoresUncheckedCreateWithoutSeguidorInput> | SeguidoresCreateWithoutSeguidorInput[] | SeguidoresUncheckedCreateWithoutSeguidorInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutSeguidorInput | SeguidoresCreateOrConnectWithoutSeguidorInput[]
    createMany?: SeguidoresCreateManySeguidorInputEnvelope
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
  }

  export type PartilhaCreateNestedManyWithoutUserInput = {
    create?: XOR<PartilhaCreateWithoutUserInput, PartilhaUncheckedCreateWithoutUserInput> | PartilhaCreateWithoutUserInput[] | PartilhaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutUserInput | PartilhaCreateOrConnectWithoutUserInput[]
    createMany?: PartilhaCreateManyUserInputEnvelope
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
  }

  export type ContactosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ContactosCreateWithoutUsuarioInput, ContactosUncheckedCreateWithoutUsuarioInput> | ContactosCreateWithoutUsuarioInput[] | ContactosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutUsuarioInput | ContactosCreateOrConnectWithoutUsuarioInput[]
    createMany?: ContactosCreateManyUsuarioInputEnvelope
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
  }

  export type PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput = {
    create?: XOR<PublicacoesCreateWithoutUsuarioPubInput, PublicacoesUncheckedCreateWithoutUsuarioPubInput> | PublicacoesCreateWithoutUsuarioPubInput[] | PublicacoesUncheckedCreateWithoutUsuarioPubInput[]
    connectOrCreate?: PublicacoesCreateOrConnectWithoutUsuarioPubInput | PublicacoesCreateOrConnectWithoutUsuarioPubInput[]
    createMany?: PublicacoesCreateManyUsuarioPubInputEnvelope
    connect?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
  }

  export type NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput = {
    create?: XOR<NotificacoesCreateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput> | NotificacoesCreateWithoutUsuarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput | NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyUsuarioNotificacaoInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput = {
    create?: XOR<NotificacoesCreateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput> | NotificacoesCreateWithoutDestinatarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput | NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyDestinatarioNotificacaoInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type ConsultasUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ConsultasCreateWithoutUsuarioInput, ConsultasUncheckedCreateWithoutUsuarioInput> | ConsultasCreateWithoutUsuarioInput[] | ConsultasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutUsuarioInput | ConsultasCreateOrConnectWithoutUsuarioInput[]
    createMany?: ConsultasCreateManyUsuarioInputEnvelope
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
  }

  export type MensagensUncheckedCreateNestedManyWithoutEmissorInput = {
    create?: XOR<MensagensCreateWithoutEmissorInput, MensagensUncheckedCreateWithoutEmissorInput> | MensagensCreateWithoutEmissorInput[] | MensagensUncheckedCreateWithoutEmissorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutEmissorInput | MensagensCreateOrConnectWithoutEmissorInput[]
    createMany?: MensagensCreateManyEmissorInputEnvelope
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
  }

  export type MensagensUncheckedCreateNestedManyWithoutReceptorInput = {
    create?: XOR<MensagensCreateWithoutReceptorInput, MensagensUncheckedCreateWithoutReceptorInput> | MensagensCreateWithoutReceptorInput[] | MensagensUncheckedCreateWithoutReceptorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutReceptorInput | MensagensCreateOrConnectWithoutReceptorInput[]
    createMany?: MensagensCreateManyReceptorInputEnvelope
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
  }

  export type MinhasConexoesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MinhasConexoesCreateWithoutUserInput, MinhasConexoesUncheckedCreateWithoutUserInput> | MinhasConexoesCreateWithoutUserInput[] | MinhasConexoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutUserInput | MinhasConexoesCreateOrConnectWithoutUserInput[]
    createMany?: MinhasConexoesCreateManyUserInputEnvelope
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
  }

  export type MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput = {
    create?: XOR<MinhasConexoesCreateWithoutFriendInput, MinhasConexoesUncheckedCreateWithoutFriendInput> | MinhasConexoesCreateWithoutFriendInput[] | MinhasConexoesUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutFriendInput | MinhasConexoesCreateOrConnectWithoutFriendInput[]
    createMany?: MinhasConexoesCreateManyFriendInputEnvelope
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
  }

  export type PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutUserInput, PedidoDeConexaoUncheckedCreateWithoutUserInput> | PedidoDeConexaoCreateWithoutUserInput[] | PedidoDeConexaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutUserInput | PedidoDeConexaoCreateOrConnectWithoutUserInput[]
    createMany?: PedidoDeConexaoCreateManyUserInputEnvelope
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
  }

  export type PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutDestinatarioInput, PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput> | PedidoDeConexaoCreateWithoutDestinatarioInput[] | PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput | PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput[]
    createMany?: PedidoDeConexaoCreateManyDestinatarioInputEnvelope
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
  }

  export type ReacoesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReacoesCreateWithoutUserInput, ReacoesUncheckedCreateWithoutUserInput> | ReacoesCreateWithoutUserInput[] | ReacoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutUserInput | ReacoesCreateOrConnectWithoutUserInput[]
    createMany?: ReacoesCreateManyUserInputEnvelope
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
  }

  export type ComentariosUncheckedCreateNestedManyWithoutAutorInput = {
    create?: XOR<ComentariosCreateWithoutAutorInput, ComentariosUncheckedCreateWithoutAutorInput> | ComentariosCreateWithoutAutorInput[] | ComentariosUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutAutorInput | ComentariosCreateOrConnectWithoutAutorInput[]
    createMany?: ComentariosCreateManyAutorInputEnvelope
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
  }

  export type SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput = {
    create?: XOR<SeguidoresCreateWithoutSeguidorInput, SeguidoresUncheckedCreateWithoutSeguidorInput> | SeguidoresCreateWithoutSeguidorInput[] | SeguidoresUncheckedCreateWithoutSeguidorInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutSeguidorInput | SeguidoresCreateOrConnectWithoutSeguidorInput[]
    createMany?: SeguidoresCreateManySeguidorInputEnvelope
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
  }

  export type PartilhaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PartilhaCreateWithoutUserInput, PartilhaUncheckedCreateWithoutUserInput> | PartilhaCreateWithoutUserInput[] | PartilhaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutUserInput | PartilhaCreateOrConnectWithoutUserInput[]
    createMany?: PartilhaCreateManyUserInputEnvelope
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ContactosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ContactosCreateWithoutUsuarioInput, ContactosUncheckedCreateWithoutUsuarioInput> | ContactosCreateWithoutUsuarioInput[] | ContactosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutUsuarioInput | ContactosCreateOrConnectWithoutUsuarioInput[]
    upsert?: ContactosUpsertWithWhereUniqueWithoutUsuarioInput | ContactosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ContactosCreateManyUsuarioInputEnvelope
    set?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    disconnect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    delete?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    update?: ContactosUpdateWithWhereUniqueWithoutUsuarioInput | ContactosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ContactosUpdateManyWithWhereWithoutUsuarioInput | ContactosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ContactosScalarWhereInput | ContactosScalarWhereInput[]
  }

  export type PublicacoesUpdateManyWithoutUsuarioPubNestedInput = {
    create?: XOR<PublicacoesCreateWithoutUsuarioPubInput, PublicacoesUncheckedCreateWithoutUsuarioPubInput> | PublicacoesCreateWithoutUsuarioPubInput[] | PublicacoesUncheckedCreateWithoutUsuarioPubInput[]
    connectOrCreate?: PublicacoesCreateOrConnectWithoutUsuarioPubInput | PublicacoesCreateOrConnectWithoutUsuarioPubInput[]
    upsert?: PublicacoesUpsertWithWhereUniqueWithoutUsuarioPubInput | PublicacoesUpsertWithWhereUniqueWithoutUsuarioPubInput[]
    createMany?: PublicacoesCreateManyUsuarioPubInputEnvelope
    set?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    disconnect?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    delete?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    connect?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    update?: PublicacoesUpdateWithWhereUniqueWithoutUsuarioPubInput | PublicacoesUpdateWithWhereUniqueWithoutUsuarioPubInput[]
    updateMany?: PublicacoesUpdateManyWithWhereWithoutUsuarioPubInput | PublicacoesUpdateManyWithWhereWithoutUsuarioPubInput[]
    deleteMany?: PublicacoesScalarWhereInput | PublicacoesScalarWhereInput[]
  }

  export type NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput = {
    create?: XOR<NotificacoesCreateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput> | NotificacoesCreateWithoutUsuarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput | NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutUsuarioNotificacaoInput | NotificacoesUpsertWithWhereUniqueWithoutUsuarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyUsuarioNotificacaoInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutUsuarioNotificacaoInput | NotificacoesUpdateWithWhereUniqueWithoutUsuarioNotificacaoInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutUsuarioNotificacaoInput | NotificacoesUpdateManyWithWhereWithoutUsuarioNotificacaoInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput = {
    create?: XOR<NotificacoesCreateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput> | NotificacoesCreateWithoutDestinatarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput | NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutDestinatarioNotificacaoInput | NotificacoesUpsertWithWhereUniqueWithoutDestinatarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyDestinatarioNotificacaoInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutDestinatarioNotificacaoInput | NotificacoesUpdateWithWhereUniqueWithoutDestinatarioNotificacaoInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutDestinatarioNotificacaoInput | NotificacoesUpdateManyWithWhereWithoutDestinatarioNotificacaoInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type ConsultasUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ConsultasCreateWithoutUsuarioInput, ConsultasUncheckedCreateWithoutUsuarioInput> | ConsultasCreateWithoutUsuarioInput[] | ConsultasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutUsuarioInput | ConsultasCreateOrConnectWithoutUsuarioInput[]
    upsert?: ConsultasUpsertWithWhereUniqueWithoutUsuarioInput | ConsultasUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ConsultasCreateManyUsuarioInputEnvelope
    set?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    disconnect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    delete?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    update?: ConsultasUpdateWithWhereUniqueWithoutUsuarioInput | ConsultasUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ConsultasUpdateManyWithWhereWithoutUsuarioInput | ConsultasUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ConsultasScalarWhereInput | ConsultasScalarWhereInput[]
  }

  export type MensagensUpdateManyWithoutEmissorNestedInput = {
    create?: XOR<MensagensCreateWithoutEmissorInput, MensagensUncheckedCreateWithoutEmissorInput> | MensagensCreateWithoutEmissorInput[] | MensagensUncheckedCreateWithoutEmissorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutEmissorInput | MensagensCreateOrConnectWithoutEmissorInput[]
    upsert?: MensagensUpsertWithWhereUniqueWithoutEmissorInput | MensagensUpsertWithWhereUniqueWithoutEmissorInput[]
    createMany?: MensagensCreateManyEmissorInputEnvelope
    set?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    disconnect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    delete?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    update?: MensagensUpdateWithWhereUniqueWithoutEmissorInput | MensagensUpdateWithWhereUniqueWithoutEmissorInput[]
    updateMany?: MensagensUpdateManyWithWhereWithoutEmissorInput | MensagensUpdateManyWithWhereWithoutEmissorInput[]
    deleteMany?: MensagensScalarWhereInput | MensagensScalarWhereInput[]
  }

  export type MensagensUpdateManyWithoutReceptorNestedInput = {
    create?: XOR<MensagensCreateWithoutReceptorInput, MensagensUncheckedCreateWithoutReceptorInput> | MensagensCreateWithoutReceptorInput[] | MensagensUncheckedCreateWithoutReceptorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutReceptorInput | MensagensCreateOrConnectWithoutReceptorInput[]
    upsert?: MensagensUpsertWithWhereUniqueWithoutReceptorInput | MensagensUpsertWithWhereUniqueWithoutReceptorInput[]
    createMany?: MensagensCreateManyReceptorInputEnvelope
    set?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    disconnect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    delete?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    update?: MensagensUpdateWithWhereUniqueWithoutReceptorInput | MensagensUpdateWithWhereUniqueWithoutReceptorInput[]
    updateMany?: MensagensUpdateManyWithWhereWithoutReceptorInput | MensagensUpdateManyWithWhereWithoutReceptorInput[]
    deleteMany?: MensagensScalarWhereInput | MensagensScalarWhereInput[]
  }

  export type MinhasConexoesUpdateManyWithoutUserNestedInput = {
    create?: XOR<MinhasConexoesCreateWithoutUserInput, MinhasConexoesUncheckedCreateWithoutUserInput> | MinhasConexoesCreateWithoutUserInput[] | MinhasConexoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutUserInput | MinhasConexoesCreateOrConnectWithoutUserInput[]
    upsert?: MinhasConexoesUpsertWithWhereUniqueWithoutUserInput | MinhasConexoesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MinhasConexoesCreateManyUserInputEnvelope
    set?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    disconnect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    delete?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    update?: MinhasConexoesUpdateWithWhereUniqueWithoutUserInput | MinhasConexoesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MinhasConexoesUpdateManyWithWhereWithoutUserInput | MinhasConexoesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MinhasConexoesScalarWhereInput | MinhasConexoesScalarWhereInput[]
  }

  export type MinhasConexoesUpdateManyWithoutFriendNestedInput = {
    create?: XOR<MinhasConexoesCreateWithoutFriendInput, MinhasConexoesUncheckedCreateWithoutFriendInput> | MinhasConexoesCreateWithoutFriendInput[] | MinhasConexoesUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutFriendInput | MinhasConexoesCreateOrConnectWithoutFriendInput[]
    upsert?: MinhasConexoesUpsertWithWhereUniqueWithoutFriendInput | MinhasConexoesUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: MinhasConexoesCreateManyFriendInputEnvelope
    set?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    disconnect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    delete?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    update?: MinhasConexoesUpdateWithWhereUniqueWithoutFriendInput | MinhasConexoesUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: MinhasConexoesUpdateManyWithWhereWithoutFriendInput | MinhasConexoesUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: MinhasConexoesScalarWhereInput | MinhasConexoesScalarWhereInput[]
  }

  export type PedidoDeConexaoUpdateManyWithoutUserNestedInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutUserInput, PedidoDeConexaoUncheckedCreateWithoutUserInput> | PedidoDeConexaoCreateWithoutUserInput[] | PedidoDeConexaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutUserInput | PedidoDeConexaoCreateOrConnectWithoutUserInput[]
    upsert?: PedidoDeConexaoUpsertWithWhereUniqueWithoutUserInput | PedidoDeConexaoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PedidoDeConexaoCreateManyUserInputEnvelope
    set?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    disconnect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    delete?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    update?: PedidoDeConexaoUpdateWithWhereUniqueWithoutUserInput | PedidoDeConexaoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PedidoDeConexaoUpdateManyWithWhereWithoutUserInput | PedidoDeConexaoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PedidoDeConexaoScalarWhereInput | PedidoDeConexaoScalarWhereInput[]
  }

  export type PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutDestinatarioInput, PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput> | PedidoDeConexaoCreateWithoutDestinatarioInput[] | PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput | PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput[]
    upsert?: PedidoDeConexaoUpsertWithWhereUniqueWithoutDestinatarioInput | PedidoDeConexaoUpsertWithWhereUniqueWithoutDestinatarioInput[]
    createMany?: PedidoDeConexaoCreateManyDestinatarioInputEnvelope
    set?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    disconnect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    delete?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    update?: PedidoDeConexaoUpdateWithWhereUniqueWithoutDestinatarioInput | PedidoDeConexaoUpdateWithWhereUniqueWithoutDestinatarioInput[]
    updateMany?: PedidoDeConexaoUpdateManyWithWhereWithoutDestinatarioInput | PedidoDeConexaoUpdateManyWithWhereWithoutDestinatarioInput[]
    deleteMany?: PedidoDeConexaoScalarWhereInput | PedidoDeConexaoScalarWhereInput[]
  }

  export type ReacoesUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReacoesCreateWithoutUserInput, ReacoesUncheckedCreateWithoutUserInput> | ReacoesCreateWithoutUserInput[] | ReacoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutUserInput | ReacoesCreateOrConnectWithoutUserInput[]
    upsert?: ReacoesUpsertWithWhereUniqueWithoutUserInput | ReacoesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReacoesCreateManyUserInputEnvelope
    set?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    disconnect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    delete?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    update?: ReacoesUpdateWithWhereUniqueWithoutUserInput | ReacoesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReacoesUpdateManyWithWhereWithoutUserInput | ReacoesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReacoesScalarWhereInput | ReacoesScalarWhereInput[]
  }

  export type ComentariosUpdateManyWithoutAutorNestedInput = {
    create?: XOR<ComentariosCreateWithoutAutorInput, ComentariosUncheckedCreateWithoutAutorInput> | ComentariosCreateWithoutAutorInput[] | ComentariosUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutAutorInput | ComentariosCreateOrConnectWithoutAutorInput[]
    upsert?: ComentariosUpsertWithWhereUniqueWithoutAutorInput | ComentariosUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: ComentariosCreateManyAutorInputEnvelope
    set?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    disconnect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    delete?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    update?: ComentariosUpdateWithWhereUniqueWithoutAutorInput | ComentariosUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: ComentariosUpdateManyWithWhereWithoutAutorInput | ComentariosUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: ComentariosScalarWhereInput | ComentariosScalarWhereInput[]
  }

  export type SeguidoresUpdateManyWithoutSeguidorNestedInput = {
    create?: XOR<SeguidoresCreateWithoutSeguidorInput, SeguidoresUncheckedCreateWithoutSeguidorInput> | SeguidoresCreateWithoutSeguidorInput[] | SeguidoresUncheckedCreateWithoutSeguidorInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutSeguidorInput | SeguidoresCreateOrConnectWithoutSeguidorInput[]
    upsert?: SeguidoresUpsertWithWhereUniqueWithoutSeguidorInput | SeguidoresUpsertWithWhereUniqueWithoutSeguidorInput[]
    createMany?: SeguidoresCreateManySeguidorInputEnvelope
    set?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    disconnect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    delete?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    update?: SeguidoresUpdateWithWhereUniqueWithoutSeguidorInput | SeguidoresUpdateWithWhereUniqueWithoutSeguidorInput[]
    updateMany?: SeguidoresUpdateManyWithWhereWithoutSeguidorInput | SeguidoresUpdateManyWithWhereWithoutSeguidorInput[]
    deleteMany?: SeguidoresScalarWhereInput | SeguidoresScalarWhereInput[]
  }

  export type PartilhaUpdateManyWithoutUserNestedInput = {
    create?: XOR<PartilhaCreateWithoutUserInput, PartilhaUncheckedCreateWithoutUserInput> | PartilhaCreateWithoutUserInput[] | PartilhaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutUserInput | PartilhaCreateOrConnectWithoutUserInput[]
    upsert?: PartilhaUpsertWithWhereUniqueWithoutUserInput | PartilhaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PartilhaCreateManyUserInputEnvelope
    set?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    disconnect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    delete?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    update?: PartilhaUpdateWithWhereUniqueWithoutUserInput | PartilhaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PartilhaUpdateManyWithWhereWithoutUserInput | PartilhaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
  }

  export type ContactosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ContactosCreateWithoutUsuarioInput, ContactosUncheckedCreateWithoutUsuarioInput> | ContactosCreateWithoutUsuarioInput[] | ContactosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ContactosCreateOrConnectWithoutUsuarioInput | ContactosCreateOrConnectWithoutUsuarioInput[]
    upsert?: ContactosUpsertWithWhereUniqueWithoutUsuarioInput | ContactosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ContactosCreateManyUsuarioInputEnvelope
    set?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    disconnect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    delete?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    connect?: ContactosWhereUniqueInput | ContactosWhereUniqueInput[]
    update?: ContactosUpdateWithWhereUniqueWithoutUsuarioInput | ContactosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ContactosUpdateManyWithWhereWithoutUsuarioInput | ContactosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ContactosScalarWhereInput | ContactosScalarWhereInput[]
  }

  export type PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput = {
    create?: XOR<PublicacoesCreateWithoutUsuarioPubInput, PublicacoesUncheckedCreateWithoutUsuarioPubInput> | PublicacoesCreateWithoutUsuarioPubInput[] | PublicacoesUncheckedCreateWithoutUsuarioPubInput[]
    connectOrCreate?: PublicacoesCreateOrConnectWithoutUsuarioPubInput | PublicacoesCreateOrConnectWithoutUsuarioPubInput[]
    upsert?: PublicacoesUpsertWithWhereUniqueWithoutUsuarioPubInput | PublicacoesUpsertWithWhereUniqueWithoutUsuarioPubInput[]
    createMany?: PublicacoesCreateManyUsuarioPubInputEnvelope
    set?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    disconnect?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    delete?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    connect?: PublicacoesWhereUniqueInput | PublicacoesWhereUniqueInput[]
    update?: PublicacoesUpdateWithWhereUniqueWithoutUsuarioPubInput | PublicacoesUpdateWithWhereUniqueWithoutUsuarioPubInput[]
    updateMany?: PublicacoesUpdateManyWithWhereWithoutUsuarioPubInput | PublicacoesUpdateManyWithWhereWithoutUsuarioPubInput[]
    deleteMany?: PublicacoesScalarWhereInput | PublicacoesScalarWhereInput[]
  }

  export type NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput = {
    create?: XOR<NotificacoesCreateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput> | NotificacoesCreateWithoutUsuarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput | NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutUsuarioNotificacaoInput | NotificacoesUpsertWithWhereUniqueWithoutUsuarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyUsuarioNotificacaoInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutUsuarioNotificacaoInput | NotificacoesUpdateWithWhereUniqueWithoutUsuarioNotificacaoInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutUsuarioNotificacaoInput | NotificacoesUpdateManyWithWhereWithoutUsuarioNotificacaoInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput = {
    create?: XOR<NotificacoesCreateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput> | NotificacoesCreateWithoutDestinatarioNotificacaoInput[] | NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput | NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutDestinatarioNotificacaoInput | NotificacoesUpsertWithWhereUniqueWithoutDestinatarioNotificacaoInput[]
    createMany?: NotificacoesCreateManyDestinatarioNotificacaoInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutDestinatarioNotificacaoInput | NotificacoesUpdateWithWhereUniqueWithoutDestinatarioNotificacaoInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutDestinatarioNotificacaoInput | NotificacoesUpdateManyWithWhereWithoutDestinatarioNotificacaoInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ConsultasCreateWithoutUsuarioInput, ConsultasUncheckedCreateWithoutUsuarioInput> | ConsultasCreateWithoutUsuarioInput[] | ConsultasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ConsultasCreateOrConnectWithoutUsuarioInput | ConsultasCreateOrConnectWithoutUsuarioInput[]
    upsert?: ConsultasUpsertWithWhereUniqueWithoutUsuarioInput | ConsultasUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ConsultasCreateManyUsuarioInputEnvelope
    set?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    disconnect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    delete?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    connect?: ConsultasWhereUniqueInput | ConsultasWhereUniqueInput[]
    update?: ConsultasUpdateWithWhereUniqueWithoutUsuarioInput | ConsultasUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ConsultasUpdateManyWithWhereWithoutUsuarioInput | ConsultasUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ConsultasScalarWhereInput | ConsultasScalarWhereInput[]
  }

  export type MensagensUncheckedUpdateManyWithoutEmissorNestedInput = {
    create?: XOR<MensagensCreateWithoutEmissorInput, MensagensUncheckedCreateWithoutEmissorInput> | MensagensCreateWithoutEmissorInput[] | MensagensUncheckedCreateWithoutEmissorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutEmissorInput | MensagensCreateOrConnectWithoutEmissorInput[]
    upsert?: MensagensUpsertWithWhereUniqueWithoutEmissorInput | MensagensUpsertWithWhereUniqueWithoutEmissorInput[]
    createMany?: MensagensCreateManyEmissorInputEnvelope
    set?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    disconnect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    delete?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    update?: MensagensUpdateWithWhereUniqueWithoutEmissorInput | MensagensUpdateWithWhereUniqueWithoutEmissorInput[]
    updateMany?: MensagensUpdateManyWithWhereWithoutEmissorInput | MensagensUpdateManyWithWhereWithoutEmissorInput[]
    deleteMany?: MensagensScalarWhereInput | MensagensScalarWhereInput[]
  }

  export type MensagensUncheckedUpdateManyWithoutReceptorNestedInput = {
    create?: XOR<MensagensCreateWithoutReceptorInput, MensagensUncheckedCreateWithoutReceptorInput> | MensagensCreateWithoutReceptorInput[] | MensagensUncheckedCreateWithoutReceptorInput[]
    connectOrCreate?: MensagensCreateOrConnectWithoutReceptorInput | MensagensCreateOrConnectWithoutReceptorInput[]
    upsert?: MensagensUpsertWithWhereUniqueWithoutReceptorInput | MensagensUpsertWithWhereUniqueWithoutReceptorInput[]
    createMany?: MensagensCreateManyReceptorInputEnvelope
    set?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    disconnect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    delete?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    connect?: MensagensWhereUniqueInput | MensagensWhereUniqueInput[]
    update?: MensagensUpdateWithWhereUniqueWithoutReceptorInput | MensagensUpdateWithWhereUniqueWithoutReceptorInput[]
    updateMany?: MensagensUpdateManyWithWhereWithoutReceptorInput | MensagensUpdateManyWithWhereWithoutReceptorInput[]
    deleteMany?: MensagensScalarWhereInput | MensagensScalarWhereInput[]
  }

  export type MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MinhasConexoesCreateWithoutUserInput, MinhasConexoesUncheckedCreateWithoutUserInput> | MinhasConexoesCreateWithoutUserInput[] | MinhasConexoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutUserInput | MinhasConexoesCreateOrConnectWithoutUserInput[]
    upsert?: MinhasConexoesUpsertWithWhereUniqueWithoutUserInput | MinhasConexoesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MinhasConexoesCreateManyUserInputEnvelope
    set?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    disconnect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    delete?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    update?: MinhasConexoesUpdateWithWhereUniqueWithoutUserInput | MinhasConexoesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MinhasConexoesUpdateManyWithWhereWithoutUserInput | MinhasConexoesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MinhasConexoesScalarWhereInput | MinhasConexoesScalarWhereInput[]
  }

  export type MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput = {
    create?: XOR<MinhasConexoesCreateWithoutFriendInput, MinhasConexoesUncheckedCreateWithoutFriendInput> | MinhasConexoesCreateWithoutFriendInput[] | MinhasConexoesUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: MinhasConexoesCreateOrConnectWithoutFriendInput | MinhasConexoesCreateOrConnectWithoutFriendInput[]
    upsert?: MinhasConexoesUpsertWithWhereUniqueWithoutFriendInput | MinhasConexoesUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: MinhasConexoesCreateManyFriendInputEnvelope
    set?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    disconnect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    delete?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    connect?: MinhasConexoesWhereUniqueInput | MinhasConexoesWhereUniqueInput[]
    update?: MinhasConexoesUpdateWithWhereUniqueWithoutFriendInput | MinhasConexoesUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: MinhasConexoesUpdateManyWithWhereWithoutFriendInput | MinhasConexoesUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: MinhasConexoesScalarWhereInput | MinhasConexoesScalarWhereInput[]
  }

  export type PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutUserInput, PedidoDeConexaoUncheckedCreateWithoutUserInput> | PedidoDeConexaoCreateWithoutUserInput[] | PedidoDeConexaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutUserInput | PedidoDeConexaoCreateOrConnectWithoutUserInput[]
    upsert?: PedidoDeConexaoUpsertWithWhereUniqueWithoutUserInput | PedidoDeConexaoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PedidoDeConexaoCreateManyUserInputEnvelope
    set?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    disconnect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    delete?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    update?: PedidoDeConexaoUpdateWithWhereUniqueWithoutUserInput | PedidoDeConexaoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PedidoDeConexaoUpdateManyWithWhereWithoutUserInput | PedidoDeConexaoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PedidoDeConexaoScalarWhereInput | PedidoDeConexaoScalarWhereInput[]
  }

  export type PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput = {
    create?: XOR<PedidoDeConexaoCreateWithoutDestinatarioInput, PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput> | PedidoDeConexaoCreateWithoutDestinatarioInput[] | PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput[]
    connectOrCreate?: PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput | PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput[]
    upsert?: PedidoDeConexaoUpsertWithWhereUniqueWithoutDestinatarioInput | PedidoDeConexaoUpsertWithWhereUniqueWithoutDestinatarioInput[]
    createMany?: PedidoDeConexaoCreateManyDestinatarioInputEnvelope
    set?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    disconnect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    delete?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    connect?: PedidoDeConexaoWhereUniqueInput | PedidoDeConexaoWhereUniqueInput[]
    update?: PedidoDeConexaoUpdateWithWhereUniqueWithoutDestinatarioInput | PedidoDeConexaoUpdateWithWhereUniqueWithoutDestinatarioInput[]
    updateMany?: PedidoDeConexaoUpdateManyWithWhereWithoutDestinatarioInput | PedidoDeConexaoUpdateManyWithWhereWithoutDestinatarioInput[]
    deleteMany?: PedidoDeConexaoScalarWhereInput | PedidoDeConexaoScalarWhereInput[]
  }

  export type ReacoesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReacoesCreateWithoutUserInput, ReacoesUncheckedCreateWithoutUserInput> | ReacoesCreateWithoutUserInput[] | ReacoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutUserInput | ReacoesCreateOrConnectWithoutUserInput[]
    upsert?: ReacoesUpsertWithWhereUniqueWithoutUserInput | ReacoesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReacoesCreateManyUserInputEnvelope
    set?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    disconnect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    delete?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    update?: ReacoesUpdateWithWhereUniqueWithoutUserInput | ReacoesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReacoesUpdateManyWithWhereWithoutUserInput | ReacoesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReacoesScalarWhereInput | ReacoesScalarWhereInput[]
  }

  export type ComentariosUncheckedUpdateManyWithoutAutorNestedInput = {
    create?: XOR<ComentariosCreateWithoutAutorInput, ComentariosUncheckedCreateWithoutAutorInput> | ComentariosCreateWithoutAutorInput[] | ComentariosUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutAutorInput | ComentariosCreateOrConnectWithoutAutorInput[]
    upsert?: ComentariosUpsertWithWhereUniqueWithoutAutorInput | ComentariosUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: ComentariosCreateManyAutorInputEnvelope
    set?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    disconnect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    delete?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    update?: ComentariosUpdateWithWhereUniqueWithoutAutorInput | ComentariosUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: ComentariosUpdateManyWithWhereWithoutAutorInput | ComentariosUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: ComentariosScalarWhereInput | ComentariosScalarWhereInput[]
  }

  export type SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput = {
    create?: XOR<SeguidoresCreateWithoutSeguidorInput, SeguidoresUncheckedCreateWithoutSeguidorInput> | SeguidoresCreateWithoutSeguidorInput[] | SeguidoresUncheckedCreateWithoutSeguidorInput[]
    connectOrCreate?: SeguidoresCreateOrConnectWithoutSeguidorInput | SeguidoresCreateOrConnectWithoutSeguidorInput[]
    upsert?: SeguidoresUpsertWithWhereUniqueWithoutSeguidorInput | SeguidoresUpsertWithWhereUniqueWithoutSeguidorInput[]
    createMany?: SeguidoresCreateManySeguidorInputEnvelope
    set?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    disconnect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    delete?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    connect?: SeguidoresWhereUniqueInput | SeguidoresWhereUniqueInput[]
    update?: SeguidoresUpdateWithWhereUniqueWithoutSeguidorInput | SeguidoresUpdateWithWhereUniqueWithoutSeguidorInput[]
    updateMany?: SeguidoresUpdateManyWithWhereWithoutSeguidorInput | SeguidoresUpdateManyWithWhereWithoutSeguidorInput[]
    deleteMany?: SeguidoresScalarWhereInput | SeguidoresScalarWhereInput[]
  }

  export type PartilhaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PartilhaCreateWithoutUserInput, PartilhaUncheckedCreateWithoutUserInput> | PartilhaCreateWithoutUserInput[] | PartilhaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutUserInput | PartilhaCreateOrConnectWithoutUserInput[]
    upsert?: PartilhaUpsertWithWhereUniqueWithoutUserInput | PartilhaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PartilhaCreateManyUserInputEnvelope
    set?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    disconnect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    delete?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    update?: PartilhaUpdateWithWhereUniqueWithoutUserInput | PartilhaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PartilhaUpdateManyWithWhereWithoutUserInput | PartilhaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
  }

  export type UsuariosCreateNestedOneWithoutPubblicacoesInput = {
    create?: XOR<UsuariosCreateWithoutPubblicacoesInput, UsuariosUncheckedCreateWithoutPubblicacoesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutPubblicacoesInput
    connect?: UsuariosWhereUniqueInput
  }

  export type ReacoesCreateNestedManyWithoutPostInput = {
    create?: XOR<ReacoesCreateWithoutPostInput, ReacoesUncheckedCreateWithoutPostInput> | ReacoesCreateWithoutPostInput[] | ReacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutPostInput | ReacoesCreateOrConnectWithoutPostInput[]
    createMany?: ReacoesCreateManyPostInputEnvelope
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
  }

  export type ComentariosCreateNestedManyWithoutPostInput = {
    create?: XOR<ComentariosCreateWithoutPostInput, ComentariosUncheckedCreateWithoutPostInput> | ComentariosCreateWithoutPostInput[] | ComentariosUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutPostInput | ComentariosCreateOrConnectWithoutPostInput[]
    createMany?: ComentariosCreateManyPostInputEnvelope
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
  }

  export type NotificacoesCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificacoesCreateWithoutPostInput, NotificacoesUncheckedCreateWithoutPostInput> | NotificacoesCreateWithoutPostInput[] | NotificacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutPostInput | NotificacoesCreateOrConnectWithoutPostInput[]
    createMany?: NotificacoesCreateManyPostInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type PartilhaCreateNestedManyWithoutPostInput = {
    create?: XOR<PartilhaCreateWithoutPostInput, PartilhaUncheckedCreateWithoutPostInput> | PartilhaCreateWithoutPostInput[] | PartilhaUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostInput | PartilhaCreateOrConnectWithoutPostInput[]
    createMany?: PartilhaCreateManyPostInputEnvelope
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
  }

  export type PartilhaCreateNestedManyWithoutPostShareInput = {
    create?: XOR<PartilhaCreateWithoutPostShareInput, PartilhaUncheckedCreateWithoutPostShareInput> | PartilhaCreateWithoutPostShareInput[] | PartilhaUncheckedCreateWithoutPostShareInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostShareInput | PartilhaCreateOrConnectWithoutPostShareInput[]
    createMany?: PartilhaCreateManyPostShareInputEnvelope
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
  }

  export type ReacoesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReacoesCreateWithoutPostInput, ReacoesUncheckedCreateWithoutPostInput> | ReacoesCreateWithoutPostInput[] | ReacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutPostInput | ReacoesCreateOrConnectWithoutPostInput[]
    createMany?: ReacoesCreateManyPostInputEnvelope
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
  }

  export type ComentariosUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ComentariosCreateWithoutPostInput, ComentariosUncheckedCreateWithoutPostInput> | ComentariosCreateWithoutPostInput[] | ComentariosUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutPostInput | ComentariosCreateOrConnectWithoutPostInput[]
    createMany?: ComentariosCreateManyPostInputEnvelope
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
  }

  export type NotificacoesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificacoesCreateWithoutPostInput, NotificacoesUncheckedCreateWithoutPostInput> | NotificacoesCreateWithoutPostInput[] | NotificacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutPostInput | NotificacoesCreateOrConnectWithoutPostInput[]
    createMany?: NotificacoesCreateManyPostInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type PartilhaUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PartilhaCreateWithoutPostInput, PartilhaUncheckedCreateWithoutPostInput> | PartilhaCreateWithoutPostInput[] | PartilhaUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostInput | PartilhaCreateOrConnectWithoutPostInput[]
    createMany?: PartilhaCreateManyPostInputEnvelope
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
  }

  export type PartilhaUncheckedCreateNestedManyWithoutPostShareInput = {
    create?: XOR<PartilhaCreateWithoutPostShareInput, PartilhaUncheckedCreateWithoutPostShareInput> | PartilhaCreateWithoutPostShareInput[] | PartilhaUncheckedCreateWithoutPostShareInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostShareInput | PartilhaCreateOrConnectWithoutPostShareInput[]
    createMany?: PartilhaCreateManyPostShareInputEnvelope
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
  }

  export type UsuariosUpdateOneRequiredWithoutPubblicacoesNestedInput = {
    create?: XOR<UsuariosCreateWithoutPubblicacoesInput, UsuariosUncheckedCreateWithoutPubblicacoesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutPubblicacoesInput
    upsert?: UsuariosUpsertWithoutPubblicacoesInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutPubblicacoesInput, UsuariosUpdateWithoutPubblicacoesInput>, UsuariosUncheckedUpdateWithoutPubblicacoesInput>
  }

  export type ReacoesUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReacoesCreateWithoutPostInput, ReacoesUncheckedCreateWithoutPostInput> | ReacoesCreateWithoutPostInput[] | ReacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutPostInput | ReacoesCreateOrConnectWithoutPostInput[]
    upsert?: ReacoesUpsertWithWhereUniqueWithoutPostInput | ReacoesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReacoesCreateManyPostInputEnvelope
    set?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    disconnect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    delete?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    update?: ReacoesUpdateWithWhereUniqueWithoutPostInput | ReacoesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReacoesUpdateManyWithWhereWithoutPostInput | ReacoesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReacoesScalarWhereInput | ReacoesScalarWhereInput[]
  }

  export type ComentariosUpdateManyWithoutPostNestedInput = {
    create?: XOR<ComentariosCreateWithoutPostInput, ComentariosUncheckedCreateWithoutPostInput> | ComentariosCreateWithoutPostInput[] | ComentariosUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutPostInput | ComentariosCreateOrConnectWithoutPostInput[]
    upsert?: ComentariosUpsertWithWhereUniqueWithoutPostInput | ComentariosUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ComentariosCreateManyPostInputEnvelope
    set?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    disconnect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    delete?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    update?: ComentariosUpdateWithWhereUniqueWithoutPostInput | ComentariosUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ComentariosUpdateManyWithWhereWithoutPostInput | ComentariosUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ComentariosScalarWhereInput | ComentariosScalarWhereInput[]
  }

  export type NotificacoesUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificacoesCreateWithoutPostInput, NotificacoesUncheckedCreateWithoutPostInput> | NotificacoesCreateWithoutPostInput[] | NotificacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutPostInput | NotificacoesCreateOrConnectWithoutPostInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutPostInput | NotificacoesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificacoesCreateManyPostInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutPostInput | NotificacoesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutPostInput | NotificacoesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type PartilhaUpdateManyWithoutPostNestedInput = {
    create?: XOR<PartilhaCreateWithoutPostInput, PartilhaUncheckedCreateWithoutPostInput> | PartilhaCreateWithoutPostInput[] | PartilhaUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostInput | PartilhaCreateOrConnectWithoutPostInput[]
    upsert?: PartilhaUpsertWithWhereUniqueWithoutPostInput | PartilhaUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PartilhaCreateManyPostInputEnvelope
    set?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    disconnect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    delete?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    update?: PartilhaUpdateWithWhereUniqueWithoutPostInput | PartilhaUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PartilhaUpdateManyWithWhereWithoutPostInput | PartilhaUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
  }

  export type PartilhaUpdateManyWithoutPostShareNestedInput = {
    create?: XOR<PartilhaCreateWithoutPostShareInput, PartilhaUncheckedCreateWithoutPostShareInput> | PartilhaCreateWithoutPostShareInput[] | PartilhaUncheckedCreateWithoutPostShareInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostShareInput | PartilhaCreateOrConnectWithoutPostShareInput[]
    upsert?: PartilhaUpsertWithWhereUniqueWithoutPostShareInput | PartilhaUpsertWithWhereUniqueWithoutPostShareInput[]
    createMany?: PartilhaCreateManyPostShareInputEnvelope
    set?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    disconnect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    delete?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    update?: PartilhaUpdateWithWhereUniqueWithoutPostShareInput | PartilhaUpdateWithWhereUniqueWithoutPostShareInput[]
    updateMany?: PartilhaUpdateManyWithWhereWithoutPostShareInput | PartilhaUpdateManyWithWhereWithoutPostShareInput[]
    deleteMany?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
  }

  export type ReacoesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReacoesCreateWithoutPostInput, ReacoesUncheckedCreateWithoutPostInput> | ReacoesCreateWithoutPostInput[] | ReacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReacoesCreateOrConnectWithoutPostInput | ReacoesCreateOrConnectWithoutPostInput[]
    upsert?: ReacoesUpsertWithWhereUniqueWithoutPostInput | ReacoesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReacoesCreateManyPostInputEnvelope
    set?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    disconnect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    delete?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    connect?: ReacoesWhereUniqueInput | ReacoesWhereUniqueInput[]
    update?: ReacoesUpdateWithWhereUniqueWithoutPostInput | ReacoesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReacoesUpdateManyWithWhereWithoutPostInput | ReacoesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReacoesScalarWhereInput | ReacoesScalarWhereInput[]
  }

  export type ComentariosUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ComentariosCreateWithoutPostInput, ComentariosUncheckedCreateWithoutPostInput> | ComentariosCreateWithoutPostInput[] | ComentariosUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ComentariosCreateOrConnectWithoutPostInput | ComentariosCreateOrConnectWithoutPostInput[]
    upsert?: ComentariosUpsertWithWhereUniqueWithoutPostInput | ComentariosUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ComentariosCreateManyPostInputEnvelope
    set?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    disconnect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    delete?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    connect?: ComentariosWhereUniqueInput | ComentariosWhereUniqueInput[]
    update?: ComentariosUpdateWithWhereUniqueWithoutPostInput | ComentariosUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ComentariosUpdateManyWithWhereWithoutPostInput | ComentariosUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ComentariosScalarWhereInput | ComentariosScalarWhereInput[]
  }

  export type NotificacoesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificacoesCreateWithoutPostInput, NotificacoesUncheckedCreateWithoutPostInput> | NotificacoesCreateWithoutPostInput[] | NotificacoesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutPostInput | NotificacoesCreateOrConnectWithoutPostInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutPostInput | NotificacoesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificacoesCreateManyPostInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutPostInput | NotificacoesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutPostInput | NotificacoesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type PartilhaUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PartilhaCreateWithoutPostInput, PartilhaUncheckedCreateWithoutPostInput> | PartilhaCreateWithoutPostInput[] | PartilhaUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostInput | PartilhaCreateOrConnectWithoutPostInput[]
    upsert?: PartilhaUpsertWithWhereUniqueWithoutPostInput | PartilhaUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PartilhaCreateManyPostInputEnvelope
    set?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    disconnect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    delete?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    update?: PartilhaUpdateWithWhereUniqueWithoutPostInput | PartilhaUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PartilhaUpdateManyWithWhereWithoutPostInput | PartilhaUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
  }

  export type PartilhaUncheckedUpdateManyWithoutPostShareNestedInput = {
    create?: XOR<PartilhaCreateWithoutPostShareInput, PartilhaUncheckedCreateWithoutPostShareInput> | PartilhaCreateWithoutPostShareInput[] | PartilhaUncheckedCreateWithoutPostShareInput[]
    connectOrCreate?: PartilhaCreateOrConnectWithoutPostShareInput | PartilhaCreateOrConnectWithoutPostShareInput[]
    upsert?: PartilhaUpsertWithWhereUniqueWithoutPostShareInput | PartilhaUpsertWithWhereUniqueWithoutPostShareInput[]
    createMany?: PartilhaCreateManyPostShareInputEnvelope
    set?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    disconnect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    delete?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    connect?: PartilhaWhereUniqueInput | PartilhaWhereUniqueInput[]
    update?: PartilhaUpdateWithWhereUniqueWithoutPostShareInput | PartilhaUpdateWithWhereUniqueWithoutPostShareInput[]
    updateMany?: PartilhaUpdateManyWithWhereWithoutPostShareInput | PartilhaUpdateManyWithWhereWithoutPostShareInput[]
    deleteMany?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
  }

  export type PublicacoesCreateNestedOneWithoutComentariosInput = {
    create?: XOR<PublicacoesCreateWithoutComentariosInput, PublicacoesUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutComentariosInput
    connect?: PublicacoesWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutComentariosInput = {
    create?: XOR<UsuariosCreateWithoutComentariosInput, UsuariosUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutComentariosInput
    connect?: UsuariosWhereUniqueInput
  }

  export type PublicacoesUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<PublicacoesCreateWithoutComentariosInput, PublicacoesUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutComentariosInput
    upsert?: PublicacoesUpsertWithoutComentariosInput
    connect?: PublicacoesWhereUniqueInput
    update?: XOR<XOR<PublicacoesUpdateToOneWithWhereWithoutComentariosInput, PublicacoesUpdateWithoutComentariosInput>, PublicacoesUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuariosUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<UsuariosCreateWithoutComentariosInput, UsuariosUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutComentariosInput
    upsert?: UsuariosUpsertWithoutComentariosInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutComentariosInput, UsuariosUpdateWithoutComentariosInput>, UsuariosUncheckedUpdateWithoutComentariosInput>
  }

  export type PublicacoesCreateNestedOneWithoutReacoesInput = {
    create?: XOR<PublicacoesCreateWithoutReacoesInput, PublicacoesUncheckedCreateWithoutReacoesInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutReacoesInput
    connect?: PublicacoesWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutReacoesInput = {
    create?: XOR<UsuariosCreateWithoutReacoesInput, UsuariosUncheckedCreateWithoutReacoesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutReacoesInput
    connect?: UsuariosWhereUniqueInput
  }

  export type PublicacoesUpdateOneRequiredWithoutReacoesNestedInput = {
    create?: XOR<PublicacoesCreateWithoutReacoesInput, PublicacoesUncheckedCreateWithoutReacoesInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutReacoesInput
    upsert?: PublicacoesUpsertWithoutReacoesInput
    connect?: PublicacoesWhereUniqueInput
    update?: XOR<XOR<PublicacoesUpdateToOneWithWhereWithoutReacoesInput, PublicacoesUpdateWithoutReacoesInput>, PublicacoesUncheckedUpdateWithoutReacoesInput>
  }

  export type UsuariosUpdateOneRequiredWithoutReacoesNestedInput = {
    create?: XOR<UsuariosCreateWithoutReacoesInput, UsuariosUncheckedCreateWithoutReacoesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutReacoesInput
    upsert?: UsuariosUpsertWithoutReacoesInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutReacoesInput, UsuariosUpdateWithoutReacoesInput>, UsuariosUncheckedUpdateWithoutReacoesInput>
  }

  export type UsuariosCreateNestedOneWithoutOrigemInput = {
    create?: XOR<UsuariosCreateWithoutOrigemInput, UsuariosUncheckedCreateWithoutOrigemInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutOrigemInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutDestinatarioNotificacaoInput = {
    create?: XOR<UsuariosCreateWithoutDestinatarioNotificacaoInput, UsuariosUncheckedCreateWithoutDestinatarioNotificacaoInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutDestinatarioNotificacaoInput
    connect?: UsuariosWhereUniqueInput
  }

  export type PublicacoesCreateNestedOneWithoutNotificacaoInput = {
    create?: XOR<PublicacoesCreateWithoutNotificacaoInput, PublicacoesUncheckedCreateWithoutNotificacaoInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutNotificacaoInput
    connect?: PublicacoesWhereUniqueInput
  }

  export type ConsultasCreateNestedOneWithoutNotificacoesInput = {
    create?: XOR<ConsultasCreateWithoutNotificacoesInput, ConsultasUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: ConsultasCreateOrConnectWithoutNotificacoesInput
    connect?: ConsultasWhereUniqueInput
  }

  export type UsuariosUpdateOneRequiredWithoutOrigemNestedInput = {
    create?: XOR<UsuariosCreateWithoutOrigemInput, UsuariosUncheckedCreateWithoutOrigemInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutOrigemInput
    upsert?: UsuariosUpsertWithoutOrigemInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutOrigemInput, UsuariosUpdateWithoutOrigemInput>, UsuariosUncheckedUpdateWithoutOrigemInput>
  }

  export type UsuariosUpdateOneRequiredWithoutDestinatarioNotificacaoNestedInput = {
    create?: XOR<UsuariosCreateWithoutDestinatarioNotificacaoInput, UsuariosUncheckedCreateWithoutDestinatarioNotificacaoInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutDestinatarioNotificacaoInput
    upsert?: UsuariosUpsertWithoutDestinatarioNotificacaoInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutDestinatarioNotificacaoInput, UsuariosUpdateWithoutDestinatarioNotificacaoInput>, UsuariosUncheckedUpdateWithoutDestinatarioNotificacaoInput>
  }

  export type PublicacoesUpdateOneRequiredWithoutNotificacaoNestedInput = {
    create?: XOR<PublicacoesCreateWithoutNotificacaoInput, PublicacoesUncheckedCreateWithoutNotificacaoInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutNotificacaoInput
    upsert?: PublicacoesUpsertWithoutNotificacaoInput
    connect?: PublicacoesWhereUniqueInput
    update?: XOR<XOR<PublicacoesUpdateToOneWithWhereWithoutNotificacaoInput, PublicacoesUpdateWithoutNotificacaoInput>, PublicacoesUncheckedUpdateWithoutNotificacaoInput>
  }

  export type ConsultasUpdateOneRequiredWithoutNotificacoesNestedInput = {
    create?: XOR<ConsultasCreateWithoutNotificacoesInput, ConsultasUncheckedCreateWithoutNotificacoesInput>
    connectOrCreate?: ConsultasCreateOrConnectWithoutNotificacoesInput
    upsert?: ConsultasUpsertWithoutNotificacoesInput
    connect?: ConsultasWhereUniqueInput
    update?: XOR<XOR<ConsultasUpdateToOneWithWhereWithoutNotificacoesInput, ConsultasUpdateWithoutNotificacoesInput>, ConsultasUncheckedUpdateWithoutNotificacoesInput>
  }

  export type UsuariosCreateNestedOneWithoutSeguidorInput = {
    create?: XOR<UsuariosCreateWithoutSeguidorInput, UsuariosUncheckedCreateWithoutSeguidorInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutSeguidorInput
    connect?: UsuariosWhereUniqueInput
  }

  export type EntidadesSistemaCreateNestedOneWithoutSeguidoresInput = {
    create?: XOR<EntidadesSistemaCreateWithoutSeguidoresInput, EntidadesSistemaUncheckedCreateWithoutSeguidoresInput>
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutSeguidoresInput
    connect?: EntidadesSistemaWhereUniqueInput
  }

  export type UsuariosUpdateOneRequiredWithoutSeguidorNestedInput = {
    create?: XOR<UsuariosCreateWithoutSeguidorInput, UsuariosUncheckedCreateWithoutSeguidorInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutSeguidorInput
    upsert?: UsuariosUpsertWithoutSeguidorInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutSeguidorInput, UsuariosUpdateWithoutSeguidorInput>, UsuariosUncheckedUpdateWithoutSeguidorInput>
  }

  export type EntidadesSistemaUpdateOneRequiredWithoutSeguidoresNestedInput = {
    create?: XOR<EntidadesSistemaCreateWithoutSeguidoresInput, EntidadesSistemaUncheckedCreateWithoutSeguidoresInput>
    connectOrCreate?: EntidadesSistemaCreateOrConnectWithoutSeguidoresInput
    upsert?: EntidadesSistemaUpsertWithoutSeguidoresInput
    connect?: EntidadesSistemaWhereUniqueInput
    update?: XOR<XOR<EntidadesSistemaUpdateToOneWithWhereWithoutSeguidoresInput, EntidadesSistemaUpdateWithoutSeguidoresInput>, EntidadesSistemaUncheckedUpdateWithoutSeguidoresInput>
  }

  export type UsuariosCreateNestedOneWithoutMensagensEnviadasInput = {
    create?: XOR<UsuariosCreateWithoutMensagensEnviadasInput, UsuariosUncheckedCreateWithoutMensagensEnviadasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutMensagensEnviadasInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutMensagensRecebidasInput = {
    create?: XOR<UsuariosCreateWithoutMensagensRecebidasInput, UsuariosUncheckedCreateWithoutMensagensRecebidasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutMensagensRecebidasInput
    connect?: UsuariosWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsuariosUpdateOneRequiredWithoutMensagensEnviadasNestedInput = {
    create?: XOR<UsuariosCreateWithoutMensagensEnviadasInput, UsuariosUncheckedCreateWithoutMensagensEnviadasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutMensagensEnviadasInput
    upsert?: UsuariosUpsertWithoutMensagensEnviadasInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutMensagensEnviadasInput, UsuariosUpdateWithoutMensagensEnviadasInput>, UsuariosUncheckedUpdateWithoutMensagensEnviadasInput>
  }

  export type UsuariosUpdateOneRequiredWithoutMensagensRecebidasNestedInput = {
    create?: XOR<UsuariosCreateWithoutMensagensRecebidasInput, UsuariosUncheckedCreateWithoutMensagensRecebidasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutMensagensRecebidasInput
    upsert?: UsuariosUpsertWithoutMensagensRecebidasInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutMensagensRecebidasInput, UsuariosUpdateWithoutMensagensRecebidasInput>, UsuariosUncheckedUpdateWithoutMensagensRecebidasInput>
  }

  export type HorasDisponiveisCreateNestedManyWithoutDiasDisponiveisInput = {
    create?: XOR<HorasDisponiveisCreateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput> | HorasDisponiveisCreateWithoutDiasDisponiveisInput[] | HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput | HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput[]
    createMany?: HorasDisponiveisCreateManyDiasDisponiveisInputEnvelope
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
  }

  export type EspecialistasCreateNestedOneWithoutDiasDisponiveisInput = {
    create?: XOR<EspecialistasCreateWithoutDiasDisponiveisInput, EspecialistasUncheckedCreateWithoutDiasDisponiveisInput>
    connectOrCreate?: EspecialistasCreateOrConnectWithoutDiasDisponiveisInput
    connect?: EspecialistasWhereUniqueInput
  }

  export type HorasDisponiveisUncheckedCreateNestedManyWithoutDiasDisponiveisInput = {
    create?: XOR<HorasDisponiveisCreateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput> | HorasDisponiveisCreateWithoutDiasDisponiveisInput[] | HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput | HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput[]
    createMany?: HorasDisponiveisCreateManyDiasDisponiveisInputEnvelope
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
  }

  export type HorasDisponiveisUpdateManyWithoutDiasDisponiveisNestedInput = {
    create?: XOR<HorasDisponiveisCreateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput> | HorasDisponiveisCreateWithoutDiasDisponiveisInput[] | HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput | HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput[]
    upsert?: HorasDisponiveisUpsertWithWhereUniqueWithoutDiasDisponiveisInput | HorasDisponiveisUpsertWithWhereUniqueWithoutDiasDisponiveisInput[]
    createMany?: HorasDisponiveisCreateManyDiasDisponiveisInputEnvelope
    set?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    disconnect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    delete?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    update?: HorasDisponiveisUpdateWithWhereUniqueWithoutDiasDisponiveisInput | HorasDisponiveisUpdateWithWhereUniqueWithoutDiasDisponiveisInput[]
    updateMany?: HorasDisponiveisUpdateManyWithWhereWithoutDiasDisponiveisInput | HorasDisponiveisUpdateManyWithWhereWithoutDiasDisponiveisInput[]
    deleteMany?: HorasDisponiveisScalarWhereInput | HorasDisponiveisScalarWhereInput[]
  }

  export type EspecialistasUpdateOneRequiredWithoutDiasDisponiveisNestedInput = {
    create?: XOR<EspecialistasCreateWithoutDiasDisponiveisInput, EspecialistasUncheckedCreateWithoutDiasDisponiveisInput>
    connectOrCreate?: EspecialistasCreateOrConnectWithoutDiasDisponiveisInput
    upsert?: EspecialistasUpsertWithoutDiasDisponiveisInput
    connect?: EspecialistasWhereUniqueInput
    update?: XOR<XOR<EspecialistasUpdateToOneWithWhereWithoutDiasDisponiveisInput, EspecialistasUpdateWithoutDiasDisponiveisInput>, EspecialistasUncheckedUpdateWithoutDiasDisponiveisInput>
  }

  export type HorasDisponiveisUncheckedUpdateManyWithoutDiasDisponiveisNestedInput = {
    create?: XOR<HorasDisponiveisCreateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput> | HorasDisponiveisCreateWithoutDiasDisponiveisInput[] | HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput[]
    connectOrCreate?: HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput | HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput[]
    upsert?: HorasDisponiveisUpsertWithWhereUniqueWithoutDiasDisponiveisInput | HorasDisponiveisUpsertWithWhereUniqueWithoutDiasDisponiveisInput[]
    createMany?: HorasDisponiveisCreateManyDiasDisponiveisInputEnvelope
    set?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    disconnect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    delete?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    connect?: HorasDisponiveisWhereUniqueInput | HorasDisponiveisWhereUniqueInput[]
    update?: HorasDisponiveisUpdateWithWhereUniqueWithoutDiasDisponiveisInput | HorasDisponiveisUpdateWithWhereUniqueWithoutDiasDisponiveisInput[]
    updateMany?: HorasDisponiveisUpdateManyWithWhereWithoutDiasDisponiveisInput | HorasDisponiveisUpdateManyWithWhereWithoutDiasDisponiveisInput[]
    deleteMany?: HorasDisponiveisScalarWhereInput | HorasDisponiveisScalarWhereInput[]
  }

  export type DiasDisponiveisCreateNestedOneWithoutHorasDisponiveisInput = {
    create?: XOR<DiasDisponiveisCreateWithoutHorasDisponiveisInput, DiasDisponiveisUncheckedCreateWithoutHorasDisponiveisInput>
    connectOrCreate?: DiasDisponiveisCreateOrConnectWithoutHorasDisponiveisInput
    connect?: DiasDisponiveisWhereUniqueInput
  }

  export type EspecialistasCreateNestedOneWithoutHorasDisponiveisInput = {
    create?: XOR<EspecialistasCreateWithoutHorasDisponiveisInput, EspecialistasUncheckedCreateWithoutHorasDisponiveisInput>
    connectOrCreate?: EspecialistasCreateOrConnectWithoutHorasDisponiveisInput
    connect?: EspecialistasWhereUniqueInput
  }

  export type DiasDisponiveisUpdateOneRequiredWithoutHorasDisponiveisNestedInput = {
    create?: XOR<DiasDisponiveisCreateWithoutHorasDisponiveisInput, DiasDisponiveisUncheckedCreateWithoutHorasDisponiveisInput>
    connectOrCreate?: DiasDisponiveisCreateOrConnectWithoutHorasDisponiveisInput
    upsert?: DiasDisponiveisUpsertWithoutHorasDisponiveisInput
    connect?: DiasDisponiveisWhereUniqueInput
    update?: XOR<XOR<DiasDisponiveisUpdateToOneWithWhereWithoutHorasDisponiveisInput, DiasDisponiveisUpdateWithoutHorasDisponiveisInput>, DiasDisponiveisUncheckedUpdateWithoutHorasDisponiveisInput>
  }

  export type EspecialistasUpdateOneRequiredWithoutHorasDisponiveisNestedInput = {
    create?: XOR<EspecialistasCreateWithoutHorasDisponiveisInput, EspecialistasUncheckedCreateWithoutHorasDisponiveisInput>
    connectOrCreate?: EspecialistasCreateOrConnectWithoutHorasDisponiveisInput
    upsert?: EspecialistasUpsertWithoutHorasDisponiveisInput
    connect?: EspecialistasWhereUniqueInput
    update?: XOR<XOR<EspecialistasUpdateToOneWithWhereWithoutHorasDisponiveisInput, EspecialistasUpdateWithoutHorasDisponiveisInput>, EspecialistasUncheckedUpdateWithoutHorasDisponiveisInput>
  }

  export type EspecialistasCreateNestedOneWithoutConsultasInput = {
    create?: XOR<EspecialistasCreateWithoutConsultasInput, EspecialistasUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: EspecialistasCreateOrConnectWithoutConsultasInput
    connect?: EspecialistasWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutConsultasInput = {
    create?: XOR<UsuariosCreateWithoutConsultasInput, UsuariosUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutConsultasInput
    connect?: UsuariosWhereUniqueInput
  }

  export type NotificacoesCreateNestedManyWithoutConsultaInput = {
    create?: XOR<NotificacoesCreateWithoutConsultaInput, NotificacoesUncheckedCreateWithoutConsultaInput> | NotificacoesCreateWithoutConsultaInput[] | NotificacoesUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutConsultaInput | NotificacoesCreateOrConnectWithoutConsultaInput[]
    createMany?: NotificacoesCreateManyConsultaInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type NotificacoesUncheckedCreateNestedManyWithoutConsultaInput = {
    create?: XOR<NotificacoesCreateWithoutConsultaInput, NotificacoesUncheckedCreateWithoutConsultaInput> | NotificacoesCreateWithoutConsultaInput[] | NotificacoesUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutConsultaInput | NotificacoesCreateOrConnectWithoutConsultaInput[]
    createMany?: NotificacoesCreateManyConsultaInputEnvelope
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
  }

  export type EnumConsultaFieldUpdateOperationsInput = {
    set?: $Enums.Consulta
  }

  export type EspecialistasUpdateOneRequiredWithoutConsultasNestedInput = {
    create?: XOR<EspecialistasCreateWithoutConsultasInput, EspecialistasUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: EspecialistasCreateOrConnectWithoutConsultasInput
    upsert?: EspecialistasUpsertWithoutConsultasInput
    connect?: EspecialistasWhereUniqueInput
    update?: XOR<XOR<EspecialistasUpdateToOneWithWhereWithoutConsultasInput, EspecialistasUpdateWithoutConsultasInput>, EspecialistasUncheckedUpdateWithoutConsultasInput>
  }

  export type UsuariosUpdateOneRequiredWithoutConsultasNestedInput = {
    create?: XOR<UsuariosCreateWithoutConsultasInput, UsuariosUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutConsultasInput
    upsert?: UsuariosUpsertWithoutConsultasInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutConsultasInput, UsuariosUpdateWithoutConsultasInput>, UsuariosUncheckedUpdateWithoutConsultasInput>
  }

  export type NotificacoesUpdateManyWithoutConsultaNestedInput = {
    create?: XOR<NotificacoesCreateWithoutConsultaInput, NotificacoesUncheckedCreateWithoutConsultaInput> | NotificacoesCreateWithoutConsultaInput[] | NotificacoesUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutConsultaInput | NotificacoesCreateOrConnectWithoutConsultaInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutConsultaInput | NotificacoesUpsertWithWhereUniqueWithoutConsultaInput[]
    createMany?: NotificacoesCreateManyConsultaInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutConsultaInput | NotificacoesUpdateWithWhereUniqueWithoutConsultaInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutConsultaInput | NotificacoesUpdateManyWithWhereWithoutConsultaInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type NotificacoesUncheckedUpdateManyWithoutConsultaNestedInput = {
    create?: XOR<NotificacoesCreateWithoutConsultaInput, NotificacoesUncheckedCreateWithoutConsultaInput> | NotificacoesCreateWithoutConsultaInput[] | NotificacoesUncheckedCreateWithoutConsultaInput[]
    connectOrCreate?: NotificacoesCreateOrConnectWithoutConsultaInput | NotificacoesCreateOrConnectWithoutConsultaInput[]
    upsert?: NotificacoesUpsertWithWhereUniqueWithoutConsultaInput | NotificacoesUpsertWithWhereUniqueWithoutConsultaInput[]
    createMany?: NotificacoesCreateManyConsultaInputEnvelope
    set?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    disconnect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    delete?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    connect?: NotificacoesWhereUniqueInput | NotificacoesWhereUniqueInput[]
    update?: NotificacoesUpdateWithWhereUniqueWithoutConsultaInput | NotificacoesUpdateWithWhereUniqueWithoutConsultaInput[]
    updateMany?: NotificacoesUpdateManyWithWhereWithoutConsultaInput | NotificacoesUpdateManyWithWhereWithoutConsultaInput[]
    deleteMany?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
  }

  export type UsuariosCreateNestedOneWithoutRemetenteInput = {
    create?: XOR<UsuariosCreateWithoutRemetenteInput, UsuariosUncheckedCreateWithoutRemetenteInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutRemetenteInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutDestinatarioInput = {
    create?: XOR<UsuariosCreateWithoutDestinatarioInput, UsuariosUncheckedCreateWithoutDestinatarioInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutDestinatarioInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneRequiredWithoutRemetenteNestedInput = {
    create?: XOR<UsuariosCreateWithoutRemetenteInput, UsuariosUncheckedCreateWithoutRemetenteInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutRemetenteInput
    upsert?: UsuariosUpsertWithoutRemetenteInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutRemetenteInput, UsuariosUpdateWithoutRemetenteInput>, UsuariosUncheckedUpdateWithoutRemetenteInput>
  }

  export type UsuariosUpdateOneRequiredWithoutDestinatarioNestedInput = {
    create?: XOR<UsuariosCreateWithoutDestinatarioInput, UsuariosUncheckedCreateWithoutDestinatarioInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutDestinatarioInput
    upsert?: UsuariosUpsertWithoutDestinatarioInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutDestinatarioInput, UsuariosUpdateWithoutDestinatarioInput>, UsuariosUncheckedUpdateWithoutDestinatarioInput>
  }

  export type UsuariosCreateNestedOneWithoutEmissorDoPedidoInput = {
    create?: XOR<UsuariosCreateWithoutEmissorDoPedidoInput, UsuariosUncheckedCreateWithoutEmissorDoPedidoInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutEmissorDoPedidoInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutReceptorDoPedidoInput = {
    create?: XOR<UsuariosCreateWithoutReceptorDoPedidoInput, UsuariosUncheckedCreateWithoutReceptorDoPedidoInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutReceptorDoPedidoInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneRequiredWithoutEmissorDoPedidoNestedInput = {
    create?: XOR<UsuariosCreateWithoutEmissorDoPedidoInput, UsuariosUncheckedCreateWithoutEmissorDoPedidoInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutEmissorDoPedidoInput
    upsert?: UsuariosUpsertWithoutEmissorDoPedidoInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutEmissorDoPedidoInput, UsuariosUpdateWithoutEmissorDoPedidoInput>, UsuariosUncheckedUpdateWithoutEmissorDoPedidoInput>
  }

  export type UsuariosUpdateOneRequiredWithoutReceptorDoPedidoNestedInput = {
    create?: XOR<UsuariosCreateWithoutReceptorDoPedidoInput, UsuariosUncheckedCreateWithoutReceptorDoPedidoInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutReceptorDoPedidoInput
    upsert?: UsuariosUpsertWithoutReceptorDoPedidoInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutReceptorDoPedidoInput, UsuariosUpdateWithoutReceptorDoPedidoInput>, UsuariosUncheckedUpdateWithoutReceptorDoPedidoInput>
  }

  export type UsuariosCreateNestedOneWithoutPartilhaInput = {
    create?: XOR<UsuariosCreateWithoutPartilhaInput, UsuariosUncheckedCreateWithoutPartilhaInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutPartilhaInput
    connect?: UsuariosWhereUniqueInput
  }

  export type PublicacoesCreateNestedOneWithoutPostPartilhadoInput = {
    create?: XOR<PublicacoesCreateWithoutPostPartilhadoInput, PublicacoesUncheckedCreateWithoutPostPartilhadoInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutPostPartilhadoInput
    connect?: PublicacoesWhereUniqueInput
  }

  export type PublicacoesCreateNestedOneWithoutPostCriadoInput = {
    create?: XOR<PublicacoesCreateWithoutPostCriadoInput, PublicacoesUncheckedCreateWithoutPostCriadoInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutPostCriadoInput
    connect?: PublicacoesWhereUniqueInput
  }

  export type UsuariosUpdateOneRequiredWithoutPartilhaNestedInput = {
    create?: XOR<UsuariosCreateWithoutPartilhaInput, UsuariosUncheckedCreateWithoutPartilhaInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutPartilhaInput
    upsert?: UsuariosUpsertWithoutPartilhaInput
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutPartilhaInput, UsuariosUpdateWithoutPartilhaInput>, UsuariosUncheckedUpdateWithoutPartilhaInput>
  }

  export type PublicacoesUpdateOneRequiredWithoutPostPartilhadoNestedInput = {
    create?: XOR<PublicacoesCreateWithoutPostPartilhadoInput, PublicacoesUncheckedCreateWithoutPostPartilhadoInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutPostPartilhadoInput
    upsert?: PublicacoesUpsertWithoutPostPartilhadoInput
    connect?: PublicacoesWhereUniqueInput
    update?: XOR<XOR<PublicacoesUpdateToOneWithWhereWithoutPostPartilhadoInput, PublicacoesUpdateWithoutPostPartilhadoInput>, PublicacoesUncheckedUpdateWithoutPostPartilhadoInput>
  }

  export type PublicacoesUpdateOneRequiredWithoutPostCriadoNestedInput = {
    create?: XOR<PublicacoesCreateWithoutPostCriadoInput, PublicacoesUncheckedCreateWithoutPostCriadoInput>
    connectOrCreate?: PublicacoesCreateOrConnectWithoutPostCriadoInput
    upsert?: PublicacoesUpsertWithoutPostCriadoInput
    connect?: PublicacoesWhereUniqueInput
    update?: XOR<XOR<PublicacoesUpdateToOneWithWhereWithoutPostCriadoInput, PublicacoesUpdateWithoutPostCriadoInput>, PublicacoesUncheckedUpdateWithoutPostCriadoInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSexoFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[]
    notIn?: $Enums.Sexo[]
    not?: NestedEnumSexoFilter<$PrismaModel> | $Enums.Sexo
  }

  export type NestedEnumSexoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[]
    notIn?: $Enums.Sexo[]
    not?: NestedEnumSexoWithAggregatesFilter<$PrismaModel> | $Enums.Sexo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoFilter<$PrismaModel>
    _max?: NestedEnumSexoFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumConsultaFilter<$PrismaModel = never> = {
    equals?: $Enums.Consulta | EnumConsultaFieldRefInput<$PrismaModel>
    in?: $Enums.Consulta[]
    notIn?: $Enums.Consulta[]
    not?: NestedEnumConsultaFilter<$PrismaModel> | $Enums.Consulta
  }

  export type NestedEnumConsultaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Consulta | EnumConsultaFieldRefInput<$PrismaModel>
    in?: $Enums.Consulta[]
    notIn?: $Enums.Consulta[]
    not?: NestedEnumConsultaWithAggregatesFilter<$PrismaModel> | $Enums.Consulta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultaFilter<$PrismaModel>
    _max?: NestedEnumConsultaFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnderecoCreateWithoutEntitieInput = {
    id?: string
    adress: string
  }

  export type EnderecoUncheckedCreateWithoutEntitieInput = {
    id?: string
    adress: string
  }

  export type EnderecoCreateOrConnectWithoutEntitieInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutEntitieInput, EnderecoUncheckedCreateWithoutEntitieInput>
  }

  export type ContactosCreateWithoutEntidadeInput = {
    id?: string
    contacto: string
    usuario: UsuariosCreateNestedOneWithoutContactosInput
  }

  export type ContactosUncheckedCreateWithoutEntidadeInput = {
    id?: string
    contacto: string
    usuarioID: string
  }

  export type ContactosCreateOrConnectWithoutEntidadeInput = {
    where: ContactosWhereUniqueInput
    create: XOR<ContactosCreateWithoutEntidadeInput, ContactosUncheckedCreateWithoutEntidadeInput>
  }

  export type ContactosCreateManyEntidadeInputEnvelope = {
    data: ContactosCreateManyEntidadeInput | ContactosCreateManyEntidadeInput[]
    skipDuplicates?: boolean
  }

  export type EspecialistasCreateWithoutEntidadeInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    diasDisponiveis?: DiasDisponiveisCreateNestedManyWithoutEspecialistaInput
    horasDisponiveis?: HorasDisponiveisCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasUncheckedCreateWithoutEntidadeInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    diasDisponiveis?: DiasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
    horasDisponiveis?: HorasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasCreateOrConnectWithoutEntidadeInput = {
    where: EspecialistasWhereUniqueInput
    create: XOR<EspecialistasCreateWithoutEntidadeInput, EspecialistasUncheckedCreateWithoutEntidadeInput>
  }

  export type EspecialistasCreateManyEntidadeInputEnvelope = {
    data: EspecialistasCreateManyEntidadeInput | EspecialistasCreateManyEntidadeInput[]
    skipDuplicates?: boolean
  }

  export type SeguidoresCreateWithoutEntidadeInput = {
    id?: string
    seguidor: UsuariosCreateNestedOneWithoutSeguidorInput
  }

  export type SeguidoresUncheckedCreateWithoutEntidadeInput = {
    id?: string
    seguidorID: string
  }

  export type SeguidoresCreateOrConnectWithoutEntidadeInput = {
    where: SeguidoresWhereUniqueInput
    create: XOR<SeguidoresCreateWithoutEntidadeInput, SeguidoresUncheckedCreateWithoutEntidadeInput>
  }

  export type SeguidoresCreateManyEntidadeInputEnvelope = {
    data: SeguidoresCreateManyEntidadeInput | SeguidoresCreateManyEntidadeInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoUpsertWithoutEntitieInput = {
    update: XOR<EnderecoUpdateWithoutEntitieInput, EnderecoUncheckedUpdateWithoutEntitieInput>
    create: XOR<EnderecoCreateWithoutEntitieInput, EnderecoUncheckedCreateWithoutEntitieInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutEntitieInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutEntitieInput, EnderecoUncheckedUpdateWithoutEntitieInput>
  }

  export type EnderecoUpdateWithoutEntitieInput = {
    id?: StringFieldUpdateOperationsInput | string
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type EnderecoUncheckedUpdateWithoutEntitieInput = {
    id?: StringFieldUpdateOperationsInput | string
    adress?: StringFieldUpdateOperationsInput | string
  }

  export type ContactosUpsertWithWhereUniqueWithoutEntidadeInput = {
    where: ContactosWhereUniqueInput
    update: XOR<ContactosUpdateWithoutEntidadeInput, ContactosUncheckedUpdateWithoutEntidadeInput>
    create: XOR<ContactosCreateWithoutEntidadeInput, ContactosUncheckedCreateWithoutEntidadeInput>
  }

  export type ContactosUpdateWithWhereUniqueWithoutEntidadeInput = {
    where: ContactosWhereUniqueInput
    data: XOR<ContactosUpdateWithoutEntidadeInput, ContactosUncheckedUpdateWithoutEntidadeInput>
  }

  export type ContactosUpdateManyWithWhereWithoutEntidadeInput = {
    where: ContactosScalarWhereInput
    data: XOR<ContactosUpdateManyMutationInput, ContactosUncheckedUpdateManyWithoutEntidadeInput>
  }

  export type ContactosScalarWhereInput = {
    AND?: ContactosScalarWhereInput | ContactosScalarWhereInput[]
    OR?: ContactosScalarWhereInput[]
    NOT?: ContactosScalarWhereInput | ContactosScalarWhereInput[]
    id?: StringFilter<"Contactos"> | string
    contacto?: StringFilter<"Contactos"> | string
    entidadeID?: StringFilter<"Contactos"> | string
    usuarioID?: StringFilter<"Contactos"> | string
  }

  export type EspecialistasUpsertWithWhereUniqueWithoutEntidadeInput = {
    where: EspecialistasWhereUniqueInput
    update: XOR<EspecialistasUpdateWithoutEntidadeInput, EspecialistasUncheckedUpdateWithoutEntidadeInput>
    create: XOR<EspecialistasCreateWithoutEntidadeInput, EspecialistasUncheckedCreateWithoutEntidadeInput>
  }

  export type EspecialistasUpdateWithWhereUniqueWithoutEntidadeInput = {
    where: EspecialistasWhereUniqueInput
    data: XOR<EspecialistasUpdateWithoutEntidadeInput, EspecialistasUncheckedUpdateWithoutEntidadeInput>
  }

  export type EspecialistasUpdateManyWithWhereWithoutEntidadeInput = {
    where: EspecialistasScalarWhereInput
    data: XOR<EspecialistasUpdateManyMutationInput, EspecialistasUncheckedUpdateManyWithoutEntidadeInput>
  }

  export type EspecialistasScalarWhereInput = {
    AND?: EspecialistasScalarWhereInput | EspecialistasScalarWhereInput[]
    OR?: EspecialistasScalarWhereInput[]
    NOT?: EspecialistasScalarWhereInput | EspecialistasScalarWhereInput[]
    id?: StringFilter<"Especialistas"> | string
    nome?: StringFilter<"Especialistas"> | string
    crm?: StringFilter<"Especialistas"> | string
    especialidade?: StringFilter<"Especialistas"> | string
    tipo_De_Consulta?: StringFilter<"Especialistas"> | string
    valor?: StringNullableFilter<"Especialistas"> | string | null
    bloqueado?: StringNullableFilter<"Especialistas"> | string | null
    sexo?: EnumSexoFilter<"Especialistas"> | $Enums.Sexo
    entidadeID?: StringNullableFilter<"Especialistas"> | string | null
  }

  export type SeguidoresUpsertWithWhereUniqueWithoutEntidadeInput = {
    where: SeguidoresWhereUniqueInput
    update: XOR<SeguidoresUpdateWithoutEntidadeInput, SeguidoresUncheckedUpdateWithoutEntidadeInput>
    create: XOR<SeguidoresCreateWithoutEntidadeInput, SeguidoresUncheckedCreateWithoutEntidadeInput>
  }

  export type SeguidoresUpdateWithWhereUniqueWithoutEntidadeInput = {
    where: SeguidoresWhereUniqueInput
    data: XOR<SeguidoresUpdateWithoutEntidadeInput, SeguidoresUncheckedUpdateWithoutEntidadeInput>
  }

  export type SeguidoresUpdateManyWithWhereWithoutEntidadeInput = {
    where: SeguidoresScalarWhereInput
    data: XOR<SeguidoresUpdateManyMutationInput, SeguidoresUncheckedUpdateManyWithoutEntidadeInput>
  }

  export type SeguidoresScalarWhereInput = {
    AND?: SeguidoresScalarWhereInput | SeguidoresScalarWhereInput[]
    OR?: SeguidoresScalarWhereInput[]
    NOT?: SeguidoresScalarWhereInput | SeguidoresScalarWhereInput[]
    id?: StringFilter<"Seguidores"> | string
    seguidorID?: StringFilter<"Seguidores"> | string
    entidadeID?: StringFilter<"Seguidores"> | string
  }

  export type EntidadesSistemaCreateWithoutEnderecoInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    contactos?: ContactosCreateNestedManyWithoutEntidadeInput
    especialista?: EspecialistasCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaUncheckedCreateWithoutEnderecoInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    contactos?: ContactosUncheckedCreateNestedManyWithoutEntidadeInput
    especialista?: EspecialistasUncheckedCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresUncheckedCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaCreateOrConnectWithoutEnderecoInput = {
    where: EntidadesSistemaWhereUniqueInput
    create: XOR<EntidadesSistemaCreateWithoutEnderecoInput, EntidadesSistemaUncheckedCreateWithoutEnderecoInput>
  }

  export type EntidadesSistemaCreateManyEnderecoInputEnvelope = {
    data: EntidadesSistemaCreateManyEnderecoInput | EntidadesSistemaCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type EntidadesSistemaUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: EntidadesSistemaWhereUniqueInput
    update: XOR<EntidadesSistemaUpdateWithoutEnderecoInput, EntidadesSistemaUncheckedUpdateWithoutEnderecoInput>
    create: XOR<EntidadesSistemaCreateWithoutEnderecoInput, EntidadesSistemaUncheckedCreateWithoutEnderecoInput>
  }

  export type EntidadesSistemaUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: EntidadesSistemaWhereUniqueInput
    data: XOR<EntidadesSistemaUpdateWithoutEnderecoInput, EntidadesSistemaUncheckedUpdateWithoutEnderecoInput>
  }

  export type EntidadesSistemaUpdateManyWithWhereWithoutEnderecoInput = {
    where: EntidadesSistemaScalarWhereInput
    data: XOR<EntidadesSistemaUpdateManyMutationInput, EntidadesSistemaUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type EntidadesSistemaScalarWhereInput = {
    AND?: EntidadesSistemaScalarWhereInput | EntidadesSistemaScalarWhereInput[]
    OR?: EntidadesSistemaScalarWhereInput[]
    NOT?: EntidadesSistemaScalarWhereInput | EntidadesSistemaScalarWhereInput[]
    id?: StringFilter<"EntidadesSistema"> | string
    name?: StringFilter<"EntidadesSistema"> | string
    cnpj?: StringFilter<"EntidadesSistema"> | string
    tipo_entidade?: StringFilter<"EntidadesSistema"> | string
    sobre?: StringNullableFilter<"EntidadesSistema"> | string | null
    email?: StringFilter<"EntidadesSistema"> | string
    foto?: StringNullableFilter<"EntidadesSistema"> | string | null
    enderecoID?: StringFilter<"EntidadesSistema"> | string
  }

  export type EntidadesSistemaCreateWithoutContactosInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    endereco: EnderecoCreateNestedOneWithoutEntitieInput
    especialista?: EspecialistasCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaUncheckedCreateWithoutContactosInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    enderecoID: string
    especialista?: EspecialistasUncheckedCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresUncheckedCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaCreateOrConnectWithoutContactosInput = {
    where: EntidadesSistemaWhereUniqueInput
    create: XOR<EntidadesSistemaCreateWithoutContactosInput, EntidadesSistemaUncheckedCreateWithoutContactosInput>
  }

  export type UsuariosCreateWithoutContactosInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutContactosInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutContactosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutContactosInput, UsuariosUncheckedCreateWithoutContactosInput>
  }

  export type EntidadesSistemaUpsertWithoutContactosInput = {
    update: XOR<EntidadesSistemaUpdateWithoutContactosInput, EntidadesSistemaUncheckedUpdateWithoutContactosInput>
    create: XOR<EntidadesSistemaCreateWithoutContactosInput, EntidadesSistemaUncheckedCreateWithoutContactosInput>
    where?: EntidadesSistemaWhereInput
  }

  export type EntidadesSistemaUpdateToOneWithWhereWithoutContactosInput = {
    where?: EntidadesSistemaWhereInput
    data: XOR<EntidadesSistemaUpdateWithoutContactosInput, EntidadesSistemaUncheckedUpdateWithoutContactosInput>
  }

  export type EntidadesSistemaUpdateWithoutContactosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: EnderecoUpdateOneRequiredWithoutEntitieNestedInput
    especialista?: EspecialistasUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUpdateManyWithoutEntidadeNestedInput
  }

  export type EntidadesSistemaUncheckedUpdateWithoutContactosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoID?: StringFieldUpdateOperationsInput | string
    especialista?: EspecialistasUncheckedUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUncheckedUpdateManyWithoutEntidadeNestedInput
  }

  export type UsuariosUpsertWithoutContactosInput = {
    update: XOR<UsuariosUpdateWithoutContactosInput, UsuariosUncheckedUpdateWithoutContactosInput>
    create: XOR<UsuariosCreateWithoutContactosInput, UsuariosUncheckedCreateWithoutContactosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutContactosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutContactosInput, UsuariosUncheckedUpdateWithoutContactosInput>
  }

  export type UsuariosUpdateWithoutContactosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutContactosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EntidadesSistemaCreateWithoutEspecialistaInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    endereco: EnderecoCreateNestedOneWithoutEntitieInput
    contactos?: ContactosCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaUncheckedCreateWithoutEspecialistaInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    enderecoID: string
    contactos?: ContactosUncheckedCreateNestedManyWithoutEntidadeInput
    seguidores?: SeguidoresUncheckedCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaCreateOrConnectWithoutEspecialistaInput = {
    where: EntidadesSistemaWhereUniqueInput
    create: XOR<EntidadesSistemaCreateWithoutEspecialistaInput, EntidadesSistemaUncheckedCreateWithoutEspecialistaInput>
  }

  export type DiasDisponiveisCreateWithoutEspecialistaInput = {
    id?: string
    date: Date | string
    horasDisponiveis?: HorasDisponiveisCreateNestedManyWithoutDiasDisponiveisInput
  }

  export type DiasDisponiveisUncheckedCreateWithoutEspecialistaInput = {
    id?: string
    date: Date | string
    horasDisponiveis?: HorasDisponiveisUncheckedCreateNestedManyWithoutDiasDisponiveisInput
  }

  export type DiasDisponiveisCreateOrConnectWithoutEspecialistaInput = {
    where: DiasDisponiveisWhereUniqueInput
    create: XOR<DiasDisponiveisCreateWithoutEspecialistaInput, DiasDisponiveisUncheckedCreateWithoutEspecialistaInput>
  }

  export type DiasDisponiveisCreateManyEspecialistaInputEnvelope = {
    data: DiasDisponiveisCreateManyEspecialistaInput | DiasDisponiveisCreateManyEspecialistaInput[]
    skipDuplicates?: boolean
  }

  export type HorasDisponiveisCreateWithoutEspecialistaInput = {
    id?: string
    hora: string
    diasDisponiveis: DiasDisponiveisCreateNestedOneWithoutHorasDisponiveisInput
  }

  export type HorasDisponiveisUncheckedCreateWithoutEspecialistaInput = {
    id?: string
    hora: string
    diasDisponiveisID: string
  }

  export type HorasDisponiveisCreateOrConnectWithoutEspecialistaInput = {
    where: HorasDisponiveisWhereUniqueInput
    create: XOR<HorasDisponiveisCreateWithoutEspecialistaInput, HorasDisponiveisUncheckedCreateWithoutEspecialistaInput>
  }

  export type HorasDisponiveisCreateManyEspecialistaInputEnvelope = {
    data: HorasDisponiveisCreateManyEspecialistaInput | HorasDisponiveisCreateManyEspecialistaInput[]
    skipDuplicates?: boolean
  }

  export type ConsultasCreateWithoutEspecialistaInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    status: $Enums.Consulta
    usuario: UsuariosCreateNestedOneWithoutConsultasInput
    notificacoes?: NotificacoesCreateNestedManyWithoutConsultaInput
  }

  export type ConsultasUncheckedCreateWithoutEspecialistaInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    status: $Enums.Consulta
    pacienteID: string
    notificacoes?: NotificacoesUncheckedCreateNestedManyWithoutConsultaInput
  }

  export type ConsultasCreateOrConnectWithoutEspecialistaInput = {
    where: ConsultasWhereUniqueInput
    create: XOR<ConsultasCreateWithoutEspecialistaInput, ConsultasUncheckedCreateWithoutEspecialistaInput>
  }

  export type ConsultasCreateManyEspecialistaInputEnvelope = {
    data: ConsultasCreateManyEspecialistaInput | ConsultasCreateManyEspecialistaInput[]
    skipDuplicates?: boolean
  }

  export type EntidadesSistemaUpsertWithoutEspecialistaInput = {
    update: XOR<EntidadesSistemaUpdateWithoutEspecialistaInput, EntidadesSistemaUncheckedUpdateWithoutEspecialistaInput>
    create: XOR<EntidadesSistemaCreateWithoutEspecialistaInput, EntidadesSistemaUncheckedCreateWithoutEspecialistaInput>
    where?: EntidadesSistemaWhereInput
  }

  export type EntidadesSistemaUpdateToOneWithWhereWithoutEspecialistaInput = {
    where?: EntidadesSistemaWhereInput
    data: XOR<EntidadesSistemaUpdateWithoutEspecialistaInput, EntidadesSistemaUncheckedUpdateWithoutEspecialistaInput>
  }

  export type EntidadesSistemaUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: EnderecoUpdateOneRequiredWithoutEntitieNestedInput
    contactos?: ContactosUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUpdateManyWithoutEntidadeNestedInput
  }

  export type EntidadesSistemaUncheckedUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoID?: StringFieldUpdateOperationsInput | string
    contactos?: ContactosUncheckedUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUncheckedUpdateManyWithoutEntidadeNestedInput
  }

  export type DiasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput = {
    where: DiasDisponiveisWhereUniqueInput
    update: XOR<DiasDisponiveisUpdateWithoutEspecialistaInput, DiasDisponiveisUncheckedUpdateWithoutEspecialistaInput>
    create: XOR<DiasDisponiveisCreateWithoutEspecialistaInput, DiasDisponiveisUncheckedCreateWithoutEspecialistaInput>
  }

  export type DiasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput = {
    where: DiasDisponiveisWhereUniqueInput
    data: XOR<DiasDisponiveisUpdateWithoutEspecialistaInput, DiasDisponiveisUncheckedUpdateWithoutEspecialistaInput>
  }

  export type DiasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput = {
    where: DiasDisponiveisScalarWhereInput
    data: XOR<DiasDisponiveisUpdateManyMutationInput, DiasDisponiveisUncheckedUpdateManyWithoutEspecialistaInput>
  }

  export type DiasDisponiveisScalarWhereInput = {
    AND?: DiasDisponiveisScalarWhereInput | DiasDisponiveisScalarWhereInput[]
    OR?: DiasDisponiveisScalarWhereInput[]
    NOT?: DiasDisponiveisScalarWhereInput | DiasDisponiveisScalarWhereInput[]
    id?: StringFilter<"DiasDisponiveis"> | string
    date?: DateTimeFilter<"DiasDisponiveis"> | Date | string
    especialistaID?: StringFilter<"DiasDisponiveis"> | string
  }

  export type HorasDisponiveisUpsertWithWhereUniqueWithoutEspecialistaInput = {
    where: HorasDisponiveisWhereUniqueInput
    update: XOR<HorasDisponiveisUpdateWithoutEspecialistaInput, HorasDisponiveisUncheckedUpdateWithoutEspecialistaInput>
    create: XOR<HorasDisponiveisCreateWithoutEspecialistaInput, HorasDisponiveisUncheckedCreateWithoutEspecialistaInput>
  }

  export type HorasDisponiveisUpdateWithWhereUniqueWithoutEspecialistaInput = {
    where: HorasDisponiveisWhereUniqueInput
    data: XOR<HorasDisponiveisUpdateWithoutEspecialistaInput, HorasDisponiveisUncheckedUpdateWithoutEspecialistaInput>
  }

  export type HorasDisponiveisUpdateManyWithWhereWithoutEspecialistaInput = {
    where: HorasDisponiveisScalarWhereInput
    data: XOR<HorasDisponiveisUpdateManyMutationInput, HorasDisponiveisUncheckedUpdateManyWithoutEspecialistaInput>
  }

  export type HorasDisponiveisScalarWhereInput = {
    AND?: HorasDisponiveisScalarWhereInput | HorasDisponiveisScalarWhereInput[]
    OR?: HorasDisponiveisScalarWhereInput[]
    NOT?: HorasDisponiveisScalarWhereInput | HorasDisponiveisScalarWhereInput[]
    id?: StringFilter<"HorasDisponiveis"> | string
    hora?: StringFilter<"HorasDisponiveis"> | string
    diasDisponiveisID?: StringFilter<"HorasDisponiveis"> | string
    especialistaID?: StringFilter<"HorasDisponiveis"> | string
  }

  export type ConsultasUpsertWithWhereUniqueWithoutEspecialistaInput = {
    where: ConsultasWhereUniqueInput
    update: XOR<ConsultasUpdateWithoutEspecialistaInput, ConsultasUncheckedUpdateWithoutEspecialistaInput>
    create: XOR<ConsultasCreateWithoutEspecialistaInput, ConsultasUncheckedCreateWithoutEspecialistaInput>
  }

  export type ConsultasUpdateWithWhereUniqueWithoutEspecialistaInput = {
    where: ConsultasWhereUniqueInput
    data: XOR<ConsultasUpdateWithoutEspecialistaInput, ConsultasUncheckedUpdateWithoutEspecialistaInput>
  }

  export type ConsultasUpdateManyWithWhereWithoutEspecialistaInput = {
    where: ConsultasScalarWhereInput
    data: XOR<ConsultasUpdateManyMutationInput, ConsultasUncheckedUpdateManyWithoutEspecialistaInput>
  }

  export type ConsultasScalarWhereInput = {
    AND?: ConsultasScalarWhereInput | ConsultasScalarWhereInput[]
    OR?: ConsultasScalarWhereInput[]
    NOT?: ConsultasScalarWhereInput | ConsultasScalarWhereInput[]
    id?: StringFilter<"Consultas"> | string
    tipo_Da_Consulta?: StringFilter<"Consultas"> | string
    data?: DateTimeFilter<"Consultas"> | Date | string
    hora?: StringFilter<"Consultas"> | string
    especialistaID?: StringFilter<"Consultas"> | string
    status?: EnumConsultaFilter<"Consultas"> | $Enums.Consulta
    pacienteID?: StringFilter<"Consultas"> | string
  }

  export type ContactosCreateWithoutUsuarioInput = {
    id?: string
    contacto: string
    entidade: EntidadesSistemaCreateNestedOneWithoutContactosInput
  }

  export type ContactosUncheckedCreateWithoutUsuarioInput = {
    id?: string
    contacto: string
    entidadeID: string
  }

  export type ContactosCreateOrConnectWithoutUsuarioInput = {
    where: ContactosWhereUniqueInput
    create: XOR<ContactosCreateWithoutUsuarioInput, ContactosUncheckedCreateWithoutUsuarioInput>
  }

  export type ContactosCreateManyUsuarioInputEnvelope = {
    data: ContactosCreateManyUsuarioInput | ContactosCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PublicacoesCreateWithoutUsuarioPubInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    reacoes?: ReacoesCreateNestedManyWithoutPostInput
    comentarios?: ComentariosCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaCreateNestedManyWithoutPostInput
    postCriado?: PartilhaCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesUncheckedCreateWithoutUsuarioPubInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutPostInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesUncheckedCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaUncheckedCreateNestedManyWithoutPostInput
    postCriado?: PartilhaUncheckedCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesCreateOrConnectWithoutUsuarioPubInput = {
    where: PublicacoesWhereUniqueInput
    create: XOR<PublicacoesCreateWithoutUsuarioPubInput, PublicacoesUncheckedCreateWithoutUsuarioPubInput>
  }

  export type PublicacoesCreateManyUsuarioPubInputEnvelope = {
    data: PublicacoesCreateManyUsuarioPubInput | PublicacoesCreateManyUsuarioPubInput[]
    skipDuplicates?: boolean
  }

  export type NotificacoesCreateWithoutUsuarioNotificacaoInput = {
    id?: string
    data?: Date | string
    tipo: string
    visto?: string | null
    destinatarioNotificacao: UsuariosCreateNestedOneWithoutDestinatarioNotificacaoInput
    post: PublicacoesCreateNestedOneWithoutNotificacaoInput
    consulta: ConsultasCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput = {
    id?: string
    data?: Date | string
    destinatarioID: string
    consultaID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesCreateOrConnectWithoutUsuarioNotificacaoInput = {
    where: NotificacoesWhereUniqueInput
    create: XOR<NotificacoesCreateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput>
  }

  export type NotificacoesCreateManyUsuarioNotificacaoInputEnvelope = {
    data: NotificacoesCreateManyUsuarioNotificacaoInput | NotificacoesCreateManyUsuarioNotificacaoInput[]
    skipDuplicates?: boolean
  }

  export type NotificacoesCreateWithoutDestinatarioNotificacaoInput = {
    id?: string
    data?: Date | string
    tipo: string
    visto?: string | null
    usuarioNotificacao: UsuariosCreateNestedOneWithoutOrigemInput
    post: PublicacoesCreateNestedOneWithoutNotificacaoInput
    consulta: ConsultasCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    consultaID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesCreateOrConnectWithoutDestinatarioNotificacaoInput = {
    where: NotificacoesWhereUniqueInput
    create: XOR<NotificacoesCreateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput>
  }

  export type NotificacoesCreateManyDestinatarioNotificacaoInputEnvelope = {
    data: NotificacoesCreateManyDestinatarioNotificacaoInput | NotificacoesCreateManyDestinatarioNotificacaoInput[]
    skipDuplicates?: boolean
  }

  export type ConsultasCreateWithoutUsuarioInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    status: $Enums.Consulta
    especialista: EspecialistasCreateNestedOneWithoutConsultasInput
    notificacoes?: NotificacoesCreateNestedManyWithoutConsultaInput
  }

  export type ConsultasUncheckedCreateWithoutUsuarioInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    especialistaID: string
    status: $Enums.Consulta
    notificacoes?: NotificacoesUncheckedCreateNestedManyWithoutConsultaInput
  }

  export type ConsultasCreateOrConnectWithoutUsuarioInput = {
    where: ConsultasWhereUniqueInput
    create: XOR<ConsultasCreateWithoutUsuarioInput, ConsultasUncheckedCreateWithoutUsuarioInput>
  }

  export type ConsultasCreateManyUsuarioInputEnvelope = {
    data: ConsultasCreateManyUsuarioInput | ConsultasCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type MensagensCreateWithoutEmissorInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    visto?: boolean
    receptor: UsuariosCreateNestedOneWithoutMensagensRecebidasInput
  }

  export type MensagensUncheckedCreateWithoutEmissorInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    receptorID: string
    visto?: boolean
  }

  export type MensagensCreateOrConnectWithoutEmissorInput = {
    where: MensagensWhereUniqueInput
    create: XOR<MensagensCreateWithoutEmissorInput, MensagensUncheckedCreateWithoutEmissorInput>
  }

  export type MensagensCreateManyEmissorInputEnvelope = {
    data: MensagensCreateManyEmissorInput | MensagensCreateManyEmissorInput[]
    skipDuplicates?: boolean
  }

  export type MensagensCreateWithoutReceptorInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    visto?: boolean
    emissor: UsuariosCreateNestedOneWithoutMensagensEnviadasInput
  }

  export type MensagensUncheckedCreateWithoutReceptorInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    emissorID: string
    visto?: boolean
  }

  export type MensagensCreateOrConnectWithoutReceptorInput = {
    where: MensagensWhereUniqueInput
    create: XOR<MensagensCreateWithoutReceptorInput, MensagensUncheckedCreateWithoutReceptorInput>
  }

  export type MensagensCreateManyReceptorInputEnvelope = {
    data: MensagensCreateManyReceptorInput | MensagensCreateManyReceptorInput[]
    skipDuplicates?: boolean
  }

  export type MinhasConexoesCreateWithoutUserInput = {
    id?: string
    friend: UsuariosCreateNestedOneWithoutDestinatarioInput
  }

  export type MinhasConexoesUncheckedCreateWithoutUserInput = {
    id?: string
    friendID: string
  }

  export type MinhasConexoesCreateOrConnectWithoutUserInput = {
    where: MinhasConexoesWhereUniqueInput
    create: XOR<MinhasConexoesCreateWithoutUserInput, MinhasConexoesUncheckedCreateWithoutUserInput>
  }

  export type MinhasConexoesCreateManyUserInputEnvelope = {
    data: MinhasConexoesCreateManyUserInput | MinhasConexoesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MinhasConexoesCreateWithoutFriendInput = {
    id?: string
    user: UsuariosCreateNestedOneWithoutRemetenteInput
  }

  export type MinhasConexoesUncheckedCreateWithoutFriendInput = {
    id?: string
    userID: string
  }

  export type MinhasConexoesCreateOrConnectWithoutFriendInput = {
    where: MinhasConexoesWhereUniqueInput
    create: XOR<MinhasConexoesCreateWithoutFriendInput, MinhasConexoesUncheckedCreateWithoutFriendInput>
  }

  export type MinhasConexoesCreateManyFriendInputEnvelope = {
    data: MinhasConexoesCreateManyFriendInput | MinhasConexoesCreateManyFriendInput[]
    skipDuplicates?: boolean
  }

  export type PedidoDeConexaoCreateWithoutUserInput = {
    id?: string
    destinatario: UsuariosCreateNestedOneWithoutReceptorDoPedidoInput
  }

  export type PedidoDeConexaoUncheckedCreateWithoutUserInput = {
    id?: string
    destinatarioID: string
  }

  export type PedidoDeConexaoCreateOrConnectWithoutUserInput = {
    where: PedidoDeConexaoWhereUniqueInput
    create: XOR<PedidoDeConexaoCreateWithoutUserInput, PedidoDeConexaoUncheckedCreateWithoutUserInput>
  }

  export type PedidoDeConexaoCreateManyUserInputEnvelope = {
    data: PedidoDeConexaoCreateManyUserInput | PedidoDeConexaoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PedidoDeConexaoCreateWithoutDestinatarioInput = {
    id?: string
    user: UsuariosCreateNestedOneWithoutEmissorDoPedidoInput
  }

  export type PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput = {
    id?: string
    userID: string
  }

  export type PedidoDeConexaoCreateOrConnectWithoutDestinatarioInput = {
    where: PedidoDeConexaoWhereUniqueInput
    create: XOR<PedidoDeConexaoCreateWithoutDestinatarioInput, PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput>
  }

  export type PedidoDeConexaoCreateManyDestinatarioInputEnvelope = {
    data: PedidoDeConexaoCreateManyDestinatarioInput | PedidoDeConexaoCreateManyDestinatarioInput[]
    skipDuplicates?: boolean
  }

  export type ReacoesCreateWithoutUserInput = {
    id?: string
    type: string
    createdAt?: Date | string
    post: PublicacoesCreateNestedOneWithoutReacoesInput
  }

  export type ReacoesUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    type: string
    createdAt?: Date | string
  }

  export type ReacoesCreateOrConnectWithoutUserInput = {
    where: ReacoesWhereUniqueInput
    create: XOR<ReacoesCreateWithoutUserInput, ReacoesUncheckedCreateWithoutUserInput>
  }

  export type ReacoesCreateManyUserInputEnvelope = {
    data: ReacoesCreateManyUserInput | ReacoesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComentariosCreateWithoutAutorInput = {
    id?: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PublicacoesCreateNestedOneWithoutComentariosInput
  }

  export type ComentariosUncheckedCreateWithoutAutorInput = {
    id?: string
    postId: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentariosCreateOrConnectWithoutAutorInput = {
    where: ComentariosWhereUniqueInput
    create: XOR<ComentariosCreateWithoutAutorInput, ComentariosUncheckedCreateWithoutAutorInput>
  }

  export type ComentariosCreateManyAutorInputEnvelope = {
    data: ComentariosCreateManyAutorInput | ComentariosCreateManyAutorInput[]
    skipDuplicates?: boolean
  }

  export type SeguidoresCreateWithoutSeguidorInput = {
    id?: string
    entidade: EntidadesSistemaCreateNestedOneWithoutSeguidoresInput
  }

  export type SeguidoresUncheckedCreateWithoutSeguidorInput = {
    id?: string
    entidadeID: string
  }

  export type SeguidoresCreateOrConnectWithoutSeguidorInput = {
    where: SeguidoresWhereUniqueInput
    create: XOR<SeguidoresCreateWithoutSeguidorInput, SeguidoresUncheckedCreateWithoutSeguidorInput>
  }

  export type SeguidoresCreateManySeguidorInputEnvelope = {
    data: SeguidoresCreateManySeguidorInput | SeguidoresCreateManySeguidorInput[]
    skipDuplicates?: boolean
  }

  export type PartilhaCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    post: PublicacoesCreateNestedOneWithoutPostPartilhadoInput
    postShare: PublicacoesCreateNestedOneWithoutPostCriadoInput
  }

  export type PartilhaUncheckedCreateWithoutUserInput = {
    id?: string
    createPostShareID: string
    postShareID: string
    createdAt?: Date | string
  }

  export type PartilhaCreateOrConnectWithoutUserInput = {
    where: PartilhaWhereUniqueInput
    create: XOR<PartilhaCreateWithoutUserInput, PartilhaUncheckedCreateWithoutUserInput>
  }

  export type PartilhaCreateManyUserInputEnvelope = {
    data: PartilhaCreateManyUserInput | PartilhaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ContactosWhereUniqueInput
    update: XOR<ContactosUpdateWithoutUsuarioInput, ContactosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ContactosCreateWithoutUsuarioInput, ContactosUncheckedCreateWithoutUsuarioInput>
  }

  export type ContactosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ContactosWhereUniqueInput
    data: XOR<ContactosUpdateWithoutUsuarioInput, ContactosUncheckedUpdateWithoutUsuarioInput>
  }

  export type ContactosUpdateManyWithWhereWithoutUsuarioInput = {
    where: ContactosScalarWhereInput
    data: XOR<ContactosUpdateManyMutationInput, ContactosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PublicacoesUpsertWithWhereUniqueWithoutUsuarioPubInput = {
    where: PublicacoesWhereUniqueInput
    update: XOR<PublicacoesUpdateWithoutUsuarioPubInput, PublicacoesUncheckedUpdateWithoutUsuarioPubInput>
    create: XOR<PublicacoesCreateWithoutUsuarioPubInput, PublicacoesUncheckedCreateWithoutUsuarioPubInput>
  }

  export type PublicacoesUpdateWithWhereUniqueWithoutUsuarioPubInput = {
    where: PublicacoesWhereUniqueInput
    data: XOR<PublicacoesUpdateWithoutUsuarioPubInput, PublicacoesUncheckedUpdateWithoutUsuarioPubInput>
  }

  export type PublicacoesUpdateManyWithWhereWithoutUsuarioPubInput = {
    where: PublicacoesScalarWhereInput
    data: XOR<PublicacoesUpdateManyMutationInput, PublicacoesUncheckedUpdateManyWithoutUsuarioPubInput>
  }

  export type PublicacoesScalarWhereInput = {
    AND?: PublicacoesScalarWhereInput | PublicacoesScalarWhereInput[]
    OR?: PublicacoesScalarWhereInput[]
    NOT?: PublicacoesScalarWhereInput | PublicacoesScalarWhereInput[]
    id?: StringFilter<"Publicacoes"> | string
    conteudo?: StringFilter<"Publicacoes"> | string
    foto?: StringNullableFilter<"Publicacoes"> | string | null
    video?: StringNullableFilter<"Publicacoes"> | string | null
    data?: DateTimeFilter<"Publicacoes"> | Date | string
    updatedAt?: DateTimeFilter<"Publicacoes"> | Date | string
    usuarioID?: StringFilter<"Publicacoes"> | string
  }

  export type NotificacoesUpsertWithWhereUniqueWithoutUsuarioNotificacaoInput = {
    where: NotificacoesWhereUniqueInput
    update: XOR<NotificacoesUpdateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedUpdateWithoutUsuarioNotificacaoInput>
    create: XOR<NotificacoesCreateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedCreateWithoutUsuarioNotificacaoInput>
  }

  export type NotificacoesUpdateWithWhereUniqueWithoutUsuarioNotificacaoInput = {
    where: NotificacoesWhereUniqueInput
    data: XOR<NotificacoesUpdateWithoutUsuarioNotificacaoInput, NotificacoesUncheckedUpdateWithoutUsuarioNotificacaoInput>
  }

  export type NotificacoesUpdateManyWithWhereWithoutUsuarioNotificacaoInput = {
    where: NotificacoesScalarWhereInput
    data: XOR<NotificacoesUpdateManyMutationInput, NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoInput>
  }

  export type NotificacoesScalarWhereInput = {
    AND?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
    OR?: NotificacoesScalarWhereInput[]
    NOT?: NotificacoesScalarWhereInput | NotificacoesScalarWhereInput[]
    id?: StringFilter<"Notificacoes"> | string
    data?: DateTimeFilter<"Notificacoes"> | Date | string
    usuarioID?: StringFilter<"Notificacoes"> | string
    destinatarioID?: StringFilter<"Notificacoes"> | string
    consultaID?: StringFilter<"Notificacoes"> | string
    postID?: StringFilter<"Notificacoes"> | string
    tipo?: StringFilter<"Notificacoes"> | string
    visto?: StringNullableFilter<"Notificacoes"> | string | null
  }

  export type NotificacoesUpsertWithWhereUniqueWithoutDestinatarioNotificacaoInput = {
    where: NotificacoesWhereUniqueInput
    update: XOR<NotificacoesUpdateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedUpdateWithoutDestinatarioNotificacaoInput>
    create: XOR<NotificacoesCreateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedCreateWithoutDestinatarioNotificacaoInput>
  }

  export type NotificacoesUpdateWithWhereUniqueWithoutDestinatarioNotificacaoInput = {
    where: NotificacoesWhereUniqueInput
    data: XOR<NotificacoesUpdateWithoutDestinatarioNotificacaoInput, NotificacoesUncheckedUpdateWithoutDestinatarioNotificacaoInput>
  }

  export type NotificacoesUpdateManyWithWhereWithoutDestinatarioNotificacaoInput = {
    where: NotificacoesScalarWhereInput
    data: XOR<NotificacoesUpdateManyMutationInput, NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoInput>
  }

  export type ConsultasUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ConsultasWhereUniqueInput
    update: XOR<ConsultasUpdateWithoutUsuarioInput, ConsultasUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ConsultasCreateWithoutUsuarioInput, ConsultasUncheckedCreateWithoutUsuarioInput>
  }

  export type ConsultasUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ConsultasWhereUniqueInput
    data: XOR<ConsultasUpdateWithoutUsuarioInput, ConsultasUncheckedUpdateWithoutUsuarioInput>
  }

  export type ConsultasUpdateManyWithWhereWithoutUsuarioInput = {
    where: ConsultasScalarWhereInput
    data: XOR<ConsultasUpdateManyMutationInput, ConsultasUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type MensagensUpsertWithWhereUniqueWithoutEmissorInput = {
    where: MensagensWhereUniqueInput
    update: XOR<MensagensUpdateWithoutEmissorInput, MensagensUncheckedUpdateWithoutEmissorInput>
    create: XOR<MensagensCreateWithoutEmissorInput, MensagensUncheckedCreateWithoutEmissorInput>
  }

  export type MensagensUpdateWithWhereUniqueWithoutEmissorInput = {
    where: MensagensWhereUniqueInput
    data: XOR<MensagensUpdateWithoutEmissorInput, MensagensUncheckedUpdateWithoutEmissorInput>
  }

  export type MensagensUpdateManyWithWhereWithoutEmissorInput = {
    where: MensagensScalarWhereInput
    data: XOR<MensagensUpdateManyMutationInput, MensagensUncheckedUpdateManyWithoutEmissorInput>
  }

  export type MensagensScalarWhereInput = {
    AND?: MensagensScalarWhereInput | MensagensScalarWhereInput[]
    OR?: MensagensScalarWhereInput[]
    NOT?: MensagensScalarWhereInput | MensagensScalarWhereInput[]
    id?: StringFilter<"Mensagens"> | string
    conteudo?: StringNullableFilter<"Mensagens"> | string | null
    foto?: StringNullableFilter<"Mensagens"> | string | null
    video?: StringNullableFilter<"Mensagens"> | string | null
    arquivo?: StringNullableFilter<"Mensagens"> | string | null
    data?: DateTimeFilter<"Mensagens"> | Date | string
    emissorID?: StringFilter<"Mensagens"> | string
    receptorID?: StringFilter<"Mensagens"> | string
    visto?: BoolFilter<"Mensagens"> | boolean
  }

  export type MensagensUpsertWithWhereUniqueWithoutReceptorInput = {
    where: MensagensWhereUniqueInput
    update: XOR<MensagensUpdateWithoutReceptorInput, MensagensUncheckedUpdateWithoutReceptorInput>
    create: XOR<MensagensCreateWithoutReceptorInput, MensagensUncheckedCreateWithoutReceptorInput>
  }

  export type MensagensUpdateWithWhereUniqueWithoutReceptorInput = {
    where: MensagensWhereUniqueInput
    data: XOR<MensagensUpdateWithoutReceptorInput, MensagensUncheckedUpdateWithoutReceptorInput>
  }

  export type MensagensUpdateManyWithWhereWithoutReceptorInput = {
    where: MensagensScalarWhereInput
    data: XOR<MensagensUpdateManyMutationInput, MensagensUncheckedUpdateManyWithoutReceptorInput>
  }

  export type MinhasConexoesUpsertWithWhereUniqueWithoutUserInput = {
    where: MinhasConexoesWhereUniqueInput
    update: XOR<MinhasConexoesUpdateWithoutUserInput, MinhasConexoesUncheckedUpdateWithoutUserInput>
    create: XOR<MinhasConexoesCreateWithoutUserInput, MinhasConexoesUncheckedCreateWithoutUserInput>
  }

  export type MinhasConexoesUpdateWithWhereUniqueWithoutUserInput = {
    where: MinhasConexoesWhereUniqueInput
    data: XOR<MinhasConexoesUpdateWithoutUserInput, MinhasConexoesUncheckedUpdateWithoutUserInput>
  }

  export type MinhasConexoesUpdateManyWithWhereWithoutUserInput = {
    where: MinhasConexoesScalarWhereInput
    data: XOR<MinhasConexoesUpdateManyMutationInput, MinhasConexoesUncheckedUpdateManyWithoutUserInput>
  }

  export type MinhasConexoesScalarWhereInput = {
    AND?: MinhasConexoesScalarWhereInput | MinhasConexoesScalarWhereInput[]
    OR?: MinhasConexoesScalarWhereInput[]
    NOT?: MinhasConexoesScalarWhereInput | MinhasConexoesScalarWhereInput[]
    id?: StringFilter<"MinhasConexoes"> | string
    userID?: StringFilter<"MinhasConexoes"> | string
    friendID?: StringFilter<"MinhasConexoes"> | string
  }

  export type MinhasConexoesUpsertWithWhereUniqueWithoutFriendInput = {
    where: MinhasConexoesWhereUniqueInput
    update: XOR<MinhasConexoesUpdateWithoutFriendInput, MinhasConexoesUncheckedUpdateWithoutFriendInput>
    create: XOR<MinhasConexoesCreateWithoutFriendInput, MinhasConexoesUncheckedCreateWithoutFriendInput>
  }

  export type MinhasConexoesUpdateWithWhereUniqueWithoutFriendInput = {
    where: MinhasConexoesWhereUniqueInput
    data: XOR<MinhasConexoesUpdateWithoutFriendInput, MinhasConexoesUncheckedUpdateWithoutFriendInput>
  }

  export type MinhasConexoesUpdateManyWithWhereWithoutFriendInput = {
    where: MinhasConexoesScalarWhereInput
    data: XOR<MinhasConexoesUpdateManyMutationInput, MinhasConexoesUncheckedUpdateManyWithoutFriendInput>
  }

  export type PedidoDeConexaoUpsertWithWhereUniqueWithoutUserInput = {
    where: PedidoDeConexaoWhereUniqueInput
    update: XOR<PedidoDeConexaoUpdateWithoutUserInput, PedidoDeConexaoUncheckedUpdateWithoutUserInput>
    create: XOR<PedidoDeConexaoCreateWithoutUserInput, PedidoDeConexaoUncheckedCreateWithoutUserInput>
  }

  export type PedidoDeConexaoUpdateWithWhereUniqueWithoutUserInput = {
    where: PedidoDeConexaoWhereUniqueInput
    data: XOR<PedidoDeConexaoUpdateWithoutUserInput, PedidoDeConexaoUncheckedUpdateWithoutUserInput>
  }

  export type PedidoDeConexaoUpdateManyWithWhereWithoutUserInput = {
    where: PedidoDeConexaoScalarWhereInput
    data: XOR<PedidoDeConexaoUpdateManyMutationInput, PedidoDeConexaoUncheckedUpdateManyWithoutUserInput>
  }

  export type PedidoDeConexaoScalarWhereInput = {
    AND?: PedidoDeConexaoScalarWhereInput | PedidoDeConexaoScalarWhereInput[]
    OR?: PedidoDeConexaoScalarWhereInput[]
    NOT?: PedidoDeConexaoScalarWhereInput | PedidoDeConexaoScalarWhereInput[]
    id?: StringFilter<"PedidoDeConexao"> | string
    userID?: StringFilter<"PedidoDeConexao"> | string
    destinatarioID?: StringFilter<"PedidoDeConexao"> | string
  }

  export type PedidoDeConexaoUpsertWithWhereUniqueWithoutDestinatarioInput = {
    where: PedidoDeConexaoWhereUniqueInput
    update: XOR<PedidoDeConexaoUpdateWithoutDestinatarioInput, PedidoDeConexaoUncheckedUpdateWithoutDestinatarioInput>
    create: XOR<PedidoDeConexaoCreateWithoutDestinatarioInput, PedidoDeConexaoUncheckedCreateWithoutDestinatarioInput>
  }

  export type PedidoDeConexaoUpdateWithWhereUniqueWithoutDestinatarioInput = {
    where: PedidoDeConexaoWhereUniqueInput
    data: XOR<PedidoDeConexaoUpdateWithoutDestinatarioInput, PedidoDeConexaoUncheckedUpdateWithoutDestinatarioInput>
  }

  export type PedidoDeConexaoUpdateManyWithWhereWithoutDestinatarioInput = {
    where: PedidoDeConexaoScalarWhereInput
    data: XOR<PedidoDeConexaoUpdateManyMutationInput, PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioInput>
  }

  export type ReacoesUpsertWithWhereUniqueWithoutUserInput = {
    where: ReacoesWhereUniqueInput
    update: XOR<ReacoesUpdateWithoutUserInput, ReacoesUncheckedUpdateWithoutUserInput>
    create: XOR<ReacoesCreateWithoutUserInput, ReacoesUncheckedCreateWithoutUserInput>
  }

  export type ReacoesUpdateWithWhereUniqueWithoutUserInput = {
    where: ReacoesWhereUniqueInput
    data: XOR<ReacoesUpdateWithoutUserInput, ReacoesUncheckedUpdateWithoutUserInput>
  }

  export type ReacoesUpdateManyWithWhereWithoutUserInput = {
    where: ReacoesScalarWhereInput
    data: XOR<ReacoesUpdateManyMutationInput, ReacoesUncheckedUpdateManyWithoutUserInput>
  }

  export type ReacoesScalarWhereInput = {
    AND?: ReacoesScalarWhereInput | ReacoesScalarWhereInput[]
    OR?: ReacoesScalarWhereInput[]
    NOT?: ReacoesScalarWhereInput | ReacoesScalarWhereInput[]
    id?: StringFilter<"Reacoes"> | string
    postId?: StringFilter<"Reacoes"> | string
    userId?: StringFilter<"Reacoes"> | string
    type?: StringFilter<"Reacoes"> | string
    createdAt?: DateTimeFilter<"Reacoes"> | Date | string
  }

  export type ComentariosUpsertWithWhereUniqueWithoutAutorInput = {
    where: ComentariosWhereUniqueInput
    update: XOR<ComentariosUpdateWithoutAutorInput, ComentariosUncheckedUpdateWithoutAutorInput>
    create: XOR<ComentariosCreateWithoutAutorInput, ComentariosUncheckedCreateWithoutAutorInput>
  }

  export type ComentariosUpdateWithWhereUniqueWithoutAutorInput = {
    where: ComentariosWhereUniqueInput
    data: XOR<ComentariosUpdateWithoutAutorInput, ComentariosUncheckedUpdateWithoutAutorInput>
  }

  export type ComentariosUpdateManyWithWhereWithoutAutorInput = {
    where: ComentariosScalarWhereInput
    data: XOR<ComentariosUpdateManyMutationInput, ComentariosUncheckedUpdateManyWithoutAutorInput>
  }

  export type ComentariosScalarWhereInput = {
    AND?: ComentariosScalarWhereInput | ComentariosScalarWhereInput[]
    OR?: ComentariosScalarWhereInput[]
    NOT?: ComentariosScalarWhereInput | ComentariosScalarWhereInput[]
    id?: StringFilter<"Comentarios"> | string
    postId?: StringFilter<"Comentarios"> | string
    autorId?: StringFilter<"Comentarios"> | string
    conteudo?: StringFilter<"Comentarios"> | string
    createdAt?: DateTimeFilter<"Comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"Comentarios"> | Date | string
  }

  export type SeguidoresUpsertWithWhereUniqueWithoutSeguidorInput = {
    where: SeguidoresWhereUniqueInput
    update: XOR<SeguidoresUpdateWithoutSeguidorInput, SeguidoresUncheckedUpdateWithoutSeguidorInput>
    create: XOR<SeguidoresCreateWithoutSeguidorInput, SeguidoresUncheckedCreateWithoutSeguidorInput>
  }

  export type SeguidoresUpdateWithWhereUniqueWithoutSeguidorInput = {
    where: SeguidoresWhereUniqueInput
    data: XOR<SeguidoresUpdateWithoutSeguidorInput, SeguidoresUncheckedUpdateWithoutSeguidorInput>
  }

  export type SeguidoresUpdateManyWithWhereWithoutSeguidorInput = {
    where: SeguidoresScalarWhereInput
    data: XOR<SeguidoresUpdateManyMutationInput, SeguidoresUncheckedUpdateManyWithoutSeguidorInput>
  }

  export type PartilhaUpsertWithWhereUniqueWithoutUserInput = {
    where: PartilhaWhereUniqueInput
    update: XOR<PartilhaUpdateWithoutUserInput, PartilhaUncheckedUpdateWithoutUserInput>
    create: XOR<PartilhaCreateWithoutUserInput, PartilhaUncheckedCreateWithoutUserInput>
  }

  export type PartilhaUpdateWithWhereUniqueWithoutUserInput = {
    where: PartilhaWhereUniqueInput
    data: XOR<PartilhaUpdateWithoutUserInput, PartilhaUncheckedUpdateWithoutUserInput>
  }

  export type PartilhaUpdateManyWithWhereWithoutUserInput = {
    where: PartilhaScalarWhereInput
    data: XOR<PartilhaUpdateManyMutationInput, PartilhaUncheckedUpdateManyWithoutUserInput>
  }

  export type PartilhaScalarWhereInput = {
    AND?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
    OR?: PartilhaScalarWhereInput[]
    NOT?: PartilhaScalarWhereInput | PartilhaScalarWhereInput[]
    id?: StringFilter<"Partilha"> | string
    userID?: StringFilter<"Partilha"> | string
    createPostShareID?: StringFilter<"Partilha"> | string
    postShareID?: StringFilter<"Partilha"> | string
    createdAt?: DateTimeFilter<"Partilha"> | Date | string
  }

  export type UsuariosCreateWithoutPubblicacoesInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutPubblicacoesInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutPubblicacoesInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutPubblicacoesInput, UsuariosUncheckedCreateWithoutPubblicacoesInput>
  }

  export type ReacoesCreateWithoutPostInput = {
    id?: string
    type: string
    createdAt?: Date | string
    user: UsuariosCreateNestedOneWithoutReacoesInput
  }

  export type ReacoesUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type ReacoesCreateOrConnectWithoutPostInput = {
    where: ReacoesWhereUniqueInput
    create: XOR<ReacoesCreateWithoutPostInput, ReacoesUncheckedCreateWithoutPostInput>
  }

  export type ReacoesCreateManyPostInputEnvelope = {
    data: ReacoesCreateManyPostInput | ReacoesCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ComentariosCreateWithoutPostInput = {
    id?: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    autor: UsuariosCreateNestedOneWithoutComentariosInput
  }

  export type ComentariosUncheckedCreateWithoutPostInput = {
    id?: string
    autorId: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComentariosCreateOrConnectWithoutPostInput = {
    where: ComentariosWhereUniqueInput
    create: XOR<ComentariosCreateWithoutPostInput, ComentariosUncheckedCreateWithoutPostInput>
  }

  export type ComentariosCreateManyPostInputEnvelope = {
    data: ComentariosCreateManyPostInput | ComentariosCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type NotificacoesCreateWithoutPostInput = {
    id?: string
    data?: Date | string
    tipo: string
    visto?: string | null
    usuarioNotificacao: UsuariosCreateNestedOneWithoutOrigemInput
    destinatarioNotificacao: UsuariosCreateNestedOneWithoutDestinatarioNotificacaoInput
    consulta: ConsultasCreateNestedOneWithoutNotificacoesInput
  }

  export type NotificacoesUncheckedCreateWithoutPostInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    destinatarioID: string
    consultaID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesCreateOrConnectWithoutPostInput = {
    where: NotificacoesWhereUniqueInput
    create: XOR<NotificacoesCreateWithoutPostInput, NotificacoesUncheckedCreateWithoutPostInput>
  }

  export type NotificacoesCreateManyPostInputEnvelope = {
    data: NotificacoesCreateManyPostInput | NotificacoesCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PartilhaCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    user: UsuariosCreateNestedOneWithoutPartilhaInput
    postShare: PublicacoesCreateNestedOneWithoutPostCriadoInput
  }

  export type PartilhaUncheckedCreateWithoutPostInput = {
    id?: string
    userID: string
    createPostShareID: string
    createdAt?: Date | string
  }

  export type PartilhaCreateOrConnectWithoutPostInput = {
    where: PartilhaWhereUniqueInput
    create: XOR<PartilhaCreateWithoutPostInput, PartilhaUncheckedCreateWithoutPostInput>
  }

  export type PartilhaCreateManyPostInputEnvelope = {
    data: PartilhaCreateManyPostInput | PartilhaCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PartilhaCreateWithoutPostShareInput = {
    id?: string
    createdAt?: Date | string
    user: UsuariosCreateNestedOneWithoutPartilhaInput
    post: PublicacoesCreateNestedOneWithoutPostPartilhadoInput
  }

  export type PartilhaUncheckedCreateWithoutPostShareInput = {
    id?: string
    userID: string
    postShareID: string
    createdAt?: Date | string
  }

  export type PartilhaCreateOrConnectWithoutPostShareInput = {
    where: PartilhaWhereUniqueInput
    create: XOR<PartilhaCreateWithoutPostShareInput, PartilhaUncheckedCreateWithoutPostShareInput>
  }

  export type PartilhaCreateManyPostShareInputEnvelope = {
    data: PartilhaCreateManyPostShareInput | PartilhaCreateManyPostShareInput[]
    skipDuplicates?: boolean
  }

  export type UsuariosUpsertWithoutPubblicacoesInput = {
    update: XOR<UsuariosUpdateWithoutPubblicacoesInput, UsuariosUncheckedUpdateWithoutPubblicacoesInput>
    create: XOR<UsuariosCreateWithoutPubblicacoesInput, UsuariosUncheckedCreateWithoutPubblicacoesInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutPubblicacoesInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutPubblicacoesInput, UsuariosUncheckedUpdateWithoutPubblicacoesInput>
  }

  export type UsuariosUpdateWithoutPubblicacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutPubblicacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReacoesUpsertWithWhereUniqueWithoutPostInput = {
    where: ReacoesWhereUniqueInput
    update: XOR<ReacoesUpdateWithoutPostInput, ReacoesUncheckedUpdateWithoutPostInput>
    create: XOR<ReacoesCreateWithoutPostInput, ReacoesUncheckedCreateWithoutPostInput>
  }

  export type ReacoesUpdateWithWhereUniqueWithoutPostInput = {
    where: ReacoesWhereUniqueInput
    data: XOR<ReacoesUpdateWithoutPostInput, ReacoesUncheckedUpdateWithoutPostInput>
  }

  export type ReacoesUpdateManyWithWhereWithoutPostInput = {
    where: ReacoesScalarWhereInput
    data: XOR<ReacoesUpdateManyMutationInput, ReacoesUncheckedUpdateManyWithoutPostInput>
  }

  export type ComentariosUpsertWithWhereUniqueWithoutPostInput = {
    where: ComentariosWhereUniqueInput
    update: XOR<ComentariosUpdateWithoutPostInput, ComentariosUncheckedUpdateWithoutPostInput>
    create: XOR<ComentariosCreateWithoutPostInput, ComentariosUncheckedCreateWithoutPostInput>
  }

  export type ComentariosUpdateWithWhereUniqueWithoutPostInput = {
    where: ComentariosWhereUniqueInput
    data: XOR<ComentariosUpdateWithoutPostInput, ComentariosUncheckedUpdateWithoutPostInput>
  }

  export type ComentariosUpdateManyWithWhereWithoutPostInput = {
    where: ComentariosScalarWhereInput
    data: XOR<ComentariosUpdateManyMutationInput, ComentariosUncheckedUpdateManyWithoutPostInput>
  }

  export type NotificacoesUpsertWithWhereUniqueWithoutPostInput = {
    where: NotificacoesWhereUniqueInput
    update: XOR<NotificacoesUpdateWithoutPostInput, NotificacoesUncheckedUpdateWithoutPostInput>
    create: XOR<NotificacoesCreateWithoutPostInput, NotificacoesUncheckedCreateWithoutPostInput>
  }

  export type NotificacoesUpdateWithWhereUniqueWithoutPostInput = {
    where: NotificacoesWhereUniqueInput
    data: XOR<NotificacoesUpdateWithoutPostInput, NotificacoesUncheckedUpdateWithoutPostInput>
  }

  export type NotificacoesUpdateManyWithWhereWithoutPostInput = {
    where: NotificacoesScalarWhereInput
    data: XOR<NotificacoesUpdateManyMutationInput, NotificacoesUncheckedUpdateManyWithoutPostInput>
  }

  export type PartilhaUpsertWithWhereUniqueWithoutPostInput = {
    where: PartilhaWhereUniqueInput
    update: XOR<PartilhaUpdateWithoutPostInput, PartilhaUncheckedUpdateWithoutPostInput>
    create: XOR<PartilhaCreateWithoutPostInput, PartilhaUncheckedCreateWithoutPostInput>
  }

  export type PartilhaUpdateWithWhereUniqueWithoutPostInput = {
    where: PartilhaWhereUniqueInput
    data: XOR<PartilhaUpdateWithoutPostInput, PartilhaUncheckedUpdateWithoutPostInput>
  }

  export type PartilhaUpdateManyWithWhereWithoutPostInput = {
    where: PartilhaScalarWhereInput
    data: XOR<PartilhaUpdateManyMutationInput, PartilhaUncheckedUpdateManyWithoutPostInput>
  }

  export type PartilhaUpsertWithWhereUniqueWithoutPostShareInput = {
    where: PartilhaWhereUniqueInput
    update: XOR<PartilhaUpdateWithoutPostShareInput, PartilhaUncheckedUpdateWithoutPostShareInput>
    create: XOR<PartilhaCreateWithoutPostShareInput, PartilhaUncheckedCreateWithoutPostShareInput>
  }

  export type PartilhaUpdateWithWhereUniqueWithoutPostShareInput = {
    where: PartilhaWhereUniqueInput
    data: XOR<PartilhaUpdateWithoutPostShareInput, PartilhaUncheckedUpdateWithoutPostShareInput>
  }

  export type PartilhaUpdateManyWithWhereWithoutPostShareInput = {
    where: PartilhaScalarWhereInput
    data: XOR<PartilhaUpdateManyMutationInput, PartilhaUncheckedUpdateManyWithoutPostShareInput>
  }

  export type PublicacoesCreateWithoutComentariosInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioPub: UsuariosCreateNestedOneWithoutPubblicacoesInput
    reacoes?: ReacoesCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaCreateNestedManyWithoutPostInput
    postCriado?: PartilhaCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesUncheckedCreateWithoutComentariosInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioID: string
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesUncheckedCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaUncheckedCreateNestedManyWithoutPostInput
    postCriado?: PartilhaUncheckedCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesCreateOrConnectWithoutComentariosInput = {
    where: PublicacoesWhereUniqueInput
    create: XOR<PublicacoesCreateWithoutComentariosInput, PublicacoesUncheckedCreateWithoutComentariosInput>
  }

  export type UsuariosCreateWithoutComentariosInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutComentariosInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutComentariosInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutComentariosInput, UsuariosUncheckedCreateWithoutComentariosInput>
  }

  export type PublicacoesUpsertWithoutComentariosInput = {
    update: XOR<PublicacoesUpdateWithoutComentariosInput, PublicacoesUncheckedUpdateWithoutComentariosInput>
    create: XOR<PublicacoesCreateWithoutComentariosInput, PublicacoesUncheckedCreateWithoutComentariosInput>
    where?: PublicacoesWhereInput
  }

  export type PublicacoesUpdateToOneWithWhereWithoutComentariosInput = {
    where?: PublicacoesWhereInput
    data: XOR<PublicacoesUpdateWithoutComentariosInput, PublicacoesUncheckedUpdateWithoutComentariosInput>
  }

  export type PublicacoesUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioPub?: UsuariosUpdateOneRequiredWithoutPubblicacoesNestedInput
    reacoes?: ReacoesUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUncheckedUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    reacoes?: ReacoesUncheckedUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUncheckedUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUncheckedUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUncheckedUpdateManyWithoutPostShareNestedInput
  }

  export type UsuariosUpsertWithoutComentariosInput = {
    update: XOR<UsuariosUpdateWithoutComentariosInput, UsuariosUncheckedUpdateWithoutComentariosInput>
    create: XOR<UsuariosCreateWithoutComentariosInput, UsuariosUncheckedCreateWithoutComentariosInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutComentariosInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutComentariosInput, UsuariosUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuariosUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutComentariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PublicacoesCreateWithoutReacoesInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioPub: UsuariosCreateNestedOneWithoutPubblicacoesInput
    comentarios?: ComentariosCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaCreateNestedManyWithoutPostInput
    postCriado?: PartilhaCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesUncheckedCreateWithoutReacoesInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioID: string
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesUncheckedCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaUncheckedCreateNestedManyWithoutPostInput
    postCriado?: PartilhaUncheckedCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesCreateOrConnectWithoutReacoesInput = {
    where: PublicacoesWhereUniqueInput
    create: XOR<PublicacoesCreateWithoutReacoesInput, PublicacoesUncheckedCreateWithoutReacoesInput>
  }

  export type UsuariosCreateWithoutReacoesInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutReacoesInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutReacoesInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutReacoesInput, UsuariosUncheckedCreateWithoutReacoesInput>
  }

  export type PublicacoesUpsertWithoutReacoesInput = {
    update: XOR<PublicacoesUpdateWithoutReacoesInput, PublicacoesUncheckedUpdateWithoutReacoesInput>
    create: XOR<PublicacoesCreateWithoutReacoesInput, PublicacoesUncheckedCreateWithoutReacoesInput>
    where?: PublicacoesWhereInput
  }

  export type PublicacoesUpdateToOneWithWhereWithoutReacoesInput = {
    where?: PublicacoesWhereInput
    data: XOR<PublicacoesUpdateWithoutReacoesInput, PublicacoesUncheckedUpdateWithoutReacoesInput>
  }

  export type PublicacoesUpdateWithoutReacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioPub?: UsuariosUpdateOneRequiredWithoutPubblicacoesNestedInput
    comentarios?: ComentariosUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUncheckedUpdateWithoutReacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    comentarios?: ComentariosUncheckedUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUncheckedUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUncheckedUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUncheckedUpdateManyWithoutPostShareNestedInput
  }

  export type UsuariosUpsertWithoutReacoesInput = {
    update: XOR<UsuariosUpdateWithoutReacoesInput, UsuariosUncheckedUpdateWithoutReacoesInput>
    create: XOR<UsuariosCreateWithoutReacoesInput, UsuariosUncheckedCreateWithoutReacoesInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutReacoesInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutReacoesInput, UsuariosUncheckedUpdateWithoutReacoesInput>
  }

  export type UsuariosUpdateWithoutReacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutReacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosCreateWithoutOrigemInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutOrigemInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutOrigemInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutOrigemInput, UsuariosUncheckedCreateWithoutOrigemInput>
  }

  export type UsuariosCreateWithoutDestinatarioNotificacaoInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutDestinatarioNotificacaoInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutDestinatarioNotificacaoInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutDestinatarioNotificacaoInput, UsuariosUncheckedCreateWithoutDestinatarioNotificacaoInput>
  }

  export type PublicacoesCreateWithoutNotificacaoInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioPub: UsuariosCreateNestedOneWithoutPubblicacoesInput
    reacoes?: ReacoesCreateNestedManyWithoutPostInput
    comentarios?: ComentariosCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaCreateNestedManyWithoutPostInput
    postCriado?: PartilhaCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesUncheckedCreateWithoutNotificacaoInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioID: string
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutPostInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaUncheckedCreateNestedManyWithoutPostInput
    postCriado?: PartilhaUncheckedCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesCreateOrConnectWithoutNotificacaoInput = {
    where: PublicacoesWhereUniqueInput
    create: XOR<PublicacoesCreateWithoutNotificacaoInput, PublicacoesUncheckedCreateWithoutNotificacaoInput>
  }

  export type ConsultasCreateWithoutNotificacoesInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    status: $Enums.Consulta
    especialista: EspecialistasCreateNestedOneWithoutConsultasInput
    usuario: UsuariosCreateNestedOneWithoutConsultasInput
  }

  export type ConsultasUncheckedCreateWithoutNotificacoesInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    especialistaID: string
    status: $Enums.Consulta
    pacienteID: string
  }

  export type ConsultasCreateOrConnectWithoutNotificacoesInput = {
    where: ConsultasWhereUniqueInput
    create: XOR<ConsultasCreateWithoutNotificacoesInput, ConsultasUncheckedCreateWithoutNotificacoesInput>
  }

  export type UsuariosUpsertWithoutOrigemInput = {
    update: XOR<UsuariosUpdateWithoutOrigemInput, UsuariosUncheckedUpdateWithoutOrigemInput>
    create: XOR<UsuariosCreateWithoutOrigemInput, UsuariosUncheckedCreateWithoutOrigemInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutOrigemInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutOrigemInput, UsuariosUncheckedUpdateWithoutOrigemInput>
  }

  export type UsuariosUpdateWithoutOrigemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutOrigemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUpsertWithoutDestinatarioNotificacaoInput = {
    update: XOR<UsuariosUpdateWithoutDestinatarioNotificacaoInput, UsuariosUncheckedUpdateWithoutDestinatarioNotificacaoInput>
    create: XOR<UsuariosCreateWithoutDestinatarioNotificacaoInput, UsuariosUncheckedCreateWithoutDestinatarioNotificacaoInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutDestinatarioNotificacaoInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutDestinatarioNotificacaoInput, UsuariosUncheckedUpdateWithoutDestinatarioNotificacaoInput>
  }

  export type UsuariosUpdateWithoutDestinatarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutDestinatarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PublicacoesUpsertWithoutNotificacaoInput = {
    update: XOR<PublicacoesUpdateWithoutNotificacaoInput, PublicacoesUncheckedUpdateWithoutNotificacaoInput>
    create: XOR<PublicacoesCreateWithoutNotificacaoInput, PublicacoesUncheckedCreateWithoutNotificacaoInput>
    where?: PublicacoesWhereInput
  }

  export type PublicacoesUpdateToOneWithWhereWithoutNotificacaoInput = {
    where?: PublicacoesWhereInput
    data: XOR<PublicacoesUpdateWithoutNotificacaoInput, PublicacoesUncheckedUpdateWithoutNotificacaoInput>
  }

  export type PublicacoesUpdateWithoutNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioPub?: UsuariosUpdateOneRequiredWithoutPubblicacoesNestedInput
    reacoes?: ReacoesUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUncheckedUpdateWithoutNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    reacoes?: ReacoesUncheckedUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUncheckedUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUncheckedUpdateManyWithoutPostShareNestedInput
  }

  export type ConsultasUpsertWithoutNotificacoesInput = {
    update: XOR<ConsultasUpdateWithoutNotificacoesInput, ConsultasUncheckedUpdateWithoutNotificacoesInput>
    create: XOR<ConsultasCreateWithoutNotificacoesInput, ConsultasUncheckedCreateWithoutNotificacoesInput>
    where?: ConsultasWhereInput
  }

  export type ConsultasUpdateToOneWithWhereWithoutNotificacoesInput = {
    where?: ConsultasWhereInput
    data: XOR<ConsultasUpdateWithoutNotificacoesInput, ConsultasUncheckedUpdateWithoutNotificacoesInput>
  }

  export type ConsultasUpdateWithoutNotificacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    especialista?: EspecialistasUpdateOneRequiredWithoutConsultasNestedInput
    usuario?: UsuariosUpdateOneRequiredWithoutConsultasNestedInput
  }

  export type ConsultasUncheckedUpdateWithoutNotificacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    pacienteID?: StringFieldUpdateOperationsInput | string
  }

  export type UsuariosCreateWithoutSeguidorInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutSeguidorInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutSeguidorInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutSeguidorInput, UsuariosUncheckedCreateWithoutSeguidorInput>
  }

  export type EntidadesSistemaCreateWithoutSeguidoresInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    endereco: EnderecoCreateNestedOneWithoutEntitieInput
    contactos?: ContactosCreateNestedManyWithoutEntidadeInput
    especialista?: EspecialistasCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaUncheckedCreateWithoutSeguidoresInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
    enderecoID: string
    contactos?: ContactosUncheckedCreateNestedManyWithoutEntidadeInput
    especialista?: EspecialistasUncheckedCreateNestedManyWithoutEntidadeInput
  }

  export type EntidadesSistemaCreateOrConnectWithoutSeguidoresInput = {
    where: EntidadesSistemaWhereUniqueInput
    create: XOR<EntidadesSistemaCreateWithoutSeguidoresInput, EntidadesSistemaUncheckedCreateWithoutSeguidoresInput>
  }

  export type UsuariosUpsertWithoutSeguidorInput = {
    update: XOR<UsuariosUpdateWithoutSeguidorInput, UsuariosUncheckedUpdateWithoutSeguidorInput>
    create: XOR<UsuariosCreateWithoutSeguidorInput, UsuariosUncheckedCreateWithoutSeguidorInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutSeguidorInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutSeguidorInput, UsuariosUncheckedUpdateWithoutSeguidorInput>
  }

  export type UsuariosUpdateWithoutSeguidorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutSeguidorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EntidadesSistemaUpsertWithoutSeguidoresInput = {
    update: XOR<EntidadesSistemaUpdateWithoutSeguidoresInput, EntidadesSistemaUncheckedUpdateWithoutSeguidoresInput>
    create: XOR<EntidadesSistemaCreateWithoutSeguidoresInput, EntidadesSistemaUncheckedCreateWithoutSeguidoresInput>
    where?: EntidadesSistemaWhereInput
  }

  export type EntidadesSistemaUpdateToOneWithWhereWithoutSeguidoresInput = {
    where?: EntidadesSistemaWhereInput
    data: XOR<EntidadesSistemaUpdateWithoutSeguidoresInput, EntidadesSistemaUncheckedUpdateWithoutSeguidoresInput>
  }

  export type EntidadesSistemaUpdateWithoutSeguidoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: EnderecoUpdateOneRequiredWithoutEntitieNestedInput
    contactos?: ContactosUpdateManyWithoutEntidadeNestedInput
    especialista?: EspecialistasUpdateManyWithoutEntidadeNestedInput
  }

  export type EntidadesSistemaUncheckedUpdateWithoutSeguidoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoID?: StringFieldUpdateOperationsInput | string
    contactos?: ContactosUncheckedUpdateManyWithoutEntidadeNestedInput
    especialista?: EspecialistasUncheckedUpdateManyWithoutEntidadeNestedInput
  }

  export type UsuariosCreateWithoutMensagensEnviadasInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutMensagensEnviadasInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutMensagensEnviadasInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutMensagensEnviadasInput, UsuariosUncheckedCreateWithoutMensagensEnviadasInput>
  }

  export type UsuariosCreateWithoutMensagensRecebidasInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutMensagensRecebidasInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutMensagensRecebidasInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutMensagensRecebidasInput, UsuariosUncheckedCreateWithoutMensagensRecebidasInput>
  }

  export type UsuariosUpsertWithoutMensagensEnviadasInput = {
    update: XOR<UsuariosUpdateWithoutMensagensEnviadasInput, UsuariosUncheckedUpdateWithoutMensagensEnviadasInput>
    create: XOR<UsuariosCreateWithoutMensagensEnviadasInput, UsuariosUncheckedCreateWithoutMensagensEnviadasInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutMensagensEnviadasInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutMensagensEnviadasInput, UsuariosUncheckedUpdateWithoutMensagensEnviadasInput>
  }

  export type UsuariosUpdateWithoutMensagensEnviadasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutMensagensEnviadasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUpsertWithoutMensagensRecebidasInput = {
    update: XOR<UsuariosUpdateWithoutMensagensRecebidasInput, UsuariosUncheckedUpdateWithoutMensagensRecebidasInput>
    create: XOR<UsuariosCreateWithoutMensagensRecebidasInput, UsuariosUncheckedCreateWithoutMensagensRecebidasInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutMensagensRecebidasInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutMensagensRecebidasInput, UsuariosUncheckedUpdateWithoutMensagensRecebidasInput>
  }

  export type UsuariosUpdateWithoutMensagensRecebidasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutMensagensRecebidasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HorasDisponiveisCreateWithoutDiasDisponiveisInput = {
    id?: string
    hora: string
    especialista: EspecialistasCreateNestedOneWithoutHorasDisponiveisInput
  }

  export type HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput = {
    id?: string
    hora: string
    especialistaID: string
  }

  export type HorasDisponiveisCreateOrConnectWithoutDiasDisponiveisInput = {
    where: HorasDisponiveisWhereUniqueInput
    create: XOR<HorasDisponiveisCreateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput>
  }

  export type HorasDisponiveisCreateManyDiasDisponiveisInputEnvelope = {
    data: HorasDisponiveisCreateManyDiasDisponiveisInput | HorasDisponiveisCreateManyDiasDisponiveisInput[]
    skipDuplicates?: boolean
  }

  export type EspecialistasCreateWithoutDiasDisponiveisInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidade?: EntidadesSistemaCreateNestedOneWithoutEspecialistaInput
    horasDisponiveis?: HorasDisponiveisCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasUncheckedCreateWithoutDiasDisponiveisInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidadeID?: string | null
    horasDisponiveis?: HorasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasCreateOrConnectWithoutDiasDisponiveisInput = {
    where: EspecialistasWhereUniqueInput
    create: XOR<EspecialistasCreateWithoutDiasDisponiveisInput, EspecialistasUncheckedCreateWithoutDiasDisponiveisInput>
  }

  export type HorasDisponiveisUpsertWithWhereUniqueWithoutDiasDisponiveisInput = {
    where: HorasDisponiveisWhereUniqueInput
    update: XOR<HorasDisponiveisUpdateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedUpdateWithoutDiasDisponiveisInput>
    create: XOR<HorasDisponiveisCreateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedCreateWithoutDiasDisponiveisInput>
  }

  export type HorasDisponiveisUpdateWithWhereUniqueWithoutDiasDisponiveisInput = {
    where: HorasDisponiveisWhereUniqueInput
    data: XOR<HorasDisponiveisUpdateWithoutDiasDisponiveisInput, HorasDisponiveisUncheckedUpdateWithoutDiasDisponiveisInput>
  }

  export type HorasDisponiveisUpdateManyWithWhereWithoutDiasDisponiveisInput = {
    where: HorasDisponiveisScalarWhereInput
    data: XOR<HorasDisponiveisUpdateManyMutationInput, HorasDisponiveisUncheckedUpdateManyWithoutDiasDisponiveisInput>
  }

  export type EspecialistasUpsertWithoutDiasDisponiveisInput = {
    update: XOR<EspecialistasUpdateWithoutDiasDisponiveisInput, EspecialistasUncheckedUpdateWithoutDiasDisponiveisInput>
    create: XOR<EspecialistasCreateWithoutDiasDisponiveisInput, EspecialistasUncheckedCreateWithoutDiasDisponiveisInput>
    where?: EspecialistasWhereInput
  }

  export type EspecialistasUpdateToOneWithWhereWithoutDiasDisponiveisInput = {
    where?: EspecialistasWhereInput
    data: XOR<EspecialistasUpdateWithoutDiasDisponiveisInput, EspecialistasUncheckedUpdateWithoutDiasDisponiveisInput>
  }

  export type EspecialistasUpdateWithoutDiasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidade?: EntidadesSistemaUpdateOneWithoutEspecialistaNestedInput
    horasDisponiveis?: HorasDisponiveisUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasUncheckedUpdateWithoutDiasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidadeID?: NullableStringFieldUpdateOperationsInput | string | null
    horasDisponiveis?: HorasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutEspecialistaNestedInput
  }

  export type DiasDisponiveisCreateWithoutHorasDisponiveisInput = {
    id?: string
    date: Date | string
    especialista: EspecialistasCreateNestedOneWithoutDiasDisponiveisInput
  }

  export type DiasDisponiveisUncheckedCreateWithoutHorasDisponiveisInput = {
    id?: string
    date: Date | string
    especialistaID: string
  }

  export type DiasDisponiveisCreateOrConnectWithoutHorasDisponiveisInput = {
    where: DiasDisponiveisWhereUniqueInput
    create: XOR<DiasDisponiveisCreateWithoutHorasDisponiveisInput, DiasDisponiveisUncheckedCreateWithoutHorasDisponiveisInput>
  }

  export type EspecialistasCreateWithoutHorasDisponiveisInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidade?: EntidadesSistemaCreateNestedOneWithoutEspecialistaInput
    diasDisponiveis?: DiasDisponiveisCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasUncheckedCreateWithoutHorasDisponiveisInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidadeID?: string | null
    diasDisponiveis?: DiasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasCreateOrConnectWithoutHorasDisponiveisInput = {
    where: EspecialistasWhereUniqueInput
    create: XOR<EspecialistasCreateWithoutHorasDisponiveisInput, EspecialistasUncheckedCreateWithoutHorasDisponiveisInput>
  }

  export type DiasDisponiveisUpsertWithoutHorasDisponiveisInput = {
    update: XOR<DiasDisponiveisUpdateWithoutHorasDisponiveisInput, DiasDisponiveisUncheckedUpdateWithoutHorasDisponiveisInput>
    create: XOR<DiasDisponiveisCreateWithoutHorasDisponiveisInput, DiasDisponiveisUncheckedCreateWithoutHorasDisponiveisInput>
    where?: DiasDisponiveisWhereInput
  }

  export type DiasDisponiveisUpdateToOneWithWhereWithoutHorasDisponiveisInput = {
    where?: DiasDisponiveisWhereInput
    data: XOR<DiasDisponiveisUpdateWithoutHorasDisponiveisInput, DiasDisponiveisUncheckedUpdateWithoutHorasDisponiveisInput>
  }

  export type DiasDisponiveisUpdateWithoutHorasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    especialista?: EspecialistasUpdateOneRequiredWithoutDiasDisponiveisNestedInput
  }

  export type DiasDisponiveisUncheckedUpdateWithoutHorasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    especialistaID?: StringFieldUpdateOperationsInput | string
  }

  export type EspecialistasUpsertWithoutHorasDisponiveisInput = {
    update: XOR<EspecialistasUpdateWithoutHorasDisponiveisInput, EspecialistasUncheckedUpdateWithoutHorasDisponiveisInput>
    create: XOR<EspecialistasCreateWithoutHorasDisponiveisInput, EspecialistasUncheckedCreateWithoutHorasDisponiveisInput>
    where?: EspecialistasWhereInput
  }

  export type EspecialistasUpdateToOneWithWhereWithoutHorasDisponiveisInput = {
    where?: EspecialistasWhereInput
    data: XOR<EspecialistasUpdateWithoutHorasDisponiveisInput, EspecialistasUncheckedUpdateWithoutHorasDisponiveisInput>
  }

  export type EspecialistasUpdateWithoutHorasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidade?: EntidadesSistemaUpdateOneWithoutEspecialistaNestedInput
    diasDisponiveis?: DiasDisponiveisUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasUncheckedUpdateWithoutHorasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidadeID?: NullableStringFieldUpdateOperationsInput | string | null
    diasDisponiveis?: DiasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasCreateWithoutConsultasInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidade?: EntidadesSistemaCreateNestedOneWithoutEspecialistaInput
    diasDisponiveis?: DiasDisponiveisCreateNestedManyWithoutEspecialistaInput
    horasDisponiveis?: HorasDisponiveisCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasUncheckedCreateWithoutConsultasInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
    entidadeID?: string | null
    diasDisponiveis?: DiasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
    horasDisponiveis?: HorasDisponiveisUncheckedCreateNestedManyWithoutEspecialistaInput
  }

  export type EspecialistasCreateOrConnectWithoutConsultasInput = {
    where: EspecialistasWhereUniqueInput
    create: XOR<EspecialistasCreateWithoutConsultasInput, EspecialistasUncheckedCreateWithoutConsultasInput>
  }

  export type UsuariosCreateWithoutConsultasInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutConsultasInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutConsultasInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutConsultasInput, UsuariosUncheckedCreateWithoutConsultasInput>
  }

  export type NotificacoesCreateWithoutConsultaInput = {
    id?: string
    data?: Date | string
    tipo: string
    visto?: string | null
    usuarioNotificacao: UsuariosCreateNestedOneWithoutOrigemInput
    destinatarioNotificacao: UsuariosCreateNestedOneWithoutDestinatarioNotificacaoInput
    post: PublicacoesCreateNestedOneWithoutNotificacaoInput
  }

  export type NotificacoesUncheckedCreateWithoutConsultaInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    destinatarioID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesCreateOrConnectWithoutConsultaInput = {
    where: NotificacoesWhereUniqueInput
    create: XOR<NotificacoesCreateWithoutConsultaInput, NotificacoesUncheckedCreateWithoutConsultaInput>
  }

  export type NotificacoesCreateManyConsultaInputEnvelope = {
    data: NotificacoesCreateManyConsultaInput | NotificacoesCreateManyConsultaInput[]
    skipDuplicates?: boolean
  }

  export type EspecialistasUpsertWithoutConsultasInput = {
    update: XOR<EspecialistasUpdateWithoutConsultasInput, EspecialistasUncheckedUpdateWithoutConsultasInput>
    create: XOR<EspecialistasCreateWithoutConsultasInput, EspecialistasUncheckedCreateWithoutConsultasInput>
    where?: EspecialistasWhereInput
  }

  export type EspecialistasUpdateToOneWithWhereWithoutConsultasInput = {
    where?: EspecialistasWhereInput
    data: XOR<EspecialistasUpdateWithoutConsultasInput, EspecialistasUncheckedUpdateWithoutConsultasInput>
  }

  export type EspecialistasUpdateWithoutConsultasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidade?: EntidadesSistemaUpdateOneWithoutEspecialistaNestedInput
    diasDisponiveis?: DiasDisponiveisUpdateManyWithoutEspecialistaNestedInput
    horasDisponiveis?: HorasDisponiveisUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasUncheckedUpdateWithoutConsultasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    entidadeID?: NullableStringFieldUpdateOperationsInput | string | null
    diasDisponiveis?: DiasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
    horasDisponiveis?: HorasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
  }

  export type UsuariosUpsertWithoutConsultasInput = {
    update: XOR<UsuariosUpdateWithoutConsultasInput, UsuariosUncheckedUpdateWithoutConsultasInput>
    create: XOR<UsuariosCreateWithoutConsultasInput, UsuariosUncheckedCreateWithoutConsultasInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutConsultasInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutConsultasInput, UsuariosUncheckedUpdateWithoutConsultasInput>
  }

  export type UsuariosUpdateWithoutConsultasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutConsultasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificacoesUpsertWithWhereUniqueWithoutConsultaInput = {
    where: NotificacoesWhereUniqueInput
    update: XOR<NotificacoesUpdateWithoutConsultaInput, NotificacoesUncheckedUpdateWithoutConsultaInput>
    create: XOR<NotificacoesCreateWithoutConsultaInput, NotificacoesUncheckedCreateWithoutConsultaInput>
  }

  export type NotificacoesUpdateWithWhereUniqueWithoutConsultaInput = {
    where: NotificacoesWhereUniqueInput
    data: XOR<NotificacoesUpdateWithoutConsultaInput, NotificacoesUncheckedUpdateWithoutConsultaInput>
  }

  export type NotificacoesUpdateManyWithWhereWithoutConsultaInput = {
    where: NotificacoesScalarWhereInput
    data: XOR<NotificacoesUpdateManyMutationInput, NotificacoesUncheckedUpdateManyWithoutConsultaInput>
  }

  export type UsuariosCreateWithoutRemetenteInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutRemetenteInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutRemetenteInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutRemetenteInput, UsuariosUncheckedCreateWithoutRemetenteInput>
  }

  export type UsuariosCreateWithoutDestinatarioInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutDestinatarioInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutDestinatarioInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutDestinatarioInput, UsuariosUncheckedCreateWithoutDestinatarioInput>
  }

  export type UsuariosUpsertWithoutRemetenteInput = {
    update: XOR<UsuariosUpdateWithoutRemetenteInput, UsuariosUncheckedUpdateWithoutRemetenteInput>
    create: XOR<UsuariosCreateWithoutRemetenteInput, UsuariosUncheckedCreateWithoutRemetenteInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutRemetenteInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutRemetenteInput, UsuariosUncheckedUpdateWithoutRemetenteInput>
  }

  export type UsuariosUpdateWithoutRemetenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutRemetenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUpsertWithoutDestinatarioInput = {
    update: XOR<UsuariosUpdateWithoutDestinatarioInput, UsuariosUncheckedUpdateWithoutDestinatarioInput>
    create: XOR<UsuariosCreateWithoutDestinatarioInput, UsuariosUncheckedCreateWithoutDestinatarioInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutDestinatarioInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutDestinatarioInput, UsuariosUncheckedUpdateWithoutDestinatarioInput>
  }

  export type UsuariosUpdateWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosCreateWithoutEmissorDoPedidoInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutEmissorDoPedidoInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutEmissorDoPedidoInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutEmissorDoPedidoInput, UsuariosUncheckedCreateWithoutEmissorDoPedidoInput>
  }

  export type UsuariosCreateWithoutReceptorDoPedidoInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaCreateNestedManyWithoutUserInput
  }

  export type UsuariosUncheckedCreateWithoutReceptorDoPedidoInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
    partilha?: PartilhaUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsuariosCreateOrConnectWithoutReceptorDoPedidoInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutReceptorDoPedidoInput, UsuariosUncheckedCreateWithoutReceptorDoPedidoInput>
  }

  export type UsuariosUpsertWithoutEmissorDoPedidoInput = {
    update: XOR<UsuariosUpdateWithoutEmissorDoPedidoInput, UsuariosUncheckedUpdateWithoutEmissorDoPedidoInput>
    create: XOR<UsuariosCreateWithoutEmissorDoPedidoInput, UsuariosUncheckedCreateWithoutEmissorDoPedidoInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutEmissorDoPedidoInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutEmissorDoPedidoInput, UsuariosUncheckedUpdateWithoutEmissorDoPedidoInput>
  }

  export type UsuariosUpdateWithoutEmissorDoPedidoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutEmissorDoPedidoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUpsertWithoutReceptorDoPedidoInput = {
    update: XOR<UsuariosUpdateWithoutReceptorDoPedidoInput, UsuariosUncheckedUpdateWithoutReceptorDoPedidoInput>
    create: XOR<UsuariosCreateWithoutReceptorDoPedidoInput, UsuariosUncheckedCreateWithoutReceptorDoPedidoInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutReceptorDoPedidoInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutReceptorDoPedidoInput, UsuariosUncheckedUpdateWithoutReceptorDoPedidoInput>
  }

  export type UsuariosUpdateWithoutReceptorDoPedidoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUpdateManyWithoutUserNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutReceptorDoPedidoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
    partilha?: PartilhaUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsuariosCreateWithoutPartilhaInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesCreateNestedManyWithoutUserInput
    comentarios?: ComentariosCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresCreateNestedManyWithoutSeguidorInput
  }

  export type UsuariosUncheckedCreateWithoutPartilhaInput = {
    id?: string
    name: string
    email: string
    crm?: string | null
    cnpj?: string | null
    foto?: string | null
    senha: string
    sobre?: string | null
    sexo: $Enums.Sexo
    socketID?: string | null
    nascimento: Date | string
    contactos?: ContactosUncheckedCreateNestedManyWithoutUsuarioInput
    pubblicacoes?: PublicacoesUncheckedCreateNestedManyWithoutUsuarioPubInput
    origem?: NotificacoesUncheckedCreateNestedManyWithoutUsuarioNotificacaoInput
    destinatarioNotificacao?: NotificacoesUncheckedCreateNestedManyWithoutDestinatarioNotificacaoInput
    consultas?: ConsultasUncheckedCreateNestedManyWithoutUsuarioInput
    mensagensEnviadas?: MensagensUncheckedCreateNestedManyWithoutEmissorInput
    mensagensRecebidas?: MensagensUncheckedCreateNestedManyWithoutReceptorInput
    remetente?: MinhasConexoesUncheckedCreateNestedManyWithoutUserInput
    destinatario?: MinhasConexoesUncheckedCreateNestedManyWithoutFriendInput
    emissorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutUserInput
    receptorDoPedido?: PedidoDeConexaoUncheckedCreateNestedManyWithoutDestinatarioInput
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutAutorInput
    seguidor?: SeguidoresUncheckedCreateNestedManyWithoutSeguidorInput
  }

  export type UsuariosCreateOrConnectWithoutPartilhaInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutPartilhaInput, UsuariosUncheckedCreateWithoutPartilhaInput>
  }

  export type PublicacoesCreateWithoutPostPartilhadoInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioPub: UsuariosCreateNestedOneWithoutPubblicacoesInput
    reacoes?: ReacoesCreateNestedManyWithoutPostInput
    comentarios?: ComentariosCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesCreateNestedManyWithoutPostInput
    postCriado?: PartilhaCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesUncheckedCreateWithoutPostPartilhadoInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioID: string
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutPostInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesUncheckedCreateNestedManyWithoutPostInput
    postCriado?: PartilhaUncheckedCreateNestedManyWithoutPostShareInput
  }

  export type PublicacoesCreateOrConnectWithoutPostPartilhadoInput = {
    where: PublicacoesWhereUniqueInput
    create: XOR<PublicacoesCreateWithoutPostPartilhadoInput, PublicacoesUncheckedCreateWithoutPostPartilhadoInput>
  }

  export type PublicacoesCreateWithoutPostCriadoInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioPub: UsuariosCreateNestedOneWithoutPubblicacoesInput
    reacoes?: ReacoesCreateNestedManyWithoutPostInput
    comentarios?: ComentariosCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaCreateNestedManyWithoutPostInput
  }

  export type PublicacoesUncheckedCreateWithoutPostCriadoInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
    usuarioID: string
    reacoes?: ReacoesUncheckedCreateNestedManyWithoutPostInput
    comentarios?: ComentariosUncheckedCreateNestedManyWithoutPostInput
    notificacao?: NotificacoesUncheckedCreateNestedManyWithoutPostInput
    postPartilhado?: PartilhaUncheckedCreateNestedManyWithoutPostInput
  }

  export type PublicacoesCreateOrConnectWithoutPostCriadoInput = {
    where: PublicacoesWhereUniqueInput
    create: XOR<PublicacoesCreateWithoutPostCriadoInput, PublicacoesUncheckedCreateWithoutPostCriadoInput>
  }

  export type UsuariosUpsertWithoutPartilhaInput = {
    update: XOR<UsuariosUpdateWithoutPartilhaInput, UsuariosUncheckedUpdateWithoutPartilhaInput>
    create: XOR<UsuariosCreateWithoutPartilhaInput, UsuariosUncheckedCreateWithoutPartilhaInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutPartilhaInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutPartilhaInput, UsuariosUncheckedUpdateWithoutPartilhaInput>
  }

  export type UsuariosUpdateWithoutPartilhaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUpdateManyWithoutSeguidorNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutPartilhaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    crm?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    socketID?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: DateTimeFieldUpdateOperationsInput | Date | string
    contactos?: ContactosUncheckedUpdateManyWithoutUsuarioNestedInput
    pubblicacoes?: PublicacoesUncheckedUpdateManyWithoutUsuarioPubNestedInput
    origem?: NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoNestedInput
    destinatarioNotificacao?: NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutUsuarioNestedInput
    mensagensEnviadas?: MensagensUncheckedUpdateManyWithoutEmissorNestedInput
    mensagensRecebidas?: MensagensUncheckedUpdateManyWithoutReceptorNestedInput
    remetente?: MinhasConexoesUncheckedUpdateManyWithoutUserNestedInput
    destinatario?: MinhasConexoesUncheckedUpdateManyWithoutFriendNestedInput
    emissorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutUserNestedInput
    receptorDoPedido?: PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioNestedInput
    reacoes?: ReacoesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutAutorNestedInput
    seguidor?: SeguidoresUncheckedUpdateManyWithoutSeguidorNestedInput
  }

  export type PublicacoesUpsertWithoutPostPartilhadoInput = {
    update: XOR<PublicacoesUpdateWithoutPostPartilhadoInput, PublicacoesUncheckedUpdateWithoutPostPartilhadoInput>
    create: XOR<PublicacoesCreateWithoutPostPartilhadoInput, PublicacoesUncheckedCreateWithoutPostPartilhadoInput>
    where?: PublicacoesWhereInput
  }

  export type PublicacoesUpdateToOneWithWhereWithoutPostPartilhadoInput = {
    where?: PublicacoesWhereInput
    data: XOR<PublicacoesUpdateWithoutPostPartilhadoInput, PublicacoesUncheckedUpdateWithoutPostPartilhadoInput>
  }

  export type PublicacoesUpdateWithoutPostPartilhadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioPub?: UsuariosUpdateOneRequiredWithoutPubblicacoesNestedInput
    reacoes?: ReacoesUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUncheckedUpdateWithoutPostPartilhadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    reacoes?: ReacoesUncheckedUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUncheckedUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUncheckedUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUpsertWithoutPostCriadoInput = {
    update: XOR<PublicacoesUpdateWithoutPostCriadoInput, PublicacoesUncheckedUpdateWithoutPostCriadoInput>
    create: XOR<PublicacoesCreateWithoutPostCriadoInput, PublicacoesUncheckedCreateWithoutPostCriadoInput>
    where?: PublicacoesWhereInput
  }

  export type PublicacoesUpdateToOneWithWhereWithoutPostCriadoInput = {
    where?: PublicacoesWhereInput
    data: XOR<PublicacoesUpdateWithoutPostCriadoInput, PublicacoesUncheckedUpdateWithoutPostCriadoInput>
  }

  export type PublicacoesUpdateWithoutPostCriadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioPub?: UsuariosUpdateOneRequiredWithoutPubblicacoesNestedInput
    reacoes?: ReacoesUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUpdateManyWithoutPostNestedInput
  }

  export type PublicacoesUncheckedUpdateWithoutPostCriadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    reacoes?: ReacoesUncheckedUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUncheckedUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ContactosCreateManyEntidadeInput = {
    id?: string
    contacto: string
    usuarioID: string
  }

  export type EspecialistasCreateManyEntidadeInput = {
    id?: string
    nome: string
    crm: string
    especialidade: string
    tipo_De_Consulta: string
    valor?: string | null
    bloqueado?: string | null
    sexo: $Enums.Sexo
  }

  export type SeguidoresCreateManyEntidadeInput = {
    id?: string
    seguidorID: string
  }

  export type ContactosUpdateWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    usuario?: UsuariosUpdateOneRequiredWithoutContactosNestedInput
  }

  export type ContactosUncheckedUpdateWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    usuarioID?: StringFieldUpdateOperationsInput | string
  }

  export type ContactosUncheckedUpdateManyWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    usuarioID?: StringFieldUpdateOperationsInput | string
  }

  export type EspecialistasUpdateWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    diasDisponiveis?: DiasDisponiveisUpdateManyWithoutEspecialistaNestedInput
    horasDisponiveis?: HorasDisponiveisUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasUncheckedUpdateWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    diasDisponiveis?: DiasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
    horasDisponiveis?: HorasDisponiveisUncheckedUpdateManyWithoutEspecialistaNestedInput
    consultas?: ConsultasUncheckedUpdateManyWithoutEspecialistaNestedInput
  }

  export type EspecialistasUncheckedUpdateManyWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    crm?: StringFieldUpdateOperationsInput | string
    especialidade?: StringFieldUpdateOperationsInput | string
    tipo_De_Consulta?: StringFieldUpdateOperationsInput | string
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    bloqueado?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
  }

  export type SeguidoresUpdateWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seguidor?: UsuariosUpdateOneRequiredWithoutSeguidorNestedInput
  }

  export type SeguidoresUncheckedUpdateWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seguidorID?: StringFieldUpdateOperationsInput | string
  }

  export type SeguidoresUncheckedUpdateManyWithoutEntidadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seguidorID?: StringFieldUpdateOperationsInput | string
  }

  export type EntidadesSistemaCreateManyEnderecoInput = {
    id?: string
    name: string
    cnpj: string
    tipo_entidade: string
    sobre?: string | null
    email: string
    foto?: string | null
  }

  export type EntidadesSistemaUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    contactos?: ContactosUpdateManyWithoutEntidadeNestedInput
    especialista?: EspecialistasUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUpdateManyWithoutEntidadeNestedInput
  }

  export type EntidadesSistemaUncheckedUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    contactos?: ContactosUncheckedUpdateManyWithoutEntidadeNestedInput
    especialista?: EspecialistasUncheckedUpdateManyWithoutEntidadeNestedInput
    seguidores?: SeguidoresUncheckedUpdateManyWithoutEntidadeNestedInput
  }

  export type EntidadesSistemaUncheckedUpdateManyWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    tipo_entidade?: StringFieldUpdateOperationsInput | string
    sobre?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiasDisponiveisCreateManyEspecialistaInput = {
    id?: string
    date: Date | string
  }

  export type HorasDisponiveisCreateManyEspecialistaInput = {
    id?: string
    hora: string
    diasDisponiveisID: string
  }

  export type ConsultasCreateManyEspecialistaInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    status: $Enums.Consulta
    pacienteID: string
  }

  export type DiasDisponiveisUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    horasDisponiveis?: HorasDisponiveisUpdateManyWithoutDiasDisponiveisNestedInput
  }

  export type DiasDisponiveisUncheckedUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    horasDisponiveis?: HorasDisponiveisUncheckedUpdateManyWithoutDiasDisponiveisNestedInput
  }

  export type DiasDisponiveisUncheckedUpdateManyWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HorasDisponiveisUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    diasDisponiveis?: DiasDisponiveisUpdateOneRequiredWithoutHorasDisponiveisNestedInput
  }

  export type HorasDisponiveisUncheckedUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    diasDisponiveisID?: StringFieldUpdateOperationsInput | string
  }

  export type HorasDisponiveisUncheckedUpdateManyWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    diasDisponiveisID?: StringFieldUpdateOperationsInput | string
  }

  export type ConsultasUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    usuario?: UsuariosUpdateOneRequiredWithoutConsultasNestedInput
    notificacoes?: NotificacoesUpdateManyWithoutConsultaNestedInput
  }

  export type ConsultasUncheckedUpdateWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    pacienteID?: StringFieldUpdateOperationsInput | string
    notificacoes?: NotificacoesUncheckedUpdateManyWithoutConsultaNestedInput
  }

  export type ConsultasUncheckedUpdateManyWithoutEspecialistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    pacienteID?: StringFieldUpdateOperationsInput | string
  }

  export type ContactosCreateManyUsuarioInput = {
    id?: string
    contacto: string
    entidadeID: string
  }

  export type PublicacoesCreateManyUsuarioPubInput = {
    id?: string
    conteudo: string
    foto?: string | null
    video?: string | null
    data?: Date | string
    updatedAt?: Date | string
  }

  export type NotificacoesCreateManyUsuarioNotificacaoInput = {
    id?: string
    data?: Date | string
    destinatarioID: string
    consultaID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesCreateManyDestinatarioNotificacaoInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    consultaID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type ConsultasCreateManyUsuarioInput = {
    id?: string
    tipo_Da_Consulta: string
    data: Date | string
    hora: string
    especialistaID: string
    status: $Enums.Consulta
  }

  export type MensagensCreateManyEmissorInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    receptorID: string
    visto?: boolean
  }

  export type MensagensCreateManyReceptorInput = {
    id?: string
    conteudo?: string | null
    foto?: string | null
    video?: string | null
    arquivo?: string | null
    data?: Date | string
    emissorID: string
    visto?: boolean
  }

  export type MinhasConexoesCreateManyUserInput = {
    id?: string
    friendID: string
  }

  export type MinhasConexoesCreateManyFriendInput = {
    id?: string
    userID: string
  }

  export type PedidoDeConexaoCreateManyUserInput = {
    id?: string
    destinatarioID: string
  }

  export type PedidoDeConexaoCreateManyDestinatarioInput = {
    id?: string
    userID: string
  }

  export type ReacoesCreateManyUserInput = {
    id?: string
    postId: string
    type: string
    createdAt?: Date | string
  }

  export type ComentariosCreateManyAutorInput = {
    id?: string
    postId: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeguidoresCreateManySeguidorInput = {
    id?: string
    entidadeID: string
  }

  export type PartilhaCreateManyUserInput = {
    id?: string
    createPostShareID: string
    postShareID: string
    createdAt?: Date | string
  }

  export type ContactosUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    entidade?: EntidadesSistemaUpdateOneRequiredWithoutContactosNestedInput
  }

  export type ContactosUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
  }

  export type ContactosUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    contacto?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
  }

  export type PublicacoesUpdateWithoutUsuarioPubInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reacoes?: ReacoesUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUncheckedUpdateWithoutUsuarioPubInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reacoes?: ReacoesUncheckedUpdateManyWithoutPostNestedInput
    comentarios?: ComentariosUncheckedUpdateManyWithoutPostNestedInput
    notificacao?: NotificacoesUncheckedUpdateManyWithoutPostNestedInput
    postPartilhado?: PartilhaUncheckedUpdateManyWithoutPostNestedInput
    postCriado?: PartilhaUncheckedUpdateManyWithoutPostShareNestedInput
  }

  export type PublicacoesUncheckedUpdateManyWithoutUsuarioPubInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacoesUpdateWithoutUsuarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarioNotificacao?: UsuariosUpdateOneRequiredWithoutDestinatarioNotificacaoNestedInput
    post?: PublicacoesUpdateOneRequiredWithoutNotificacaoNestedInput
    consulta?: ConsultasUpdateOneRequiredWithoutNotificacoesNestedInput
  }

  export type NotificacoesUncheckedUpdateWithoutUsuarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacoesUncheckedUpdateManyWithoutUsuarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacoesUpdateWithoutDestinatarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNotificacao?: UsuariosUpdateOneRequiredWithoutOrigemNestedInput
    post?: PublicacoesUpdateOneRequiredWithoutNotificacaoNestedInput
    consulta?: ConsultasUpdateOneRequiredWithoutNotificacoesNestedInput
  }

  export type NotificacoesUncheckedUpdateWithoutDestinatarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacoesUncheckedUpdateManyWithoutDestinatarioNotificacaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsultasUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    especialista?: EspecialistasUpdateOneRequiredWithoutConsultasNestedInput
    notificacoes?: NotificacoesUpdateManyWithoutConsultaNestedInput
  }

  export type ConsultasUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
    notificacoes?: NotificacoesUncheckedUpdateManyWithoutConsultaNestedInput
  }

  export type ConsultasUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo_Da_Consulta?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
    status?: EnumConsultaFieldUpdateOperationsInput | $Enums.Consulta
  }

  export type MensagensUpdateWithoutEmissorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    visto?: BoolFieldUpdateOperationsInput | boolean
    receptor?: UsuariosUpdateOneRequiredWithoutMensagensRecebidasNestedInput
  }

  export type MensagensUncheckedUpdateWithoutEmissorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    receptorID?: StringFieldUpdateOperationsInput | string
    visto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensagensUncheckedUpdateManyWithoutEmissorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    receptorID?: StringFieldUpdateOperationsInput | string
    visto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensagensUpdateWithoutReceptorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    visto?: BoolFieldUpdateOperationsInput | boolean
    emissor?: UsuariosUpdateOneRequiredWithoutMensagensEnviadasNestedInput
  }

  export type MensagensUncheckedUpdateWithoutReceptorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    emissorID?: StringFieldUpdateOperationsInput | string
    visto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MensagensUncheckedUpdateManyWithoutReceptorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    arquivo?: NullableStringFieldUpdateOperationsInput | string | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    emissorID?: StringFieldUpdateOperationsInput | string
    visto?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MinhasConexoesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friend?: UsuariosUpdateOneRequiredWithoutDestinatarioNestedInput
  }

  export type MinhasConexoesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendID?: StringFieldUpdateOperationsInput | string
  }

  export type MinhasConexoesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendID?: StringFieldUpdateOperationsInput | string
  }

  export type MinhasConexoesUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UsuariosUpdateOneRequiredWithoutRemetenteNestedInput
  }

  export type MinhasConexoesUncheckedUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type MinhasConexoesUncheckedUpdateManyWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoDeConexaoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatario?: UsuariosUpdateOneRequiredWithoutReceptorDoPedidoNestedInput
  }

  export type PedidoDeConexaoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoDeConexaoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoDeConexaoUpdateWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UsuariosUpdateOneRequiredWithoutEmissorDoPedidoNestedInput
  }

  export type PedidoDeConexaoUncheckedUpdateWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoDeConexaoUncheckedUpdateManyWithoutDestinatarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type ReacoesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PublicacoesUpdateOneRequiredWithoutReacoesNestedInput
  }

  export type ReacoesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReacoesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentariosUpdateWithoutAutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PublicacoesUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentariosUncheckedUpdateWithoutAutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentariosUncheckedUpdateManyWithoutAutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeguidoresUpdateWithoutSeguidorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entidade?: EntidadesSistemaUpdateOneRequiredWithoutSeguidoresNestedInput
  }

  export type SeguidoresUncheckedUpdateWithoutSeguidorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
  }

  export type SeguidoresUncheckedUpdateManyWithoutSeguidorInput = {
    id?: StringFieldUpdateOperationsInput | string
    entidadeID?: StringFieldUpdateOperationsInput | string
  }

  export type PartilhaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PublicacoesUpdateOneRequiredWithoutPostPartilhadoNestedInput
    postShare?: PublicacoesUpdateOneRequiredWithoutPostCriadoNestedInput
  }

  export type PartilhaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createPostShareID?: StringFieldUpdateOperationsInput | string
    postShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartilhaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createPostShareID?: StringFieldUpdateOperationsInput | string
    postShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReacoesCreateManyPostInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type ComentariosCreateManyPostInput = {
    id?: string
    autorId: string
    conteudo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificacoesCreateManyPostInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    destinatarioID: string
    consultaID: string
    tipo: string
    visto?: string | null
  }

  export type PartilhaCreateManyPostInput = {
    id?: string
    userID: string
    createPostShareID: string
    createdAt?: Date | string
  }

  export type PartilhaCreateManyPostShareInput = {
    id?: string
    userID: string
    postShareID: string
    createdAt?: Date | string
  }

  export type ReacoesUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsuariosUpdateOneRequiredWithoutReacoesNestedInput
  }

  export type ReacoesUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReacoesUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentariosUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autor?: UsuariosUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentariosUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentariosUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacoesUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNotificacao?: UsuariosUpdateOneRequiredWithoutOrigemNestedInput
    destinatarioNotificacao?: UsuariosUpdateOneRequiredWithoutDestinatarioNotificacaoNestedInput
    consulta?: ConsultasUpdateOneRequiredWithoutNotificacoesNestedInput
  }

  export type NotificacoesUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacoesUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    consultaID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartilhaUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsuariosUpdateOneRequiredWithoutPartilhaNestedInput
    postShare?: PublicacoesUpdateOneRequiredWithoutPostCriadoNestedInput
  }

  export type PartilhaUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createPostShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartilhaUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createPostShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartilhaUpdateWithoutPostShareInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsuariosUpdateOneRequiredWithoutPartilhaNestedInput
    post?: PublicacoesUpdateOneRequiredWithoutPostPartilhadoNestedInput
  }

  export type PartilhaUncheckedUpdateWithoutPostShareInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    postShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartilhaUncheckedUpdateManyWithoutPostShareInput = {
    id?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    postShareID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HorasDisponiveisCreateManyDiasDisponiveisInput = {
    id?: string
    hora: string
    especialistaID: string
  }

  export type HorasDisponiveisUpdateWithoutDiasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    especialista?: EspecialistasUpdateOneRequiredWithoutHorasDisponiveisNestedInput
  }

  export type HorasDisponiveisUncheckedUpdateWithoutDiasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
  }

  export type HorasDisponiveisUncheckedUpdateManyWithoutDiasDisponiveisInput = {
    id?: StringFieldUpdateOperationsInput | string
    hora?: StringFieldUpdateOperationsInput | string
    especialistaID?: StringFieldUpdateOperationsInput | string
  }

  export type NotificacoesCreateManyConsultaInput = {
    id?: string
    data?: Date | string
    usuarioID: string
    destinatarioID: string
    postID: string
    tipo: string
    visto?: string | null
  }

  export type NotificacoesUpdateWithoutConsultaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNotificacao?: UsuariosUpdateOneRequiredWithoutOrigemNestedInput
    destinatarioNotificacao?: UsuariosUpdateOneRequiredWithoutDestinatarioNotificacaoNestedInput
    post?: PublicacoesUpdateOneRequiredWithoutNotificacaoNestedInput
  }

  export type NotificacoesUncheckedUpdateWithoutConsultaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacoesUncheckedUpdateManyWithoutConsultaInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioID?: StringFieldUpdateOperationsInput | string
    destinatarioID?: StringFieldUpdateOperationsInput | string
    postID?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    visto?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use EntidadesSistemaCountOutputTypeDefaultArgs instead
     */
    export type EntidadesSistemaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntidadesSistemaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnderecoCountOutputTypeDefaultArgs instead
     */
    export type EnderecoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnderecoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecialistasCountOutputTypeDefaultArgs instead
     */
    export type EspecialistasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecialistasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuariosCountOutputTypeDefaultArgs instead
     */
    export type UsuariosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuariosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicacoesCountOutputTypeDefaultArgs instead
     */
    export type PublicacoesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicacoesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiasDisponiveisCountOutputTypeDefaultArgs instead
     */
    export type DiasDisponiveisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiasDisponiveisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultasCountOutputTypeDefaultArgs instead
     */
    export type ConsultasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntidadesSistemaDefaultArgs instead
     */
    export type EntidadesSistemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntidadesSistemaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnderecoDefaultArgs instead
     */
    export type EnderecoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnderecoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactosDefaultArgs instead
     */
    export type ContactosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecialistasDefaultArgs instead
     */
    export type EspecialistasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecialistasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuariosDefaultArgs instead
     */
    export type UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuariosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicacoesDefaultArgs instead
     */
    export type PublicacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicacoesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComentariosDefaultArgs instead
     */
    export type ComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComentariosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReacoesDefaultArgs instead
     */
    export type ReacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReacoesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificacoesDefaultArgs instead
     */
    export type NotificacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificacoesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeguidoresDefaultArgs instead
     */
    export type SeguidoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeguidoresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MensagensDefaultArgs instead
     */
    export type MensagensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MensagensDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiasDisponiveisDefaultArgs instead
     */
    export type DiasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiasDisponiveisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HorasDisponiveisDefaultArgs instead
     */
    export type HorasDisponiveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HorasDisponiveisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultasDefaultArgs instead
     */
    export type ConsultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoCallDefaultArgs instead
     */
    export type VideoCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoCallDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinhasConexoesDefaultArgs instead
     */
    export type MinhasConexoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinhasConexoesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoDeConexaoDefaultArgs instead
     */
    export type PedidoDeConexaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoDeConexaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartilhaDefaultArgs instead
     */
    export type PartilhaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartilhaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}